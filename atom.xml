<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>乘风破浪</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.python100.com/"/>
  <updated>2018-07-31T15:48:41.124Z</updated>
  <id>http://www.python100.com/</id>
  
  <author>
    <name>chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>系统开机过程</title>
    <link href="http://www.python100.com/2018/07/31/%E7%B3%BB%E7%BB%9F%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.python100.com/2018/07/31/系统开机过程/</id>
    <published>2018-07-31T15:29:00.000Z</published>
    <updated>2018-07-31T15:48:41.124Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><p><img src="/images/系统开机过程.assets/1533042168708.png" alt="1533042168708"></p><p><strong>步骤1：</strong>上电自检POST(Power-on self test)，主要负责检测系统外围关键设备（如：CPU、内存、显卡、I/O、键盘鼠标等）是否正常。例如，最常见的是内存松动的情况，BIOS自检阶段会报错，系统就无法启动起来；</p><p><strong>步骤2：</strong>步骤1成功后，便会执行一段小程序用来枚举本地设备并对其初始化。这一步主要是根据我们在BIOS中设置的系统启动顺序来搜索用于启动系统的驱动器，如硬盘、光盘、U盘、软盘和网络等。我们以硬盘启动为例，BIOS此时去读取硬盘驱动器的第一个扇区(MBR，512字节)，然后执行里面的代码。实际上这里BIOS并不关心启动设备第一个扇区中是什么内容，它只是负责读取该扇区内容、并执行。至此，BIOS的任务就完成了，此后将系统启动的控制权移交到MBR部分的代码。</p><p><strong>步骤3</strong>：系统引导</p><p>grub引导也分为两个阶段stage1阶段和stage2阶段</p><p>1)、stage1：stage1是直接被写入到MBR中去的，这样机器一启动检测完硬件后，就将控制权交给了GRUB的代码。 BIOS将stage1载入内存中0x7c00处并跳转执行。stage1（/stage1/start.S）的任务非常单纯，仅仅是将硬盘0头0道2扇区读入内存。而0头0道2扇区内容是源代码中的/stage2/start.S，编译后512字节，它是stage2或者stage1_5的入口。而此时，stage1是没有识别文件系统的能力的。</p><p>2)、stage2： 它的主要作用就是负责将stage2或stage1.5从硬盘读到内存中。如果是stage2，它将被载入到0x820处；如果是stage1.5，它将被载入到0x2200处。这里的stage2或者stage1_5不是/boot分区/boot/grub目录下的文件，因为这个时候grub还没有能力识别任何文件系统。</p><p><strong>步骤4</strong>：启动内核</p><p>当stage2被载入内存执行时，它首先会去解析grub的配置文件/boot/grub/grub.conf，然后加载内核镜像到内存中，并将控制权转交给内核。而内核会立即初始化系统中各设备并做相关的配置工作，其中包括CPU、I/O、存储设备等。</p><p>Linux的内核镜像仅是包含了基本的硬件驱动，在系统安装过程中会检测系统硬件信息，根据安装信息和系统硬件信息将一部分设备驱动写入 initrd 。这样在以后启动系统时，一部分设备驱动就放在initrd中来加载。</p><p>grub的stage2将initrd加载到内存里，让后将其中的内容释放到内容中，内核便去执行initrd中的init脚本，这时内核将控制权交给了init文件处理。我们简单浏览一下init脚本的内容，发现它也主要是加载各种存储介质相关的设备驱动程序。当所需的驱动程序加载完后，会创建一个根设备，然后将根文件系统rootfs以只读的方式挂载。这一步结束后，释放未使用的内存，转换到真正的根文件系统上面去，同时运行/sbin/init程序，执行系统的1号进程。此后系统的控制权就全权交给/sbin/init进程了。</p><p><strong>步骤5</strong>：初始化系统</p><p>1)、执行系统初始化脚本(/etc/rc.d/rc.sysinit)，对系统进行基本的配置，以读写方式挂载根文件系统及其它文件系统，到此系统算是基本运行起来了，后面需要进行运行级别的确定及相应服务的启动。</p><p>2)、执行/etc/rc.d/rc脚本。该文件定义了服务启动的顺序是先K后S，而具体的每个运行级别的服务状态是放在/etc/rc.d/rc<em>.d（</em>=0~6）目录下，所有的文件均是指向/etc/init.d下相应文件的符号链接。rc.sysinit通过分析/etc/inittab文件来确定系统的启动级别，然后才去执行/etc/rc.d/rc*.d下的文件。</p><p>3)、执行用户自定义引导程序/etc/rc.d/rc.local。其实当执行/etc/rc.d/rc3.d/S99local时，它就是在执行/etc/rc.d/rc.local。S99local是指向rc.local的符号链接。</p><p>4)、完成了系统所有的启动任务后，linux会启动终端或X-Window来等待用户登录。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&quot;/images/系统开机过程.assets/1533042168708.png&quot; alt=&quot;1533042168708&quot;&gt;&lt;/p
      
    
    </summary>
    
      <category term="linux" scheme="http://www.python100.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>DevOps是什么</title>
    <link href="http://www.python100.com/2018/07/31/DevOps%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://www.python100.com/2018/07/31/DevOps是什么/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:58:10.278Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><p><strong>DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称</strong>，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。</p><p>它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p><p>它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作。</p><p><strong>DevOps 是一种工程模式，本质上是一种分工，通过对开发、运维、测试，配管等角色职责的分工，实现工程效率最大化，进而满足业务的需求。</strong></p><p><strong>DevOps的核心是角色的分工</strong>，而不是组织架构变化，垂直化的组织架构不代表可以实现DevOps所需要的分工模式，横向的组织架构也不代表传统的分工模式。</p><p><strong>DevOps的目标是工程效率最大化</strong>，它本身也只是一种方法论，是为了实现工程效率最大化的目标而存在的。</p><p><strong>DevOps与传统模式的区别</strong></p><p>传统分工模式下，PD将需求提出来，开发者根据需求写代码，然后告诉SCM，SCM拿着代码去打包，打包后告诉QA，QA测试完成后通知运维OPS上线，OPS进行上线部署，最后整个需求得到release。</p><p><strong>它的优势在于</strong>：分工与责任清晰，质量有保障，层层制约，容易把控。</p><p>它的劣势也很明显：沟通成本与等待成本高，每一个环节都有成为瓶颈的风险，比如DEV知道怎样写代码，但QA也需要了解需求才能知道怎么做测试，OPS也需要了解需求维持线上稳定性，OPS负责交付，容易演变成擦屁股的角色，包括日常出现的bug。</p><p>在DevOps分工模式下，一切都改变了，不再是每个人做完自己的事情然后交给下一个人。这个分工模式下，开发通过工具驱动所有流程运转向前走，比如开发写完代码通过工具驱动自动化打包，自动化测试，自动化部署或升级，还会配备监控；SCM、OPS和QA等在工具的外围，确保在工具中的每一个环节可以正常运转，它们支撑工具的目的是确保DEV可以使用工具完成人肉完成的事情，这是决策的变化，还要保证工具中的几个模块可以支撑最新的业务变化，当业务有了更新的变化时，须保证工具可以支撑开发。</p><p>DevOps分工模式的好处很明显：可以减少沟通成本与等待风险，降低正常需求交付所需时间，DEV负责交付，避免交付扯皮。</p><p>DevOps分工模式的劣势也很突出：每个环节参与角色较多，风险较高，对于业务形态比较多的企业较明显，工具支撑多种业务形态的成本是非常高的，当工具搞不定时，需要人肉补位保证业务发布，如果补位较多，那么DevOps分工就失败了；专业度会有降低，工具只能支持在精确输入的情况下以非常精确的方式完成一件固定的事情，一旦输入有变化而超出规则，该环节就比较麻烦了，工具的专业提升比人要慢的多；DEV权利过大，容易军阀化。</p><p>DevOps的难点和需要解决的问题</p><p>寻找平衡点</p><p>DevOps是为了追求工程效率最大化而存在的，但是工程效率和稳定性的目标在大部分场景下都是相悖的，如何能够在工程效率提升的前提下，保证稳定性不出问题？</p><p>传统分工模式是OPS团队负责，在DevOps分工模式中已经没有OPS团队了，只能开发团队负责，当一个团队同时负责两个相互有冲突的case时，该怎么办呢？如果分成两部分人分别负责业务KPI和稳定性KPI，就回到了传统的分工模式。</p><p>责权划分</p><p>对于开发者而言，主业是coding，其它包括打包、测试、发布都是辅业，它是工具的使用者，并不能完全将所有事情做得完美，在除coding以外的所有环节中，责任和分工要怎么来分，除了开发以外的事情要占用开发人员多少精力，才能保证DEV使用顺畅，跟上公司业务发展？</p><p>其中核心是工具，工具是将二者粘合在一起的，工具起到了赋能和粘合的作用，工具还须可介入，需要人肉补位；另外，工具的进化要运维团队、测试团队和SCM团队来负责，工具自己要足够开放，才能让其它团队可以不断优化某一环节；工具也要保证可持续成长，跟上时代的发展。</p><p>制约与考核</p><p>打破原先的平衡以后，新的平衡如何建立？重新建立平衡是需要时间的，DEV在工程中话语权加大，权利是一定会被制约的，不是内部，就是外部市场。</p><p>每一个问题都要根据公司的实际情况寻找一个平衡点，找到责权划分，怎样去考核和制约，只有将这三个点解完，才可能活下来将分工模式持续跑下去。</p><p>DevOps怎么衡量？</p><p>DevOps可以由四个角度做衡量：</p><p>工程效率：从某一个开发的团队接到需求，到需求交付上线的时间有多长。工程效率能够提升多少代表DevOps发挥作用的大小；</p><p>稳定性：当稳定性没有保证时，效率越高死的越快；<br>非研发工作占比：当占比非常大时，离失败就不远了；</p><p>业务规模与运维人员比例：谷歌的每一个SRE也要管理2000台机器的业务。<br>总结</p><ol><li>实现自动化运维后，很多运维人员就会面临失业，但这是时代发展的必然结果，我们只需欣然接受；</li><li>DevOps没有最佳实践，我们该更关注一些案例的环境和业务背景，DevOps本身不是目标，是一个方法，一个理论；</li><li>DevOps和传统模式没有好坏之分，只有适不适合。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称&lt;/strong&gt;，用于促进开发（应
      
    
    </summary>
    
      <category term="linux" scheme="http://www.python100.com/categories/linux/"/>
    
    
      <category term="DevOps" scheme="http://www.python100.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>经典面试题一</title>
    <link href="http://www.python100.com/2018/07/31/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://www.python100.com/2018/07/31/经典面试题/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:49:05.326Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><p><strong>1、Linux如何挂载windows下的共享目录？</strong><br>mount.cifs //IP地址/server /mnt/server -o user=administrator,password=123456<br>linux 下的server需要自己手动建一个 后面的user与pass 是windows主机的账号和密码 注意空格 和逗号</p><p><strong>2、如何查看http的并发请求数与其TCP连接状态？</strong><br>netstat -n | awk ‘/^tcp/ {++b[$NF]}’ END {for(a in b) print a,b[a]}’</p><p>还有ulimit -n 查看linux系统打开最大的文件描述符，这里默认1024，不修改这里web服务器修改再大也没用。若要用就修改很几个办法，这里说其中一个：<br>修改/etc/security/limits.conf<br>* soft nofile 10240<br>* hard nofile 10240<br>重启后生效</p><p><strong>3、如何用tcpdump嗅探80端口的访问看看谁最高？</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -tnn dst port <span class="number">80</span> -c <span class="number">1000</span> | awk -F<span class="string">"."</span> <span class="string">'&#123;print 1"."2"."3"."4"."&#125;'</span> | sort |uniq -c | sort -nr | head-<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>4、如何查看/var/log目录下的文件数？</strong><br>ls /var/log/ -1R | grep “-” | wc -l</p><p><strong>5、如何查看Linux系统每个ip的连接数？</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk <span class="string">'/^tcp/ &#123;print 5&#125;'</span> | awk -F: <span class="string">'&#123;print $1&#125;'</span> | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure><p><strong>6、shell下生成32位随机密码</strong><br>cat /dev/urandom | head -1 | md5sum | head -c 32 &gt;&gt; /pass</p><p><strong>7、统计出apache的access.log中访问量最多的5个ip</strong><br>cat access.log | awk ‘{print $1}’ | sort | uniq -c | sort -n -r | head -5</p><p><strong>8、如何查看二进制文件的内容？</strong><br>我们一般通过hexdump命令 来查看二进制文件的内容。<br>hexdump -C XXX(文件名) -C是参数 不同的参数有不同的意义<br>-C 是比较规范的 十六进制和ASCII码显示<br>-c 是单字节字符显示<br>-b 单字节八进制显示<br>-o 是双字节八进制显示<br>-d 是双字节十进制显示<br>-x 是双字节十六进制显示</p><p><strong>9、ps aux 中的VSZ代表什么意思，RSS代表什么意思？</strong><br>VSZ:虚拟内存集,进程占用的虚拟内存空间<br>RSS:物理内存集,进程战用实际物理内存空间</p><p><strong>10、如何检测并修复/dev/hda5？</strong><br>fsck用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查</p><p><strong>11、介绍下Linux系统的开机启动顺序</strong><br>加载BIOS–&gt;读取MBR–&gt;Boot Loader–&gt;加载内核–&gt;用户层init一句inittab文件来设定系统运行的等级(一般3或者<br>5，3是多用户命令行，5是界面)–&gt;init进程执行rc.syninit–&gt;启动内核模块–&gt;执行不同级别运行的脚本程序–&gt;执行/etc/rc.d/rc.local(本地运行服务)–&gt;执行/bin/login,就可以登录了。</p><p><strong>12、符号链接与硬链接的区别</strong><br>我们可以把符号链接，也就是软连接 当做是 windows系统里的 快捷方式。<br>硬链接 就好像是 又复制了一份，举例说明：<br>ln 3.txt 4.txt 这是硬链接，相当于复制，不可以跨分区，但修改3,4会跟着变，若删除3,4不受任何影响。<br>ln -s 3.txt 4.txt 这是软连接，相当于快捷方式。修改4,3也会跟着变，若删除3,4就坏掉了。不可以用了。</p><p><strong>13、保存当前磁盘分区的分区表</strong><br>dd 命令是以个强大的命令，在复制的同时进行转换<br>dd if=/dev/sda of=./mbr.txt bs=1 count=512</p><p><strong>14、如何在文本里面进行复制、粘贴，删除行，删除全部，按行查找和按字母查找？</strong><br>以下操作全部在命令行状态操作，不要在编辑状态操作。<br>在文本里 移动到想要复制的行 按yy 想复制到哪就移动到哪，然后按P 就黏贴了<br>删除行 移动到改行 按dd<br>删除全部 dG 这里注意G一定要大写<br>按行查找 :90 这样就是找到第90行<br>按字母查找 /path 这样就是 找到path这个单词所在的位置，文本里可能存在多个,多次查找会显示在不同的位置。</p><p><strong>15、手动安装grub</strong><br>grub-install /dev/sda</p><p><strong>16、修改内核参数</strong><br>vi /etc/sysctl.conf 这里修改参数<br>sysctl -p 刷新后可用</p><p><strong>17、在1-39内取随机数</strong><br>expr $[RANDOM%39] +1<br>RANDOM随机数<br>%39取余数范围0-38</p><p><strong>18、限制apache每秒新建连接数为1，峰值为3</strong><br>每秒新建连接数 一般都是由防火墙来做，apache本身好像无法设置每秒新建连接数，只能设置最大连接：<br>iptables -A INPUT -d 172.16.100.1 -p tcp –dport 80 -m limit –limit 1/second -j ACCEPT</p><p><strong>19、FTP的主动模式和被动模式</strong><br>FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动式和被动式。</p><p>PORT（主动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请 求，服务器接受连接，建立一条命令链路。当需要传送数据时，客户端在命令链路上用PORT 命令告诉服务器：“我打开了XX端口，你过来连接我”。于是服务器从20端口向客户端的 XX端口发送连接请求，建立一条数据链路来传送数据。</p><p>PASV（被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请 求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器在命令链路上用PASV 命令告诉客户端：“我打开了XX端口，你过来连接我”。于是客户端向服务器的XX端口 发送连接请求，建立一条数据链路来传送数据。<br>从上面可以看出，两种方式的命令链路连接方法是一样的，而数据链路的建立方法就完 全不同。</p><p><strong>20、显示/etc/inittab中以#开头，且后面跟了一个或者多个空白字符，而后又跟了任意非空白字符的行</strong><br>grep “^#{1,}[^]” /etc/inittab</p><p><strong>21、显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行</strong><br>grep “\:[0-9]{1}:” /etc/inittab</p><p><strong>22、怎么把脚本添加到系统服务里，即用service来调用？</strong><br>在脚本里加入<br>#!/bin/bash<br># chkconfig: 345 85 15<br># description: httpd<br>然后保存<br>chkconfig httpd –add 创建系统服务<br>现在就可以使用service 来 start or restart</p><p><strong>23、写一个脚本，实现批量添加20个用户，用户名为user01-20，密码为user后面跟5个随机字符</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#description: useradd</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq -f<span class="string">"%02g"</span> <span class="number">1</span> <span class="number">20</span>`;<span class="keyword">do</span></span><br><span class="line">useradd  user<span class="variable">$i</span></span><br><span class="line">echo <span class="string">"user<span class="variable">$i</span>- `echo RANDOM|md5sum|cut -c 1-5`"|passwd --stdin user<span class="variable">$i</span></span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure><p><strong>24、写一个脚本，实现判断192.168.1.0/24网络里，当前在线的IP有哪些，能ping通则认为在线</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> `seq <span class="number">1</span> <span class="number">100</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ping -c <span class="number">1</span> <span class="number">192.168</span>.<span class="number">100</span>.<span class="variable">$ip</span> &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> [ $? <span class="nomarkup">-eq</span> <span class="number">0</span> ]; then</span><br><span class="line">echo <span class="number">192.168</span>.<span class="number">1</span>.<span class="variable">$ip</span> UP</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo <span class="number">192.168</span>.<span class="number">1</span>.<span class="variable">$ip</span> DOWN</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">wait</span><br></pre></td></tr></table></figure><p><strong>25、写一个脚本，判断一个指定的脚本是否是语法错误；如果有错误，则提醒用户键入Q或者q无视错误并退出其它任何键可以通过vim打开这个指定的脚本</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">read -p <span class="string">"please input check script-&gt; "</span> file</span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$file</span> ]; then</span><br><span class="line">sh -n <span class="variable">$file</span> &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> [ $? <span class="nomarkup">-ne</span> <span class="number">0</span> ]; then</span><br><span class="line">read -p <span class="string">"You input <span class="variable">$file</span> syntax error,[Type q to exit or Type vim to edit]"</span>  answer</span><br><span class="line">case <span class="variable">$answer</span> <span class="keyword">in</span></span><br><span class="line">q | Q)</span><br><span class="line"><span class="keyword">exit</span> <span class="number">0</span></span><br><span class="line">;;</span><br><span class="line">vim )</span><br><span class="line">vim <span class="variable">$file</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"><span class="keyword">exit</span> <span class="number">0</span></span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">fi</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo <span class="string">"<span class="variable">$file</span> not exist"</span></span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>26、写一个脚本，要求如何：</strong></p><p>创建一个函数，能接受两个参数：<br>1)第一个参数为URL，即可下载的文件；第二个参数为目录，即下载后保存的位置；<br>2)如果用户给的目录不存在，则提示用户是否创建；如果创建就继续执行，否则，函数返回一个51的错误值给调用脚本；<br>3)如果给的目录存在，则下载文件；下载命令执行结束后测试文件下载成功与否；如果成功，则返回0给调用脚本，否则，返回52给调用脚本；</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">url=<span class="variable">$1</span></span><br><span class="line">dir=<span class="variable">$2</span></span><br><span class="line">download()</span><br><span class="line">&#123;</span><br><span class="line">cd <span class="variable">$dir</span> &gt;&gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> [ $? <span class="nomarkup">-ne</span> <span class="number">0</span> ];then</span><br><span class="line">    read -p <span class="string">"<span class="variable">$dir</span> No such file or directory,create?(y/n)"</span>  answer</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$answer</span>"</span> == <span class="string">"y"</span> ];then</span><br><span class="line">        mkdir -p <span class="variable">$dir</span></span><br><span class="line">        cd <span class="variable">$dir</span></span><br><span class="line">        wget <span class="variable">$url</span> <span class="number">1</span>&gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"51"</span></span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"><span class="keyword">if</span> [ $? <span class="nomarkup">-ne</span> <span class="number">0</span> ]; then</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"52"</span></span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line">download url dir</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><p><strong>27、写一个脚本，详细需求如下：</strong></p><p>1、创建一个函数，可以接受一个磁盘设备路径（如/dev/sdb）作为参数;在真正开始后面步骤之前提醒用户有危险，并让用户选择是否继续；而后将此磁盘设备上的所有分区清空（提示，使用命令dd if=/dev/zero of=/dev/sdb bs=512 count=1实现，注意其中的设备路径不要写错了；<br>如果此步骤失败，返回67给主程序；<br>接着在此磁盘设备上创建两个主分区，一个大小为100M，一个大小为1G；如果此步骤失败，返回68给主程序；<br>格式化此两分区，文件系统类型为ext3；如果此步骤失败，返回69给主程序；<br>如果上述过程都正常，返回0给主程序；</p><p>2、调用此函数；并通过接收函数执行的返回值来判断其执行情况，并将信息显示出来；</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">local Darray=(`ls /dev/sd[a-z]`)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $&#123;Darray&#125;;<span class="keyword">do</span></span><br><span class="line">[[ <span class="string">"i"</span> == <span class="string">"1"</span> ]] &amp;&amp; Sd=<span class="variable">$i</span> &amp;&amp;<span class="keyword">break</span></span><br><span class="line">done</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>66</span><br><span class="line">fi</span><br><span class="line"><span class="comment">#当匹配成功，进入选择，告诉用户，是否继续，输错的话进入无限循环，当用户选择Y,则清空目标分区，且跳出while循环</span></span><br><span class="line"><span class="keyword">while</span> :;<span class="keyword">do</span></span><br><span class="line">read -p <span class="string">"Warning!!!This operation will clean <span class="variable">$Sd</span> data.Next=y,Quit=n [y|n]:"</span>  Choice</span><br><span class="line">case <span class="variable">$Choice</span> <span class="keyword">in</span></span><br><span class="line">y)</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=<span class="variable">$Sd</span> bs=<span class="number">512</span> count=<span class="number">1</span> &amp;&gt; /dev/null &amp;&amp;<span class="keyword">break</span> || <span class="keyword">return</span> <span class="number">67</span> ;;</span><br><span class="line">n)</span><br><span class="line"><span class="keyword">exit</span> <span class="number">88</span> ;;</span><br><span class="line">*)</span><br><span class="line">echo <span class="string">"Invalid choice,please choice again."</span> ;;</span><br><span class="line">esac</span><br><span class="line">done</span><br><span class="line"><span class="comment">#使用echo传递给fdisk进行分区，如果此命令失败，则跳转出去，错误值68，需要注意的是，有时候这个返回值很诡异，笔者之前成功与否都是返回的1，后来重启之后，就好了，如果慎重的话，可以对创建的分区，进行判断，不过就需要使用其他工具截取相关字段了，虽有些小麻烦，但无大碍</span></span><br><span class="line">echo-e <span class="string">"n\np\n1\n\n+100M\nn\np\n2\n\n+1024M\nw\n"</span>|fdisk /dev/sdb&amp;&gt; /dev/null || || <span class="keyword">return</span> <span class="number">68</span></span><br><span class="line"><span class="comment">#格式化之前，让内核重新读取磁盘分区表，值得注意的是，有的系统版本，使用partprobe无效，譬如笔者的环境是rhel5.8，而rhel6.0以后，这个命令就很危险了，而使用partx  -a /dev/sdb则效果更好…此项需慎重，如果格式化失败，则告知把失败的分区定义成变量，且跳出函数，并带出错误值69</span></span><br><span class="line">partprobe  <span class="comment">#只读方式打开设备</span></span><br><span class="line">Part=fdisk -l /dev/<span class="variable">$Sd</span>|tail -<span class="number">2</span>|cut -d<span class="string">" "</span> -f1</span><br><span class="line"><span class="keyword">for</span> M <span class="keyword">in</span> $&#123;Part&#125;;<span class="keyword">do</span></span><br><span class="line">mke2fs -j M &amp;&gt; /dev/null &amp;&amp; ErrorPart=M &amp;&amp; <span class="keyword">return</span> <span class="number">69</span></span><br><span class="line">done</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#下面代码，调用函数，接收函数返回值，根据返回值进行判断哪里出错。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Disk_Mod <span class="variable">$1</span></span><br><span class="line">Res=$?</span><br><span class="line">[ <span class="variable">$Res</span> <span class="nomarkup">-eq</span> <span class="number">0</span> ] &amp;&amp; <span class="keyword">exit</span> <span class="number">0</span></span><br><span class="line">[ <span class="variable">$Res</span> <span class="nomarkup">-eq</span> <span class="number">66</span> ] &amp;&amp; echo <span class="string">"Error! Invalid input."</span></span><br><span class="line">[ <span class="variable">$Res</span> <span class="nomarkup">-eq</span> <span class="number">67</span> ] &amp;&amp; echo <span class="string">"Error! Command -&gt; dd fdisk mke2fs"</span></span><br></pre></td></tr></table></figure><p><strong>28、如何让history命令显示具体时间？</strong><br>HISTTIMEFORMAT=”%Y-%m-%d %H:%M:%S ”<br>export HISTTIMEFORMAT<br>重新开机后会还原，可以写/etc/profile</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;1、Linux如何挂载windows下的共享目录？&lt;/strong&gt;&lt;br&gt;mount.cifs //IP地址/server /mn
      
    
    </summary>
    
      <category term="面试题" scheme="http://www.python100.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://www.python100.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql多表查询</title>
    <link href="http://www.python100.com/2018/07/31/MySQL%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>http://www.python100.com/2018/07/31/MySQL多表查询/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:50:35.224Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h3 id="一使用SELECT子句进行多表查询"><a href="#一使用SELECT子句进行多表查询" class="headerlink" title="一使用SELECT子句进行多表查询"></a>一使用SELECT子句进行多表查询</h3><p><strong>SELECT 字段名 FROM 表1，表2 … WHERE 表1.字段 = 表2.字段 AND 其它查询条件</strong><br>SELECT a.id,a.name,a.address,a.date,b.math,b.english,b.chinese FROM tb_demo065_tel AS b,tb_demo065 AS a WHERE a.id=b.id<br>注:在上面的的代码中，以两张表的id字段信息相同作为条件建立两表关联，但在实际开发中不应该这样使用，最好用主外键约束来实现</p><h3 id="二使用表的别名进行多表查询"><a href="#二使用表的别名进行多表查询" class="headerlink" title="二使用表的别名进行多表查询"></a>二使用表的别名进行多表查询</h3><p>如:SELECT a.id,a.name,a.address,b.math,b.english,b.chinese FROM tb_demo065 a,tb_demo065_tel b WHERE a.id=b.id AND b.id=’$_POST[textid]’<br>SQL语言中，可以通过两种方式为表指定别名<br>第一种是通过关键字AS指定,如<br>SELECT a.id,a.name,a.address,b.math,b.english,b.chinese FROM tb_demo065 AS a,tb_demo065_tel AS b WHERE a.id=b.id<br>第二种是在表名后直接加表的别名实现<br>SELECT a.id,a.name,a.address,b.math,b.english,b.chinese FROM tb_demo065 a,tb_demo065_tel b WHERE a.id=b.id<br>使用表的别名应注意几下几点<br>(1)别名通常是一个缩短了的表名，用于在连接中引用表中的特定列，如果连接中的多个表中有相同的名称列存在，必须用表名或表的别名限定列名<br>(2)如果定义了表的别名就不能再使用表名</p><h3 id="三合并多个结果集"><a href="#三合并多个结果集" class="headerlink" title="三合并多个结果集"></a>三合并多个结果集</h3><p>SQL语言中，可以通过UNION 或 ALL将多个SELECT语句的查询结果合并输出，这两个关键字的使用说明如下：<br>UNION:利用该关键字可以将多个SELECT 语句的查询结果合并输出，并删除重复行<br>ALL:利用该关键字可以将多个SELECT 语句的查询结果合并输出，但不会删除重复行<br>在使用UNION或ALL关键字将多个表合并输出时，查询结果必须具有相同的结构并且数据类型必须兼容,另外使用UNION时两张表的字段数量也必须相同，否则会提示SQL语句有错误。<br>e.x:SELECT id,name,pwd FROM tb_demo067 UNION SELECT uid,price,date FROM tb_demo067_tel</p><h3 id="四简单嵌套查询"><a href="#四简单嵌套查询" class="headerlink" title="四简单嵌套查询"></a>四简单嵌套查询</h3><p>子查询:子查询是一个SELECT查询，返回单个值且嵌套在SELECT、INSERT、UPDATE和DELETE语句或其它查询语句中，任何可以使用表达式的地方都可以使用子查询.<br>SELECT id,name,sex,date FROM tb_demo068 WHERE id in(SELECT id FROM tb_demo068 WHERE id=’$_POST[test]’)<br>内连接：把查询结果作为WHERE子句的查询条件即称为内连接</p><h3 id="五复杂的嵌套查询"><a href="#五复杂的嵌套查询" class="headerlink" title="五复杂的嵌套查询"></a>五复杂的嵌套查询</h3><p>多表之间的嵌套查询可以通过谓词IN实现，语法格式如下:<br>test_expression[NOT] IN{<br>subquery<br>}<br>参数说明：test_expression指SQL表达式，subquery包含某结果集的子查询<br>多表嵌套查询的原理:无论是多少张表进行嵌套，表与表之间一定存在某种关联，通过WHERE子句建立此种关联实现查询</p><h3 id="六嵌套查询在查询统计中的应用"><a href="#六嵌套查询在查询统计中的应用" class="headerlink" title="六嵌套查询在查询统计中的应用"></a>六嵌套查询在查询统计中的应用</h3><p>实现多表查询时，可以同时使用谓词ANY、SOME、ALL,这些谓词被称为定量比较谓词，可以和比较运算符联合使用，判断是否全部返回值都满足搜索条件.SOME和ANY谓词是存在量的，只注重是否有返回值满足搜索条件，这两个谓词的含义相同，可以替换使用;ALL谓词称为通用谓词，它只关心是否有谓词满足搜索要求.<br>SELECT * FROM tb_demo069_people WHERE uid IN(SELECT deptID FROM tb_demo069_dept WHERE deptName=’$_POST[select]’)<br>SELECT a.id,a.name FROM tb_demo067 AS a WHERE id&lt;3)</p><blockquote><p>ANY 大于子查询中的某个值</p></blockquote><blockquote><p>=ANY 大于等于子查询中的某个值<br>&lt;=ANY 小于等于子查询中的某个值<br>=ANY 等于子查询中的某个值<br>!=ANY或&lt;&gt;ANY 不等于子查询中的某个值<br>ALL 大于子查询中的所有值</p></blockquote><blockquote><p>=ALL 大于等于子查询中的所有值<br>&lt;=ALL 小于等于子查询中的所有值<br>=ALL 等于子查询中的所有值<br>!=ALL或&lt;&gt;ALL 不等于子查询中的所有值</p></blockquote><h3 id="七-使用子查询作派生的表"><a href="#七-使用子查询作派生的表" class="headerlink" title="七.使用子查询作派生的表"></a>七.使用子查询作派生的表</h3><p>在实际项目开发过程中经常用到从一个信息较为完善的表中派生出一个只含有几个关键字段的信息表，通过子查询就可以来实现这一目标,如<br>SELECT people.name,people.chinese,people.math,people.english FROM (SELECT name,chinese,math,english FROM tb_demo071) AS people<br>注:子查询应遵循以下规则:<br>(1)由比较运算符引入的内层子查询只包含一个表达式或列名，在外层语句中的WHERE子句内命名的列必须与内层子查询命名的列兼容<br>(2)由不可更改的比较运算符引入的子查询(比较运算符后面不跟关键字ANY或ALL)不包括GROUP BY 或 HAVING子句，除非预先确定了成组或单个的值<br>(3)用EXISTS引入的SELECT列表一般都由*组成，不必指定列名<br>(4)子查询不能在内部处理其结果</p><h3 id="八使用子查询作表达式"><a href="#八使用子查询作表达式" class="headerlink" title="八使用子查询作表达式"></a>八使用子查询作表达式</h3><p>SELECT (SELECT AVG(chinese)FROM tb_demo071),(SELECT AVG(english)FROM tb_demo071),(SELECT AVG(math)FROM tb_demo071) FROM tb_demo071<br>注：在使用子查询时最好为列表项取个别名，这样可以方便用户在使用mysql_fetch_array()函数时为表项赋值,如<br>SELECT (SELECT AVG(chinese) FROM tb_demo071) AS yuwen ,(SELECT AVG(english) FROM tb_demo071) AS yingyu,(SELECT AVG(math) FROM tb_demo071) AS shuxue FROM tb_demo071</p><h3 id="九使用子查询关联数据"><a href="#九使用子查询关联数据" class="headerlink" title="九使用子查询关联数据"></a>九使用子查询关联数据</h3><p>SELECT * FROM tb_demo072_student WHERE id=(SELECT id FROM tb_demo072_class WHERE className = ‘$_POST[text]’)</p><h3 id="十多表联合查询"><a href="#十多表联合查询" class="headerlink" title="十多表联合查询"></a>十多表联合查询</h3><p>利用SQL语句中的UNION，可以将不同表中符合条件的数据信息显示在同一列中。<br>e.x:SELECT <em>FROM tb_demo074_student UNION SELECT </em>FROM tb_demo074_fasten<br>注:使用UNION时应注意以下两点：<br>(1)在使用UNION运算符组合的语句中，所有选择列表的表达式数目必须相同，如列名、算术表达式及聚合函数等<br>(2)在每个查询表中，对应列的数据结构必须一样。</p><h3 id="十一对联合后的结果进行排序"><a href="#十一对联合后的结果进行排序" class="headerlink" title="十一对联合后的结果进行排序"></a>十一对联合后的结果进行排序</h3><p>为了UNION的运算兼容，要求所有SELECT语句都不能有ORDER BY语句，但有一种情况例外，那就是在最后一个SELECT语句中放置ORDER BY 子句实现结果的最终排序输出。<br>e.x:SELECT <em>FROM tb_demo074_student UNION SELECT </em>FROM tb_demo074_fasten ORDER BY id<br>使用UNION条件上相对比较苛刻，所以使用此语句时一定要注意两个表项数目和字段类型是否相同</p><h3 id="十二条件联合语句"><a href="#十二条件联合语句" class="headerlink" title="十二条件联合语句"></a>十二条件联合语句</h3><p>SELECT <em>FROM tb_demo076_BEIJING GROUP BY name HAVING name=’人民邮电出版社’ OR name=’机械工业出版社’ UNION SELECT </em>FROM tb_demo076_BEIJING GROUP BY name HAVING name &lt;&gt;’人民邮电出版社’ AND name &lt;&gt;’机械工业再版社’ ORDER BY id<br>上面语句应用了GROUP BY分组语句和HAVING语句实现条件联合查询。其实现目的是先保证将’人民邮电出版社’和’机械工业出版社’始终位于名单最前列，然后再输出其它的出版社</p><h3 id="十三简单内连接查询"><a href="#十三简单内连接查询" class="headerlink" title="十三简单内连接查询"></a>十三简单内连接查询</h3><p>SELECT filedlist FROM table1 [INNER] JOIN table2 ON table1.column1 = table2.column1<br>其中，filedlist是要显示的字段,INNER表示表之间的连接方式为内连接，table1.column1=table2.column1用于指明两表间的连接条件，如:<br>SELECT a.name,a.address,a.date,b.chinese,b.math,b.english FROM tb_demo065 AS a INNER JOIN tb_demo065_tel AS b on a.id=b.id</p><h3 id="十四复杂内连接查询"><a href="#十四复杂内连接查询" class="headerlink" title="十四复杂内连接查询"></a>十四复杂内连接查询</h3><p>复杂的内连接查询是在基本的内连接查询的基础上再附加一些查询条件，如:<br>SELECT a.name,a.address,a.date,b.chinese,b.math,b.english FROM tb_demo065 AS a INNER JOIN tb_demo065_tel AS b on a.id=b.id WHERE b.id=(SELECT id FROM tb_demo065 WHERE tb_demo065.name=’$_POST[text]’)<br>总之，实现表与表之间的关联的本质是两表之间存在共同的数据项或者相同的数据项，通过WHERE 子句或内连接INNER JOIN … ON 语句将两表连接起来，实现查询</p><h3 id="十五使用外连接实现多表联合查询"><a href="#十五使用外连接实现多表联合查询" class="headerlink" title="十五使用外连接实现多表联合查询"></a>十五使用外连接实现多表联合查询</h3><p>(1)LEFT OUTER JOIN表示表之间通过左连接方式相互连接，也可简写成LEFT JOIN,它是以左侧的表为基准故称左连接，左侧表中所有信息将被全部输出，而右侧表信息则只会输出符合条件的信息，对不符合条件的信息则返回NULL<br>e.x:SELECT a.name,a.address,b.math,b.english FROM tb_demo065 AS A LEFT OUTER JOIN tb_demo065_tel AS b ON a.id=b.id<br>(2)RIGHT OUTER JOIN表示表之间通过右连接方式相互连接，也可简写成RIGHT JOIN,它是以右侧的表为基准故称右连接，右侧表中所有信息将被全部输出，而左侧表信息则只会输出符合条件的信息，对不符合条件的信息则返回NULL<br>E.X:SELECT a.name,a.address,b.math,b.english FROM tb_demo065 AS A RIGHT OUTER JOIN tb_demo065_tel AS b ON a.id=b.id</p><h3 id="十六利用IN或NOTIN关键字限定范围"><a href="#十六利用IN或NOTIN关键字限定范围" class="headerlink" title="十六利用IN或NOTIN关键字限定范围"></a>十六利用IN或NOTIN关键字限定范围</h3><p>e.x:SELECT * FROM tb_demo083 WHERE code IN(SELECT code FROM tb_demo083 WHERE code BETWEEN ‘$_POST[text1]’ AND ‘$_POST[text2]’)<br>利用IN可指定在范围内查询，若要求在某范围外查询可以用NOT IN代替它</p><h3 id="十七由IN引入的关联子查询"><a href="#十七由IN引入的关联子查询" class="headerlink" title="十七由IN引入的关联子查询"></a>十七由IN引入的关联子查询</h3><p>e.x:SELECT * FROM tb_demo083 WHERE code IN(SELECT code FROM tb_demo083 WHERE code = ‘$_POST[text]’)</p><h3 id="十八利用HAVING语句过滤分组数据"><a href="#十八利用HAVING语句过滤分组数据" class="headerlink" title="十八利用HAVING语句过滤分组数据"></a>十八利用HAVING语句过滤分组数据</h3><p>HAVING子句用于指定组或聚合的搜索条件，HAVING通常与GROUP BY 语句一起使用，如果SQL语句中不含GROUP BY子句，则HAVING的行为与WHERE子句一样.<br>e.x:SELECT name,math FROM tb_demo083 GROUP BY id HAVING math &gt; ‘95’</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;一使用SELECT子句进行多表查询&quot;&gt;&lt;a href=&quot;#一使用SELECT子句进行多表查询&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.python100.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.python100.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>git和svn区别</title>
    <link href="http://www.python100.com/2018/07/31/SVN%E5%92%8Cgit%E5%B7%AE%E5%88%AB/"/>
    <id>http://www.python100.com/2018/07/31/SVN和git差别/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:36:27.838Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>最核心的区别Git是分布式的，而Svn不是分布的。</li><li>Git把内容按元数据方式存储，而SVN是按文件</li><li>Git没有一个全局版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。</li><li>Git的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li><li>克隆一份全新的大目录，git要比SVN快的多。</li><li>版本库（repository):SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。或者，更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！</li><li>分支（Branch）在SVN，分支是一个完整的目录。且这个目录拥有完整的实际文件。如果工作成员想要开啟新的分支， 还得让其他人重新切分支重新下载 。而 Git，每个工作成员可以任意在自己的本地版本库开啟无限个分支 ，开一个分支，做喜欢的事。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。</li></ul><h3 id="SVN-的主要功能"><a href="#SVN-的主要功能" class="headerlink" title="SVN 的主要功能"></a>SVN 的主要功能</h3><ul><li>SVN属于集中化的版本控制系统，有个不太精确的比喻:SVN = 版本控制+ 备份服务器</li><li>SVN使用起来有点像是档案仓库的感觉，支持并行读写文件，支持代码的版本化管理，功能包括取出、导入、更新、分支、改名、还原、合并等。SVN大都采用图形界面操作，直观，上手快。</li><li>SVN对中文支持好，操作简单，使用没有难度，美工人员，产品人员，测试人员，实施人员都可轻松上手。使用界面统一，功能完善，操作方便。</li></ul><h3 id="Git的主要功能"><a href="#Git的主要功能" class="headerlink" title="Git的主要功能"></a>Git的主要功能</h3><ul><li>Git是一个分布式版本控制系统，操作命令包括：clone，pull，push,branch ,merge ,push,rebase，Git擅长的是程序代码的版本化管理。</li><li>对程序源代码进行差异化的版本管理，代码库占极少的空间。易于代码的分支化管理。不支持中文，图形界面支持差，使用难度大。不易推广。</li></ul><p>SVN更适用于项目管理， Git仅适用于代码管理。</p><h3 id="最后总结一下："><a href="#最后总结一下：" class="headerlink" title="最后总结一下："></a>最后总结一下：</h3><p>SVN的特点是简单，只是需要一个放代码的地方时用是OK的。</p><p>Git的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)，不过想各位能更好使用它，需要花点时间尝试下。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;区别：&quot;&gt;&lt;a href=&quot;#区别：&quot; class=&quot;headerlink&quot; title=&quot;区别：&quot;&gt;&lt;/a&gt;区别：&lt;/h3&gt;&lt;ul&gt;&lt;l
      
    
    </summary>
    
      <category term="git" scheme="http://www.python100.com/categories/git/"/>
    
    
      <category term="git" scheme="http://www.python100.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>面试题二</title>
    <link href="http://www.python100.com/2018/07/31/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://www.python100.com/2018/07/31/面试题/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:47:40.836Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h3 id="对运维有什么看法？主要做什么可以让自己工作？"><a href="#对运维有什么看法？主要做什么可以让自己工作？" class="headerlink" title="对运维有什么看法？主要做什么可以让自己工作？"></a>对运维有什么看法？主要做什么可以让自己工作？</h3><p>1、做好全方面的监控</p><p>2、及时优化系统和工具</p><p>3、消除系统安全隐患、做好系统的安全防护</p><p>4、做好典型故障的整理和归纳</p><p>5、查询日志，看是否有异常登录等</p><h3 id="一台数据库主机cpu负载过高怎么办？"><a href="#一台数据库主机cpu负载过高怎么办？" class="headerlink" title="一台数据库主机cpu负载过高怎么办？"></a>一台数据库主机cpu负载过高怎么办？</h3><p>根据实际情况，如果是读数据库比较多造成的，读写分离，多做几个负责读的服务器。</p><p>如果写比较多造成的，则多做几个主主服务，</p><p>如果是多web服务器请求造成的，则需要使用proxy或者nginx代理服务器，将用户需求分发到多个子服务器上，将用户需求分流</p><p>总的一句话，就是将造成过高的原因进行分流，将负载均衡到其他服务器。</p><p>如果是DDOS攻击，则需要小心了</p><h3 id="sort命令可以对文本的内容进行排序"><a href="#sort命令可以对文本的内容进行排序" class="headerlink" title="sort命令可以对文本的内容进行排序"></a>sort命令可以对文本的内容进行排序</h3><p>uniq命令可以对文本内容连续的内容进行去重，非连续的重复内容无法去重</p><p>sort 文件 | uniq 可以达到去除所有重复数据的目的（因为先排序了，这样相同的内容一定在连续的一片，再uniq）</p><p>sort 文件 |uniq <strong>等价于</strong> sort -u 文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-<span class="number">1</span> ~]<span class="comment"># sort a.txt </span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">98789</span></span><br><span class="line"><span class="number">98789</span></span><br><span class="line">sdfs</span><br><span class="line">sdfsaf</span><br><span class="line">sdfsaf</span><br><span class="line">sdfsaf</span><br><span class="line">[root@k8s-<span class="number">1</span> ~]<span class="comment"># sort a.txt |uniq</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">98789</span></span><br><span class="line">sdfs</span><br><span class="line">sdfsaf</span><br><span class="line">[root@k8s-<span class="number">1</span> ~]<span class="comment"># sort -u a.txt </span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">98789</span></span><br><span class="line">sdfs</span><br><span class="line">sdfsaf</span><br></pre></td></tr></table></figure><h3 id="ext4与xfs比有什么优势和劣势。"><a href="#ext4与xfs比有什么优势和劣势。" class="headerlink" title="ext4与xfs比有什么优势和劣势。"></a>ext4与xfs比有什么优势和劣势。</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXT4是第四代扩展文件系统（英语：Fourth EXtended filesystem，缩写为ext4）是Linux系统下的日志文件系统，是ext3文件系统的后继版本。 Ext4的文件系统容量达到<span class="number">1</span>EB，而文件容量则达到<span class="number">16</span>TB，这是一个非常大的数字了。对一般的台式机和服务器而言，这可能并不重要，但对于大型磁盘阵列的用户而言，这就非常重要了。</span><br><span class="line"></span><br><span class="line">XFS是一个<span class="number">64</span>位文件系统，最大支持<span class="number">8</span>EB减<span class="number">1</span>字节的单个文件系统，实际部署时取决于宿主操作系统的最大块限制。对于一个<span class="number">32</span>位Linux系统，文件和文件系统的大小会被限制在<span class="number">16</span>TB。   </span><br><span class="line"></span><br><span class="line">二者各有特点，而性能表现基本上是差不多的。例如，谷歌公司就考虑将EXT2系统升级，最终确定为EXT4系统。谷歌公司表示，他们还考虑过XFS和JFS。结果显示，EXT4和XFS的表现类似，不过从EXT2升级到EXT4比升级到XFS容易。</span><br></pre></td></tr></table></figure><h3 id="overlay文件系统解析"><a href="#overlay文件系统解析" class="headerlink" title="overlay文件系统解析"></a>overlay文件系统解析</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个 overlay 文件系统包含两个文件系统，一个 upper 文件系统和一个 lower 文件系统，是一种新型的联合文件系统。overlay是“覆盖…上面”的意思，overlay文件系统则表示一个文件系统覆盖在另一个文件系统上面。</span><br><span class="line"></span><br><span class="line">overlay的两层对应的就是docker的镜像层（只读）和容器层（可写），只是把原来AUFS中的多层镜像合并成了lower层，而upper层代表的是容器层</span><br><span class="line"></span><br><span class="line">overlay和AUFS都是联合文件系统，但结构比AUFS简单，且并入了linux kernel mainline，可能会比AUFS快，但还是太年轻，要谨慎在生产使用。而AUFS做为docker的第一个存储驱动，已经有很长的历史，比较的稳定，且在大量的生产中实践过，有较强的社区支持。</span><br></pre></td></tr></table></figure><h3 id="简述TCP握手协议"><a href="#简述TCP握手协议" class="headerlink" title="简述TCP握手协议"></a>简述TCP握手协议</h3><p>在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.<br>第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认；<br>SYN：同步序列编号(Synchronize Sequence Numbers)</p><p>第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包, 此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.</p><p>完成三次握手,客户端与服务器开始传送数据</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;对运维有什么看法？主要做什么可以让自己工作？&quot;&gt;&lt;a href=&quot;#对运维有什么看法？主要做什么可以让自己工作？&quot; class=&quot;head
      
    
    </summary>
    
      <category term="面试题" scheme="http://www.python100.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://www.python100.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>buffer 和 cache</title>
    <link href="http://www.python100.com/2018/07/31/buffer_%E5%92%8C_cache/"/>
    <id>http://www.python100.com/2018/07/31/buffer_和_cache/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:49:57.600Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h3 id="linux-操作系统中buffer-和-cache-的作用"><a href="#linux-操作系统中buffer-和-cache-的作用" class="headerlink" title="[linux 操作系统中buffer 和 cache 的作用]"></a>[linux 操作系统中buffer 和 cache 的作用]</h3><ul><li><strong>Buffer</strong> 和 <strong>cache</strong> （它们都是占用内存）。</li><li><strong>Buffer</strong>: 系统分配但未被使用的buffer 数量。</li><li>buffer ：作为buffer cache的内存，是块设备的读写缓冲区</li><li>cache（名词）：作为page cache的内存， 文件系统的cache</li></ul><h3 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区:  "></a><strong>Buffer 缓冲区:</strong></h3><p><strong>是块设备的读写缓冲区，buffer 是I/O 缓存，用于内存和硬盘（或其他 I/O设备）之间的数据交换的速度而设计的。</strong></p><p>分析：</p><p><strong>1**</strong>、**通常在写一个非常大的文件，文件会被分成一个个的小 block块–&gt;一直往内存上写–&gt;然后再写入磁盘,, 这个文件非常的大，但是会被分成一个个小的block块，每次都一点一点的–&gt;写入内存–&gt;再写入磁盘, 这样的效率较慢 。</p><p><strong>2**</strong>、<strong> 这种情况下，内存就会攒足一次大的block块–&gt;再写入磁盘，这样的话就不会有第一种情况里的延迟。 </strong>这就是buffer.**</p><h3 id="Cache-高速缓存-："><a href="#Cache-高速缓存-：" class="headerlink" title="Cache**高速缓存** ："></a><strong>Cache**</strong>高速缓存** ：</h3><p><strong>cache</strong>是高速缓存，用于cpu与内存之间的缓冲。主要原因是cpu与memory,由于cpu快，memory跟不上，且有些值使用次数多，所以放入cache中，主要目的是，使用内存来缓存可能被再次访问的数据。 <strong>Cache 经常被使用在I/O 请求上。为提高系统性能。</strong></p><p>从硬盘上读内容时的情况：</p><p>例如 要打开一个非常大的视频文件从硬盘–&gt;读到内存—&gt;显示出来。 第一次打开这个文件的时候需要等待一些时间（视电脑性能），然后第二次打开的时候会比第一次流畅许多。</p><p>例如：小明第一次看这个10G的视频文件，从硬盘–&gt;内存–&gt;显示，他看完以后就关机了，内存也就清空空间了，但是他回头一想，电影中的某个情节想再回顾一下，这个时候，从硬盘–&gt;读到内存 ，这个时候的内存没有再次从硬盘读取，而是之前关机有缓存，读取的时间可能比之前流畅，这就是cache.是为了提高文件读取效率的做法。</p><p><strong>如果 cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO 必会非常小。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;linux-操作系统中buffer-和-cache-的作用&quot;&gt;&lt;a href=&quot;#linux-操作系统中buffer-和-cache-的作
      
    
    </summary>
    
      <category term="linux" scheme="http://www.python100.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>常用的nginx规则总结</title>
    <link href="http://www.python100.com/2018/07/31/%E5%AE%9E%E7%94%A8%E7%9A%84Nginx%E8%A7%84%E5%88%99/"/>
    <id>http://www.python100.com/2018/07/31/实用的Nginx规则/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:48:29.380Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>大家都知道Nginx有很多功能模块，比如反向代理、缓存等，这篇文章总结下我们这些年实际环境中那些有用的Nginx规则和模块，大部分是用法的概括及介绍，具体细节在实际配置时再自行google。</p><h2 id="2-内置语法"><a href="#2-内置语法" class="headerlink" title="2. 内置语法"></a>2. 内置语法</h2><p>先介绍Nginx默认已支持的内置功能，靠这些基本就满足大部分的web服务需求。</p><h3 id="2-1-proxy代理"><a href="#2-1-proxy代理" class="headerlink" title="2.1 proxy代理"></a>2.1 proxy代理</h3><p>proxy常用于两类应用场景，一类是中转，如异地科学的上网方式，另外一类是到后端服务的负载均衡方案。</p><p>用反向代理时候，需要特别注意里面的域名默认是在nginx启动时候就解析了，除非reload否则一直用的是当初解析的域名，也就是说不能动态解析。</p><p>但这个问题是可以通过别的模块或者用内置字典变量方式来解决。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; resolver 114.114.114.114;</span><br><span class="line">&gt; server &#123;</span><br><span class="line">&gt;     location / &#123;</span><br><span class="line">&gt;         set $servers github.com;</span><br><span class="line">&gt;         proxy_pass http://$servers;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-1-1-中转"><a href="#2-1-1-中转" class="headerlink" title="2.1.1 中转"></a>2.1.1 中转</h4><p>针对某个域名进行中转：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; server &#123;</span><br><span class="line">&gt; listen 172.16.10.1:80;</span><br><span class="line">&gt;     server_name pypi.python.org;</span><br><span class="line">&gt;     location ~ /simple &#123;</span><br><span class="line">&gt;         proxy_set_header Host $http_host;</span><br><span class="line">&gt;         proxy_redirect off;</span><br><span class="line">&gt;         proxy_pass http://pypi.python.org;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>注意如果是前后端域名不一样的话需要处理proxy_redirect的301跳转之类的显示，否则在跳转时候会跳转到proxy_pass的域名。</p><p>另外可以直接代理所有80端口的http流量：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; server &#123;</span><br><span class="line">&gt;     listen 80;</span><br><span class="line">&gt;     server_name _;</span><br><span class="line">&gt;     resolver 114.114.114.114;</span><br><span class="line">&gt;     set $URL $host;</span><br><span class="line">&gt;     location / &#123;</span><br><span class="line">&gt;         proxy_pass http://$URL;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果是想代理https的站点也不是不可能，只是需要自行处理CA证书导入即可，而且经过https中转的流量对nginx是透明的，也就是有证书的时候做窃听和劫持的情况。</p><h4 id="2-1-2-负载均衡"><a href="#2-1-2-负载均衡" class="headerlink" title="2.1.2 负载均衡"></a>2.1.2 负载均衡</h4><p>这是代理的另外一个常见用法，通过upstream到多个后端，可以通过weight来调节权重或者backup关键词来指定备份用的后端，通常默认就可以 了，或者可以指定类似ip_hash这样的方式来均衡，配置很简单，先在http区域添加upstream定义：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; upstream backend &#123;</span><br><span class="line">&gt;     ip_hash;</span><br><span class="line">&gt;     server backend1.example.com weight=5;</span><br><span class="line">&gt;     server backend2.example.com weight=5;;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>然后在server里面添加proxy_pass：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; location / &#123;</span><br><span class="line">&gt;     proxy_pass http://backend;</span><br><span class="line">&gt;     proxy_http_version 1.1;</span><br><span class="line">&gt;     proxy_set_header Connection &quot;&quot;;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>做负载均衡的时候可以智能识别后端服务器状态，虽然可以智能地proxy_next_upstream到另外的后端，但还是会定期损失一些正常的“尝试性”的连接，比如过了max_fails 次尝试之后，休息fail_timeout时间，过了这个时间之后又会去尝试，这个时候可以使用第三方的upstream_check模块来在后台定期地自动探索，类似这样：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; check interval=3000 rise=2 fall=5 timeout=2000 type=http;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这样替代用户正常的连接来进行尝试的方式进一步保障了高可用的特性。</p><p>还有就是在做前端代理的时候也是这样的方式，直接proxy_pass到后端即可，比如CDN的场景。</p><h3 id="2-2-防盗链"><a href="#2-2-防盗链" class="headerlink" title="2.2 防盗链"></a>2.2 防盗链</h3><p>普通的防盗链是通过referer来做，比如：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; location ~* \.(gif|jpg|png|bmp)$ &#123;</span><br><span class="line">&gt;     valid_referers none blocked *.example.com server_names ~\.google\. ~\.baidu\.;</span><br><span class="line">&gt;     if ($invalid_referer) &#123;</span><br><span class="line">&gt;         return 403;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>再精细一点的就是URL加密，针对一些用户IP之类的变量生成一个加密URL通常是针对文件下载时候用到，可以通过openresty来写lua脚本或者是accesskey之类的模块来实现。</p><h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><p>nginx里面支持正则匹配和变量配置，默认的变量比如remote_addr、request_filename、query_string、server_name之类的，这些组合在一起可以做很多规则，或者还有日志里面status、http_cookie等。</p><p>还有在进行多域名配置时候可以用通配符，比如：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; server_name ~^(www\.)?(.+)$;</span><br><span class="line">&gt; root /data/web/$2;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这样就实现了自动进行域名的目录指派。</p><p>变量方面，比如配置变量a=1：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; set $a 1;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>下面这个案例配合if判断来做有更大的用处。</p><h3 id="2-4-if判断"><a href="#2-4-if判断" class="headerlink" title="2.4 if判断"></a>2.4 if判断</h3><p>nginx里面支持一些简单的if判断，但是没有多重逻辑的语法，多个判断条件用起来需要结合变量的方式来实现，比如允许ip地址为10.10.61段和和192.168.100段的用户访问，其余的拒绝，返回405状态码：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; set $err 0;</span><br><span class="line">&gt;     if ( $remote_addr ~ 10.10.61.)&#123;</span><br><span class="line">&gt;         set $err 0;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     if ( $remote_addr ~ 192.168.100.)&#123;</span><br><span class="line">&gt;         set $err 0;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     if ( $err = 1)&#123;</span><br><span class="line">&gt;         return 405;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这样通过一个err变量比较巧妙实现了需求。</p><h3 id="2-5-error-page"><a href="#2-5-error-page" class="headerlink" title="2.5 error_page"></a>2.5 error_page</h3><p>有用到后端proxy的地方需要加上这句话才可以传到状态码到nginx：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; fastcgi_intercept_errors on;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>具体配置一般是配置到具体的错误URL页面，比如：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; #返回具体状态码</span><br><span class="line">&gt; error_page 404 403 /4xx.html</span><br><span class="line">&gt; #返回200状态码</span><br><span class="line">&gt; error_page 404 403 =200  /error.html</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>或者采用callback的方式统一做处理：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; error_page 404 403 = @fallback; </span><br><span class="line">&gt; location @fallback &#123;</span><br><span class="line">&gt;     proxy_pass http://backend;</span><br><span class="line">&gt;     access_log /data/logs/404_error.log access;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这样在重定向时不会改变URL，然后把404页面直接返回。</p><h3 id="2-6-rewrite"><a href="#2-6-rewrite" class="headerlink" title="2.6 rewrite"></a>2.6 rewrite</h3><p>rewrite做一些301、302之类的跳转，同时也可以在CDN前端做“去问号”缓存的效果。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; location /db.txt &#123;</span><br><span class="line">&gt;     rewrite (.*) $1? break;</span><br><span class="line">&gt;     include proxy.conf;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>另外最常见的跳转写法：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rewrite ^/game/(.*) /$1;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>把/game/test跳转为/test的效果，注意这样是没有状态码的，如果访问正常就直接返回200状态码。</p><p>可以在后面加个permanent参数，就变为了301 Moved Permanently，或者添加redirect改为302跳转。</p><p>同理，还可以进行多个正则匹配进行URL重组，比如：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rewrite ^/download/(.*)/lastest/(.*)$ /file/$1?ver=$2 break;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-7-日志字段"><a href="#2-7-日志字段" class="headerlink" title="2.7 日志字段"></a>2.7 日志字段</h3><p>想针对每个连接进行日志留档，可以在nginx日志那里配置好字段，比如记录cookie之类的数据。</p><p>在log_format字段里面加入$http_cookie变量即可。</p><p>另外post的数据可以永久保留在文件里面，比如用来做http的日志备份，包括get和post的原始数据，把这个值开启即可：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; client_body_in_file_only  on;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>然后post的数据就会保存在nginx/client_body_temp文件夹里面。</p><h3 id="2-8-internal关键词"><a href="#2-8-internal关键词" class="headerlink" title="2.8 internal关键词"></a>2.8 internal关键词</h3><p>这个关键词很少见，但有时候是很有用的，比如在有很多规则时候，突然需要针对某个目录转为nginx内部处理。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; location ^~ /upload/down/ &#123;</span><br><span class="line">&gt; alias /data/web/dts/dtsfile/down/;</span><br><span class="line">&gt; internal;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-9-try-files"><a href="#2-9-try-files" class="headerlink" title="2.9 try_files"></a>2.9 try_files</h3><p>字面意思是尝试，后面可以接多个目录或者文件，比如kohana框架：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; try_files $uri /index.php?$query_string;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>先看是否有URL这个文件，没有的话再调用index.php来处理，或者支持状态码处理：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; try_files /foo /bar/ =404;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>没有这两个文件的话返回404状态。</p><h3 id="2-10-auth认证"><a href="#2-10-auth认证" class="headerlink" title="2.10 auth认证"></a>2.10 auth认证</h3><p>可以做简单的用户登录认证方式，其中的passwd_file得通过apache的htpasswd命令来生成。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; auth_basic &quot;Restricted&quot;;</span><br><span class="line">&gt; auth_basic_user_file passwd_file;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>认证通过之后每次访问会在头部添加Authorization字段包含用户名密码的base64加密密文给服务端。</p><h3 id="2-11-gzip"><a href="#2-11-gzip" class="headerlink" title="2.11 gzip"></a>2.11 gzip</h3><p>普通的线上web站点gzip压缩是必须要开的，压缩一些文本类型的文件再返回给用户。</p><p>注意必须手动指定全需要压缩的类型，比如css、js之类的，线上配置如下：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; gzip on;</span><br><span class="line">&gt; gzip_min_length  2048;</span><br><span class="line">&gt; gzip_buffers     4 16k;</span><br><span class="line">&gt; gzip_vary   on;</span><br><span class="line">&gt; gzip_http_version 1.1;</span><br><span class="line">&gt; gzip_types  text/plain  text/css text/xml application/xml application/javascript application/x-javascript ;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-12-mime配置"><a href="#2-12-mime配置" class="headerlink" title="2.12 mime配置"></a>2.12 mime配置</h3><p>很久以前基本是忽略这个配置，但手游流行之后就发现异常了，需要让手机浏览器知道返回的apk后缀是什么类型，否则类似IE浏览器会以zip后缀返回，需要加上：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; application/vnd.android.package-archive apk;</span><br><span class="line">&gt; application/iphone pxl ipa;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-13-限速"><a href="#2-13-限速" class="headerlink" title="2.13 限速"></a>2.13 限速</h3><p>限速包括限制请求的并发数和请求的下载速度。</p><p>简单的限制某个线程的下载速度就直接加上一句话就可以了：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; limit_rate 1024k;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>要限制某个IP的并发数之类的就需要用ngx_http_limit_req_module和ngx_http_limit_conn_module模块了，不过是默认就编译好的。</p><p>比如使用一个 10M 大小的状态缓存区，针对每个IP每秒只接受20次的请求：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; limit_req_zone $binary_remote_addr zone=NAME:10m rate=20r/s;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-14-location匹配"><a href="#2-14-location匹配" class="headerlink" title="2.14 location匹配"></a>2.14 location匹配</h3><p>location匹配有多种方式，常见的比如</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; location  = / </span><br><span class="line">&gt; location  / </span><br><span class="line">&gt; location ^~ /test&#123;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>是有优先级的，直接 ”=” 的优先级是最高的，一般就用”~”这个符号来匹配php就好了，不过是区分了大小写的：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; location ~ .*\.php$</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-15-文件缓存"><a href="#2-15-文件缓存" class="headerlink" title="2.15 文件缓存"></a>2.15 文件缓存</h3><p>返回给用户的文件一般都配置了过期时间，让浏览器缓存起来。</p><p>比如缓存14天：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; expires 14d;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>针对某些特殊的文件就需要location匹配之后进行禁止缓存配置：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; add_header Cache-Control no-cache;</span><br><span class="line">&gt; add_header Cache-Control no-store;</span><br><span class="line">&gt; expires off;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-16-缓存文件"><a href="#2-16-缓存文件" class="headerlink" title="2.16 缓存文件"></a>2.16 缓存文件</h3><p>nginx可以作为ATS这样的缓存服务器来缓存文件，配置也比较简单，不过我们很少用，除非一些特殊的场合，参考配置：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; #先在全局下面定义好缓存存放的目录</span><br><span class="line">&gt; proxy_cache_path  /data/cache/ levels=1:2 keys_zone=cache_one:10m inactive=7d max_size=10g;</span><br><span class="line">&gt; proxy_temp_path   /data/cache/proxy_temp_path;</span><br><span class="line">&gt; proxy_cache_key   $host$uri$is_args$args;</span><br><span class="line">&gt; #然后在server里面的location匹配好目的文件，加入下一段即可</span><br><span class="line">&gt; proxy_cache cache_one;</span><br><span class="line">&gt; proxy_cache_valid 200 304 24h;</span><br><span class="line">&gt; proxy_cache_valid any 10m;</span><br><span class="line">&gt; proxy_pass https://$host;</span><br><span class="line">&gt; proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">&gt; add_header  Nginx-Cache &quot;$upstream_cache_status&quot;; 3. 内置模块</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-内置模块"><a href="#3-内置模块" class="headerlink" title="3. 内置模块"></a>3. 内置模块</h2><p>nginx含有大量的模块可以支持多种复杂的需求，比如源码目录src/http/modules里面就有很多c模块的代码，或者直接通过./configure –help|grep module来查看有哪些内置模块，编译时候直接加上就可以了。</p><p>除了nginx内置的模块，网络上还有很多第三方的模块，可以通过编译时候加参数–add-module=PATH指定模块源码来编译。</p><p>下面介绍一些我们线上用过而且比较赞的内置模块。</p><h3 id="3-1-stream"><a href="#3-1-stream" class="headerlink" title="3.1 stream"></a>3.1 stream</h3><p>端口转发的模块，从nginx1.9版本才开始支持，包含tcp和udp的支持，和IPTABLES相比这个虽然是应用层，会监听端口，但是配置起来很方便，比IPTABLES灵活，在tcp模块下面添加类似vhost的server就可以了，方便自动化管理，参考配置：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; server &#123;</span><br><span class="line">&gt;     listen PORT;</span><br><span class="line">&gt;     proxy_pass IP:PORT;</span><br><span class="line">&gt;     access_log /data/logs/tcp/PORT.log;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-2-http-realip-module"><a href="#3-2-http-realip-module" class="headerlink" title="3.2 http_realip_module"></a>3.2 http_realip_module</h3><p>nginx反向代理之后，如何让后端web直接获取到的IP不是反向代理的iP，而是直接获取到用户的真实IP呢，就需要这个模块了，不需要代码那里再做类似X-Real-IP的变量特殊判断。</p><h3 id="3-3-http-slice-module"><a href="#3-3-http-slice-module" class="headerlink" title="3.3 http_slice_module"></a>3.3 http_slice_module</h3><p>在做CDN时候可以用到，让一个大文件分片，分成多个小文件通过206断点续传到后端，然后再组合起来，避免大文件直接回源导致多副本和多次回源的问题。</p><h3 id="3-4-http-secure-link-module"><a href="#3-4-http-secure-link-module" class="headerlink" title="3.4 http_secure_link_module"></a>3.4 http_secure_link_module</h3><p>前面说到的防盗链可以用这个来做，但是这个一般是针对那种文件下载时候用到的，比如从网页下载时候，服务端生成一个加密URL给用户，然后这个URL有过期时间之类的，避免此URL被多次分享出去，不过普通的素材加载还是用普通的防盗链即可。</p><h3 id="3-5-http-sub-module"><a href="#3-5-http-sub-module" class="headerlink" title="3.5 http_sub_module"></a>3.5 http_sub_module</h3><p>替换响应给用户的内容，相对于sed之后再返回，比如可以在需要临时全局修改网站背景或者title时候可以一次性处理好。</p><h2 id="4-扩展项目"><a href="#4-扩展项目" class="headerlink" title="4. 扩展项目"></a>4. 扩展项目</h2><p>简单介绍下大名鼎鼎的两个基于nginx的扩展项目，也是我们线上有很多地方用到的。</p><h3 id="4-1-openresty"><a href="#4-1-openresty" class="headerlink" title="4.1 openresty"></a>4.1 openresty</h3><p>集成lua脚本，几乎可以完成任何普通web相关的需求。</p><p>比如URL加密进行防劫持和防盗链，服务端动态生成一串aes加密的URL给CDN，CDN的openresty解密之后用普通的URL转发到后端，然后再返回给用户正确的内容。</p><h3 id="4-2-tengine"><a href="#4-2-tengine" class="headerlink" title="4.2 tengine"></a>4.2 tengine</h3><p>淘宝的nginx修改版，实现了很多nginx的收费功能或者是特殊功能，比如动态加载、concat合并请求，动态解析等。</p><p>我们python开发的后台基本都是用的这个版本，主要是利用了concat的合并素材的功能。</p><h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h2><p>Nginx是个非常实用软件，部分功能已经超越了普通的web服务定位，同时它具备开源、轻量、自动化等特性，能有效解决实际工作中很多特殊场景的需求，祝Nginx在全球的份额持续攀升~</p><p>原文地址：<a href="http://www.yunweipai.com/archives/24973.html" target="_blank" rel="noopener">http://www.yunweipai.com/archives/24973.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;
      
    
    </summary>
    
      <category term="nginx" scheme="http://www.python100.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://www.python100.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库优化建议</title>
    <link href="http://www.python100.com/2018/07/31/%E4%BC%98%E5%8C%96_MySQL_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9A%84%E5%BB%BA%E8%AE%AE/"/>
    <id>http://www.python100.com/2018/07/31/优化_MySQL_数据库性能的建议/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:48:00.925Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><p>应用程序、网站和数据库之间的交互会直接影响到应用服务水平的确立。</p><p>这种交互的一个核心组成部分是：各种应用程序如何去查询数据库，以及数据库是如何响应各种请求的。</p><h3 id="MySQL-数据库性能的-7-点必备技巧："><a href="#MySQL-数据库性能的-7-点必备技巧：" class="headerlink" title="MySQL 数据库性能的 7 点必备技巧："></a>MySQL 数据库性能的 7 点必备技巧：</h3><ul><li><p><strong>学习如何使用EXPLAIN</strong></p></li><li><p><strong>创建正确的索引</strong></p></li><li><p><strong>拒绝默认设置</strong></p></li><li><p><strong>将数据库载入内存中</strong></p></li><li><p><strong>使用SSD存储</strong></p></li><li><p><strong>横向扩展</strong></p></li><li><p><strong>追求可视性</strong></p></li></ul><h3 id="一、EXPLAIN-命令"><a href="#一、EXPLAIN-命令" class="headerlink" title="一、EXPLAIN 命令"></a>一、EXPLAIN 命令</h3><p>输出有两种不同的格式：老式的表格形式和较新的、能够提供更为细节化的、结构化的 JSON 文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain format=json select avg(k) from sbtest1 where id between 1000 and 2000 \G</span><br></pre></td></tr></table></figure><h3 id="二、创建正确的索引"><a href="#二、创建正确的索引" class="headerlink" title="二、创建正确的索引"></a>二、创建正确的索引</h3><p>索引是通过减少在数据库里查询时，必须扫描的数据量来提高查询的自身效率。</p><p>在 MySQL 中，索引被用于加快对数据库的访问，并有助于遵循数据库的各种约束（例如 UNIQUE 和 FOREIGN KEY）。</p><p>数据库索引就像书的索引一样，它们的位置信息被保存，并且包含有数据库的主要信息。</p><p>它们是数据位置的一种参考方法或映射，因此索引并不会更改数据库中的任何数据。它们只是指向数据存放的位置而已。</p><p>不过，索引并不总能匹配上任何的负载请求。在系统运行中，您应当不断为查询的上下文环境创建各种索引。</p><p>虽然有着良好索引的数据库会运行更快速，但是如果出现单个索引的缺失，则会拖慢整个数据库的效率。</p><p>因此，我们需要使用 EXPLAIN 来查找缺失的索引，并将其添加上去。</p><p>需要注意的是：不要添加您所不需要的索引，因为不必要的索引会反过来拖慢数据库。</p><h3 id="三、拒绝默认设置"><a href="#三、拒绝默认设置" class="headerlink" title="三、拒绝默认设置"></a>三、拒绝默认设置</h3><p>就像其他任何软件那样，MySQL 也能通过各种可配置的设置，来修改其行为并最终优化其性能。</p><p>同时这些配置的设置经常会被管理员所忽略，并一直保持着默认值的状态。</p><p>为了让 MySQL 获得最佳的性能，了解如何配置 MySQL，以及将它们设置为最适合您的数据库环境的状态是非常重要的。</p><p>在默认情况下，MySQL 是针对小规模的发布、安装进行调优的，而并非真正的生产环境规模。</p><p>因此，通常您需要将 MySQL 配置为使用所有可用的内存资源，并且能允许您的应用程序所需的最大连接数。</p><p>这里有三个有关 MySQL 性能优化的设置，值得您去仔细地配置：</p><h3 id="innodb-buffer-pool-size"><a href="#innodb-buffer-pool-size" class="headerlink" title="innodb_buffer_pool_size"></a><strong>innodb_buffer_pool_size</strong></h3><p>数据和索引被用作缓存的缓冲池。当您的数据库服务器有着大量的系统内存时，可以用到该设置。</p><p>如果您只运行 InnoDB 存储引擎，那么您通常可以分配 80％ 左右的内存给该缓冲池。</p><p>而如果您要运行非常复杂的查询或者您有大量的并发数据库连接，亦或您有非常大的数据表的情况，那么就可能需要将此值下调一个等级，以便为其他的调用分配更多的内存。</p><p>您在设置 InnoDB 缓冲池大小的时候，要确保其设置既不要过大，也不要频繁引起交换（swapping），因为这些绝对会降低您的数据库性能。有一个简单的检查方法就是在“Percona 监控和管理”。</p><p>如果您一开始并没有将 innodb_buffer_pool_size 的值设置正确，也不必担心。</p><p>从 MySQL 5.7 开始，您可以动态地改变 InnoDB 缓冲池的大小，而不需要重新启动数据库服务器了。</p><h3 id="innodb-log-file-size"><a href="#innodb-log-file-size" class="headerlink" title="innodb_log_file_size"></a><strong>innodb_log_file_size</strong></h3><p>这是指单个 InnoDB 日志文件的大小。默认情况下，InnoDB 使用两个值，这样您就可以通过将其增加一倍，来让 InnoDB 获得循环的重做日志空间，以确保交易的持久性。这同时也优化了对数据库的写入性能。</p><p>设置 innodb_log_file_size 的值是很值得推敲的：如果分配了较大的重做空间，那么对于写入密集型的工作负载来说性能会越好。</p><p>但是如果您的系统遭受到断电或其他问题导致崩溃的时候，那么其恢复时间则会越长。</p><p>您可能会问：怎么才能知道自己的 MySQL 性能是否受限于当前的 InnoDB 日志文件大小呢？</p><p>您可以通过查看未实际使用的重做日志空间大小来判定。最简单的方法就是查看“Percona 监控和管理”的 InnoDB 指标仪表板。因此，您的日志文件应该至少比使用量大 20％，从而保持系统处于最佳的性能状态。</p><h3 id="max-connections"><a href="#max-connections" class="headerlink" title="max_connections"></a><strong>max_connections</strong></h3><p>大型应用程序通常需要比默认数量多得多的连接。不同于其他的变量，如果您没能将该值设置正确，您就会碰到性能方面的问题。</p><p>也就是说，如果连接的数量不足以满足您的应用需求，那么应用程序将根本无法连接到数据库，在用户看来就像宕机了一样。由此可见，将它设置正确是非常重要的。</p><p>对于在多台服务器上运行着具有多个组件的复杂应用来说，您想获知到底需要多少个连接是非常困难的。</p><p>幸运的是，MySQL 能够在峰值操作时轻易地获悉所用到的连接数量。通常，您需要确保在应用程序所使用到的最大连接数和可用的最大连接数之间至少有 30％ 的差额。</p><p>查看这些数字的一个简单方法是：在“Percona 监控和管理”的系统概述界面中查看使用 MySQL 连接图。</p><p>还有一点需要记住：如果您的应用程序所创建的连接数量过多，通常会导致数据库运行缓慢。</p><p>在这种情况下，您应该在数据库性能上做文章，而不是简单地允许建立更多的连接。更多的连接会使得潜在的性能问题更加恶化。</p><h3 id="四、将数据库载入内存中"><a href="#四、将数据库载入内存中" class="headerlink" title="四、将数据库载入内存中"></a>四、将数据库载入内存中</h3><p>年来，出现了固态硬盘（SSD）方向上的转变。尽管固态硬盘比传统机械旋臂硬盘快得多，但是它们仍然敌不过将数据存在内存里。</p><p>这种差别不仅来自于存储性能本身，还来自于数据库从磁盘或 SSD 里存取数据时所产生的额外工作。</p><p>随着近年来硬件技术的改进，不管您是运行在云端，还是管理着自己的硬件，将数据库载入内存已经变得可行</p><h3 id="五、使用-SSD-存储"><a href="#五、使用-SSD-存储" class="headerlink" title="五、使用 SSD 存储"></a>五、使用 SSD 存储</h3><p>无论您的数据库是否已被载入内存，您都需要使用快速存储来处理写入操作，并且避免在数据库启动后（重启之后）出现性能问题。这里的快速存储就是指固态硬盘。</p><p>一些所谓的“专家”仍在基于成本和可靠性的基础上，主张使用机械旋臂硬盘。坦率地说，当涉及到数据库操作时，这些建议往往是过时的或是完全错误的。现如今，固态硬盘的性能已经非常卓越、可靠且价格低廉了。</p><p>并非所有的固态硬盘都是同等生产的。对于数据库服务器来说，您应该选用那些专供服务器工作负载、且能精心呵护数据的 SSD。</p><p>例如：防止断电损坏的，而避免使用那些专为台式和笔记本电脑设计的商用固态硬盘。</p><p>通过 NVMe 或英特尔 Optane 技术来直接连接的 SSD 往往能够提供最佳的性能。</p><p>即使远程连接到 SAN、NAS 或云端的块设备上，固态硬盘也能比机械旋臂硬盘提供更为优越的性能。</p><h3 id="六、横向扩展"><a href="#六、横向扩展" class="headerlink" title="六、横向扩展"></a>六、横向扩展</h3><p>即使是性能最高的服务器也有局限性。业界一般用两种方法来进行扩展：纵向和横向。</p><p>纵向扩展意味着购买更多的硬件。这样做不但成本昂贵，而且硬件折旧速度快。</p><p>而横向扩展，则在处理负载方面有如下几点优势：</p><ul><li>您可以从更小型、成本更低的系统中获益。</li><li>横向扩展使得系统的线性扩展更方便、更快捷。</li><li>由于数据库会横跨增长到多个物理机上，横向扩展在保护数据库的同时，消除了硬件单点故障。</li></ul><p>尽管横向扩展有着诸多优势，不过它还是具有一定的局限性。横向扩展需要数据复制，例如基本的 MySQL Replication 或是用于数据同步的 Percona XtraDB 群集。</p><p>但是作为回报，您也会获得更高的性能和可用性。如果您需要更高级的扩展性，那么请考虑使用 MySQL 分片（sharding）。</p><p>另外，您还需要确保连接到群集架构的应用程序可以找到它们所需的数据。这通常是通过诸如 ProxySQL 或 HAProxy 的一些代理服务器和负载平衡器来实现的。</p><p>当然，过早地规划横向扩展，会增加分布式数据库的复杂性。最近发布的 MySQL 8 候选版本已声称自己能够在单一的系统上处理超过 200 万个简单查询。</p><h3 id="七、追求可视性"><a href="#七、追求可视性" class="headerlink" title="七、追求可视性"></a>七、追求可视性</h3><p>可视性是系统设计的最佳境界，MySQL 也不例外。</p><p>一旦完成了 MySQL 环境的搭建、运行并调优，您千万不要认为已经万事大吉了。</p><p>数据库环境既会受到来自系统更改或流量负荷的影响，也会遇到例如流量高峰、应用程序错误以及 MySQL 自身的各种问题。</p><p>为了快速、有效地解决各种问题，您需要建立和实施一些监控机制，从而能获悉数据库环境的状态，并在出现错误时及时分析服务器上的数据。</p><p>因此理想情况就是在系统出现问题或是被用户所察觉之前就做到防范于未然。</p><p>常用的监测工具有：</p><ul><li><strong>MySQL企业监控器（Enterprise Monitor）。</strong></li><li><strong>Monyog。</strong></li><li><strong>具有免费与开源版本的 Percona 监控和管理（PMM）。</strong></li></ul><p>这些工具在监控和故障排除方面提供了很好的操作可视性。</p><p>随着越来越多的公司在大规模生产环境中使用开源的数据库（特别是MySQL）来管理和服务他们的业务数据，他们需要把工作重心放在保持数据库的调优和运行效率上。</p><p>MySQL 的确是一款能够提升您的应用程序和网站性能的优秀数据库，当然您需要通过对它进行调整，以满足业务需求，监测、发现并防止任何瓶颈和性能方面的问题。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;应用程序、网站和数据库之间的交互会直接影响到应用服务水平的确立。&lt;/p&gt;&lt;p&gt;这种交互的一个核心组成部分是：各种应用程序如何去查询数据库，以及数据库
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.python100.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.python100.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql日志查询</title>
    <link href="http://www.python100.com/2018/07/31/mysql%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E9%9B%86/"/>
    <id>http://www.python100.com/2018/07/31/mysql日志查询集/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:49:29.453Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h2 id="mysql日志查询"><a href="#mysql日志查询" class="headerlink" title="mysql日志查询"></a>mysql日志查询</h2><h3 id="binlog介绍"><a href="#binlog介绍" class="headerlink" title="binlog介绍"></a>binlog介绍</h3><ol><li>binlog,即二进制日志,它记录了数据库上的所有改变.</li><li>改变数据库的SQL语句执行结束时,将在binlog的末尾写入一条记录,同时通知语句解析器,语句执行完毕.</li><li>binlog格式</li></ol><h3 id="登录到mysql查看binlog"><a href="#登录到mysql查看binlog" class="headerlink" title="登录到mysql查看binlog"></a>登录到mysql查看binlog</h3><p>只查看第一个binlog文件的内容 show binlog events;</p><p>查看指定binlog文件的内容 show binlog events in ‘mysql-bin.000002’;</p><p>查看当前正在写入的binlog文件 show master status\G</p><p>获取binlog文件列表 show binary logs;</p><h3 id="用mysqlbinlog工具查看"><a href="#用mysqlbinlog工具查看" class="headerlink" title="用mysqlbinlog工具查看"></a>用mysqlbinlog工具查看</h3><p>本地查看</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 基于开始/结束时间 </span><br><span class="line">mysqlbinlog --start-datetime=<span class="string">'2013-09-10 00:00:00'</span> --stop-datetime=<span class="string">'2013-09-10 01:01:01'</span> -d 库名 二进制文件</span><br><span class="line">&gt; 基于pos值</span><br><span class="line">mysqlbinlog --start-postion=<span class="number">107</span> --stop-position=<span class="number">1000</span> -d 库名 二进制文件</span><br><span class="line">&gt; 转换为可读文本</span><br><span class="line">mysqlbinlog –base64-output=DECODE-ROWS -v -d 库名 二进制文件</span><br></pre></td></tr></table></figure><p>远程查看</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 指定开始/结束时间,并把结果重定向到本地t.binlog文件中.</span><br><span class="line">mysqlbinlog -u username -p password -hl-db1.dba.beta.cn6.qunar.com -P3306 \</span><br><span class="line">--read-from-remote-server --start-datetime=<span class="string">'2013-09-10 23:00:00'</span> --stop-datetime=<span class="string">'2013-09-10 23:30:00'</span> mysql-bin.<span class="number">000001</span> &gt; t.binlog</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h2 id=&quot;mysql日志查询&quot;&gt;&lt;a href=&quot;#mysql日志查询&quot; class=&quot;headerlink&quot; title=&quot;mysql日志查询&quot;&gt;
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.python100.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.python100.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql常用备份操作</title>
    <link href="http://www.python100.com/2018/07/31/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"/>
    <id>http://www.python100.com/2018/07/31/mysql备份恢复/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:49:43.102Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h2 id="mysql压缩备份"><a href="#mysql压缩备份" class="headerlink" title="mysql压缩备份"></a>mysql压缩备份</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、mysqldump 备份并压缩sql文件</span><br><span class="line">mysql&gt;mysqldump -h主机ip -u用户名 -p密码（也可不输入） 数据库名   | gzip &gt; 压缩后文件位置</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、mysql直接用压缩文件恢复</span><br><span class="line">mysql&gt;gunzip &lt; backupfile.sql.gz | mysql -u用户名 -p密码（也可不输入） 数据库名</span><br></pre></td></tr></table></figure><h4 id="一、备份常用操作基本命令"><a href="#一、备份常用操作基本命令" class="headerlink" title="一、备份常用操作基本命令"></a>一、备份常用操作基本命令</h4><p>1、备份命令mysqldump格式</p><p>格式：mysqldump -h主机名 -P端口 -u用户名 -p密码 –database 数据库名 &gt; 文件名.sql</p><p>2、备份MySQL数据库为带删除表的格式</p><p>备份MySQL数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库。</p><p>mysqldump –add-drop-table -uusername -ppassword -database databasename &gt; backupfile.sql</p><p>3、直接将MySQL数据库压缩备份</p><p>mysqldump -hhostname -uusername -ppassword -database databasename | gzip &gt; backupfile.sql.gz</p><p>4、备份MySQL数据库某个(些)表</p><p>mysqldump -hhostname -uusername -ppassword databasename specific_table1 specific_table2 &gt; backupfile.sql</p><p>5、同时备份多个MySQL数据库</p><p>mysqldump -hhostname -uusername -ppassword <strong>–databases</strong> databasename1 databasename2 databasename3 &gt; multibackupfile.sql仅仅备6、仅备份份数据库结构</p><p>mysqldump –no-data –databases databasename1 databasename2 databasename3 &gt; structurebackupfile.sql</p><p>7、备份服务器上所有数据库</p><p>mysqldump –all-databases &gt; allbackupfile.sql</p><p>mysqldump -h 192.168.27.40 –flush-logs –all-databases -p -udba &gt; /mysql_backup/backup_40.sql</p><p>忽略某个表，mysqldump不提供忽略某个库的参数</p><p>mysqldump -h 192.168.27.72 –ignore-table=huisou.tbl_product_sale_summary –flush-logs –all-databases -pjsrh1sdshj -udba &gt; //mysql_backup/dbbackup/mysqlback/hs.sql</p><p>8、还原MySQL数据库的命令</p><p>mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sql</p><p>9、还原压缩的MySQL数据库</p><p>gunzip &lt; backupfile.sql.gz | mysql -uusername -ppassword databasename</p><p>10、将数据库转移到新服务器</p><p>mysqldump -uusername -ppassword databasename | mysql –host=<em>.</em>.<em>.</em> -C databasename</p><p>11、–master-data 和–single-transaction</p><p>在mysqldump中使用–master-data=2，会记录binlog文件和position的信息 。–single-transaction会将隔离级别设置成repeatable-commited</p><p>12、导入数据库</p><p>常用source命令，用use进入到某个数据库，mysql&gt;source d:\test.sql，后面的参数为脚本文件。</p><p>13、查看binlog日志</p><p>查看binlog日志可用用命令 mysqlbinlog binlog日志名称|more</p><p>14、general_log</p><p>General_log记录数据库的任何操作，查看general_log 的状态和位置可以用命令show variables like “general_log%” ,开启general_log可以用命令set global general_log=on</p><h4 id="二、增量备份"><a href="#二、增量备份" class="headerlink" title="二、增量备份"></a>二、增量备份</h4><p>小量的数据库可以每天进行完整备份，因为这也用不了多少时间，但当数据库很大时，就不太可能每天进行一次完整备份了，这时候就可以使用增量备份。增量备份的原理就是使用了<a href="http://www.centos.bz/category/mysql/" target="_blank" rel="noopener">mysql</a>的binlog志。</p><p>1、首先做一次完整备份：</p><p>mysqldump -h10.6.208.183 -utest2 -p123 -P3310 –single-transaction –master-data=2 test&gt;test.sql这时候就会得到一个全备文件test.sql</p><p>在sql文件中我们会看到：<br>– CHANGE MASTER TO MASTER_LOG_FILE=’bin-log.000002’, MASTER_LOG_POS=107;是指备份后所有的更改将会保存到bin-log.000002二进制文件中。<br>2、在test库的t_student表中增加两条记录，然后执行flush logs命令。这时将会产生一个新的二进制日志文件bin-log.000003，bin-log.000002则保存了全备过后的所有更改，既增加记录的操作也保存在了bin-log.00002中。</p><p>3、再在test库中的a表中增加两条记录，然后误删除t_student表和a表。a中增加记录的操作和删除表a和t_student的操作都记录在bin-log.000003中。</p><h4 id="三、恢复"><a href="#三、恢复" class="headerlink" title="三、恢复"></a>三、恢复</h4><p>1、首先导入全备数据</p><p>mysql -h10.6.208.183 -utest2 -p123 -P3310 &lt; test.sql，也可以直接在mysql命令行下面用source导入</p><p>2、恢复bin-log.000002</p><p>mysqlbinlog bin-log.000002 |mysql -h10.6.208.183 -utest2 -p123 -P3310</p><p>3、恢复部分 bin-log.000003</p><p>在general_log中找到误删除的时间点，然后更加对应的时间点到bin-log.000003中找到相应的position点，需要恢复到误删除的前面一个position点。</p><p>可以用如下参数来控制binlog的区间</p><p>–start-position 开始点 –stop-position 结束点</p><p>–start-date 开始时间 –stop-date 结束时间</p><p>找到恢复点后，既可以开始恢复。</p><p>mysqlbinlog mysql-bin.000003 –stop-position=208 |mysql -h10.6.208.183 -utest2 -p123 -P3310</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h2 id=&quot;mysql压缩备份&quot;&gt;&lt;a href=&quot;#mysql压缩备份&quot; class=&quot;headerlink&quot; title=&quot;mysql压缩备份&quot;&gt;
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.python100.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.python100.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>linux运维面试题</title>
    <link href="http://www.python100.com/2018/07/31/Linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://www.python100.com/2018/07/31/Linux运维面试题/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:50:53.147Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><p>1、<strong>解释top命令和vmstat命令</strong></p><p><strong>top命令用来的监控linux系统的状况，比如系统持续运行时间、登录的用户数、负载状况，</strong></p><p><strong>cpu和内存及swap使用状况，还有个进程任务的动态监控。</strong></p><p>vmstat可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存和虚拟内存交换情况,磁盘IO读写情况</p><p>[root@localhost ~]# vmstat 2 1</p><p>2表示每个两秒采集一次服务器状态，1表示只采集一次。</p><p><strong>iostat是对系统磁盘IO操作进行监控，它的输出主要显示磁盘的读写操作的统计信息。同时给出cpu的使用情况</strong></p><p>mpstat可以监控到cpu的一些统计信息，在多核cpu的系统里不但能够查看所有cpu的平均状况信息，</p><p>而且能够查看特定的cpu的信息。</p><p>sar命令可以全名的获取到cpu 、运行、磁盘IO、虚拟内存、内存、网络等信息。</p><p>netstat 命令用于显示本机网络链接、运行端口、路由表等信息</p><p>ps命令是进程查看命令，使用这个命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、</p><p>哪些进程占用了过多的资源等。</p><p>lsof的原始功能是列出打开的文件的进程</p><h3 id="2、请写出iptables语句"><a href="#2、请写出iptables语句" class="headerlink" title="2、请写出iptables语句"></a>2、<strong>请写出iptables语句</strong></h3><p>1）本地80端口的请求转发到8080端口，当前主机IP为192.168.2.1</p><p>iptables -t nat -A PREROUTING -d 192.168.2.1 -p tcp -dport 80 -j DNAT -to 192.168.2.1:8080</p><p>2）允许本机对外连接80端口（本机能连外界服务器为80）</p><p>iptables -A OUTPUT -p tcp –dport 80 -j ACCEPT</p><p>3）开放本机的3306端口,22端口</p><p>iptables -A INPUT -p tcp –dport 3306 -j ACCEPT</p><p>4）禁止外界ping本服务器</p><p>iptables -A INPUT -p icmp -j DROP</p><p>5）防止SYN攻击（轻量级预防）</p><p>iptables -A FORWARD -p tcp –syn -m limit –limit 1/s -j ACCEPT</p><p>iptables -A FORWARD -p tcp –tcp-flags SYN,ACK,FIN,RST RST -m limit –limit 1/s -j ACCEPT</p><p>6)iptables -L -n</p><h3 id="3、Mysql高可用方案有哪些？Mysql备份方案有哪些？有什么缺点"><a href="#3、Mysql高可用方案有哪些？Mysql备份方案有哪些？有什么缺点" class="headerlink" title="3、Mysql高可用方案有哪些？Mysql备份方案有哪些？有什么缺点"></a>3、<strong>Mysql高可用方案有哪些？Mysql备份方案有哪些？有什么缺点</strong></h3><p>Mysql数据库高可用主要解决：万一数据库发生了宕机或者意外中断等故障，能尽快恢复数据库的可用性，尽可能的减少停机时间，</p><p>保证业务不会因为数据库的故障而中断</p><p>用作备份、只读副本等功能的非主节点的数据和主节点的数据实时或者最终保持一致。</p><p>当业务发生数据库切换时，切换前后的数据库内容应当一致，不会英文数据缺失或者数据不一致而影响业务。</p><h3 id="方案一：主从或者主主半同步复制"><a href="#方案一：主从或者主主半同步复制" class="headerlink" title="方案一：主从或者主主半同步复制"></a><strong>方案一：主从或者主主半同步复制</strong></h3><p>通常使用proxy、keepalived等第三方软件配合双节点数据库，搭建单向或者双向的半同步复制。</p><p>优点：1、结构简单，使用原生半同步复制作为数据同步的依据</p><p>​ 2、双节点，需求资源少，部署简单，没有主机宕机后的选主问题，直接切换。</p><p>缺点：完全依赖半同步复制，如果半同步复制退化为异步复制，数据一致性无法得到保障，需要额外考虑高可用机制</p><h3 id="方案二：半同步复制优化"><a href="#方案二：半同步复制优化" class="headerlink" title="方案二：半同步复制优化"></a><strong>方案二：半同步复制优化</strong></h3><p>半同步复制机制是可靠的，如果半同步复制 一致是生效的，那么便可以认为数据时一致的。但是由于网络波动等一些客观原因，</p><p>导致半同步复制发生超时而切换为异步复制，那么便不能保证数据的一致性。所以尽可能的保证半同步复制，便可提高数据一</p><p>致性。该方案也是使用双节点架构，在原有半同步复制的基础上做了功能上的优化，使得半同步复制的机制变得更可靠。</p><h3 id="优化方案三：双通道复制"><a href="#优化方案三：双通道复制" class="headerlink" title="优化方案三：双通道复制"></a>优化方案三：双通道复制</h3><h5 id="1、双通道复制"><a href="#1、双通道复制" class="headerlink" title="1、双通道复制"></a>1、双通道复制</h5><p>半同步复制由于发生超时后，复制断开，当再次建立起复制时，同时建立两条通道，其中一条半同步复制通道从当前</p><p>位置开始复制，保证从机知道当前主机执行的进度。另外一条异步复制通道开始追补从机落后的数据。当异步复制通</p><p>道追赶到半同步复制的起始位置时，恢复半同步复制。</p><h5 id="2、binlog文件服务器"><a href="#2、binlog文件服务器" class="headerlink" title="2、binlog文件服务器"></a>2、binlog文件服务器</h5><p>搭建两条半同步复制通道，其中连接文件服务器的半同步通道正常情况下不启用，当主从的半同步复制发生网络问题</p><p>退化后，启动与文件服务器的半同步复制通道。当主从半同步复制恢复后，关闭与文件服务器的半同步复制通道。</p><p>优点：双节点，需求资源少，部署简单，架构简单，没有选主问题，可直接切换，相比原生复制，优化后的半同步</p><p>复制更能保证数据的一致性。</p><p>缺点：需要修改内核源码或者使用mysql通信协议，需要对源码有一定的理解，并能做到一定程度的二次开发。</p><p>​ 依旧依赖半同步复制，没有从根本上解决数据一致性问题。</p><h3 id="方案四：高可用架构优化"><a href="#方案四：高可用架构优化" class="headerlink" title="方案四：高可用架构优化"></a><strong>方案四：高可用架构优化</strong></h3><p>​ 将双节点数据库扩展到多节点数据库，或者多节点数据库集群。可以根据自己的需要选择一主两从，一主多从或者多主多从集群</p><h5 id="常见方案：1、MHA-多节点集群"><a href="#常见方案：1、MHA-多节点集群" class="headerlink" title="常见方案：1、MHA+多节点集群"></a>常见方案：1、MHA+多节点集群</h5><p>MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的</p><p>master，然后将所有其他的slave重新指向新的master，整个故障转移过程对应用程序完全透明。</p><p>MHA Node运行在每台MySQL服务器上，主要作用是切换时处理二进制日志，确保切换尽量少丢数据。</p><p>优点：</p><p>可以进行故障的自动检测和转移;</p><p>可扩展性较好，可以根据需要扩展MySQL的节点数量和结构;</p><p>相比于双节点的MySQL复制，三节点/多节点的MySQL发生不可用的概率更低</p><p>缺点：</p><p>至少需要三节点，相对于双节点需要更多的资源;</p><p>逻辑较为复杂，发生故障后排查问题，定位问题更加困难;</p><p>数据一致性仍然靠原生半同步复制保证，仍然存在数据不一致的风险;</p><p>可能因为网络分区发生脑裂现象;</p><h5 id="常见方案：2、zookeeper-proxy"><a href="#常见方案：2、zookeeper-proxy" class="headerlink" title="常见方案：2、zookeeper+proxy"></a>常见方案：2、zookeeper+proxy</h5><p>Zookeeper使用分布式算法保证集群数据的一致性，使用zookeeper可以有效的保证proxy的高可用性，可以较</p><p>好的避免网络分区现象的产生。</p><p>优点：</p><p>较好的保证了整个系统的高可用性，包括proxy、MySQL;</p><p>扩展性较好，可以扩展为大规模集群;</p><p>缺点：</p><p>数据一致性仍然依赖于原生的mysql半同步复制;</p><p>引入zk，整个系统的逻辑变得更加复杂;</p><h3 id="方案五：共享存储"><a href="#方案五：共享存储" class="headerlink" title="方案五：共享存储"></a><strong>方案五：共享存储</strong></h3><p>共享存储实现了数据库服务器和存储设备的解耦，不同数据库之间的数据同步不再依赖于MySQL的原生复制功能，而是通过</p><p>磁盘数据同步的手段，来保证数据的一致性。</p><h5 id="1-SAN共享储存"><a href="#1-SAN共享储存" class="headerlink" title="(1) SAN共享储存"></a>(1) SAN共享储存</h5><p>SAN的概念是允许存储设备和处理器(服务器)之间建立直接的高速网络连接，通过这种连接实现数据的集中式存储。</p><p>使用共享存储时，MySQL服务器能够正常挂载文件系统并操作，如果主库发生宕机，备库可以挂载相同的文件系统，保证主库、</p><p>和备库使用相同的数据。</p><p>优点：</p><p>两节点即可，部署简单，切换逻辑简单;</p><p>很好的保证数据的强一致性;</p><p>不会因为MySQL的逻辑错误发生数据不一致的情况;</p><p>缺点：</p><p>需要考虑共享存储的高可用;</p><p>价格昂贵;</p><h5 id="2-DRBD磁盘复制"><a href="#2-DRBD磁盘复制" class="headerlink" title="(2) DRBD磁盘复制"></a>(2) DRBD磁盘复制</h5><p>DRBD是一种基于软件、基于网络的块复制存储解决方案，主要用于对服务器之间的磁盘、分区、逻辑卷等进行数据镜像，当用户将数据写入本地磁盘时，还会将数据发送到网络中另一台主机的磁盘上，这样的本地主机(主节点)与远程主机(备节点)的数据就可以保证实时同步。</p><p>当本地主机出现问题，远程主机上还保留着一份相同的数据，可以继续使用，保证了数据的安全。</p><p>DRBD是linux内核模块实现的快级别的同步复制技术，可以与SAN达到相同的共享存储效果。</p><p>优点：</p><p>两节点即可，部署简单，切换逻辑简单;</p><p>相比于SAN储存网络，价格低廉;</p><p>保证数据的强一致性;</p><p>缺点：</p><p>对io性能影响较大;</p><p>从库不提供读操作;</p><h3 id="方案六：-分布式协议"><a href="#方案六：-分布式协议" class="headerlink" title="方案六：** 分布式协议**"></a><strong>方案六：**</strong> 分布式协议**</h3><p>分布式协议可以很好解决数据一致性问题。比较常见的方案如下：</p><h5 id="1-MySQL-cluster"><a href="#1-MySQL-cluster" class="headerlink" title="(1) MySQL cluster"></a>(1) MySQL cluster</h5><p>MySQL cluster是官方集群的部署方案，通过使用NDB存储引擎实时备份冗余数据，实现数据库的高可用性和数据一致性。</p><p>优点：</p><p>全部使用官方组件，不依赖于第三方软件;</p><p>可以实现数据的强一致性;</p><p>缺点：</p><p>国内使用的较少;</p><p>配置较复杂，需要使用NDB储存引擎，与MySQL常规引擎存在一定差异;</p><p>至少三节点;</p><h5 id="2-Galera"><a href="#2-Galera" class="headerlink" title="(2) Galera"></a>(2) Galera</h5><p>基于Galera的MySQL高可用集群， 是多主数据同步的MySQL集群解决方案，使用简单，没有单点故障，可用性高。</p><p>优点：</p><p>多主写入，无延迟复制，能保证数据强一致性;</p><p>有成熟的社区，有互联网公司在大规模的使用;</p><p>自动故障转移，自动添加、剔除节点;</p><p>缺点：</p><p>需要为原生MySQL节点打wsrep补丁</p><p>只支持innodb储存引擎</p><p>至少三节点;</p><h5 id="3-POAXS"><a href="#3-POAXS" class="headerlink" title="(3) POAXS"></a>(3) POAXS</h5><p>Paxos 算法解决的问题是一个分布式系统如何就某个值(决议)达成一致。这个算法被认为是同类算法中最有效的。Paxos与</p><p>MySQL相结合可以实现在分布式的MySQL数据的强一致性。</p><p>优点：</p><p>多主写入，无延迟复制，能保证数据强一致性;</p><p>有成熟理论基础;</p><p>自动故障转移，自动添加、剔除节点;</p><p>缺点：</p><p>只支持innodb储存引擎</p><p>随着官方MySQL Group Replication的GA，使用分布式协议来解决数据一致性问题已经成为了主流的方向。</p><p>一系列成熟的产品如PhxSQL、MariaDB Galera Cluster、Percona XtraDB Cluster等越来越多的被大规模使用。</p><h3 id="4、写出apache2-x的两种工作模式，以及各自的工作原理。如何查看apache当前支持的模块。并查看再哪种模式下工作。"><a href="#4、写出apache2-x的两种工作模式，以及各自的工作原理。如何查看apache当前支持的模块。并查看再哪种模式下工作。" class="headerlink" title="4、写出apache2.x的两种工作模式，以及各自的工作原理。如何查看apache当前支持的模块。并查看再哪种模式下工作。"></a>4、<strong>写出apache2.x的两种工作模式，以及各自的工作原理。如何查看apache当前支持的模块。并查看再哪种模式下工作。</strong></h3><p><strong>prefork(多进程，每个进程产生子进程)和worker（多进程，每个进程生成多个线程)两种模式。</strong><br><strong>prefork 的工作原理</strong>是，控制进程在最初建立“StartServers”个子进程后，为了满足MinSpareServers 设置的需要创建一个进程，等待一秒钟，继续创建两个，再等待一秒钟，继续创建四个……如此按指数级增加创建的进程数，最多达到每秒32 个，直到满足MinSpareServers 设置的值为止。这就是预派生（prefork）的由来。这种模式可以不必在请求到来时再产生新的进程，从而减小了系统开销以增加性能。<br><strong>worker 是2.0 版中全新的支持多线程和多进程混合模型的MPM</strong>。由于使用线程来处理，所以可以处理相对海量的请求，而系统资源的开销要小于基于进程的服务器。但是，worker 也使用了多进程，每个进程又生成多个线程，以获得基于进程服务器的稳定性。这种MPM 的工作方式将是Apache 2.0 的发展趋势。可以通过命令httpd -l 可以查看apache 当前的模块，如果带有worker.c 就是工作在worker 模式下，如果有prefork.c 就是工作在prefork.c 的模式下。</p><h3 id="5、Linux基础问题："><a href="#5、Linux基础问题：" class="headerlink" title="5、Linux基础问题："></a>5、<strong>Linux基础问题：</strong></h3><p><strong>1）linux怎么查看用户登录日志</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who/var/log/wtmp   cat/var/log/secure</span><br></pre></td></tr></table></figure><p><strong>2）Linux中utmp，wtmp，lastlog，message各个文件的作用</strong></p><p>有关当前登录用户信息记录在utmp中；使用who命令</p><p>用户登录进入和退出记录在文件wtmp中；使用w命令</p><p>用户最后一次登录的文件可以使用lastlog查看；</p><p>messages=======从syslog中记录信息</p><p><strong>3）列举你熟悉的服务器区性能查看命令</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看磁盘df -h</span><br><span class="line">查看内存大小free vmstat</span><br><span class="line">只查看cpucat /proc/cupinfo</span><br><span class="line">只查看cpu数量grep “model name” /proc/cpuinfo|wc -l</span><br><span class="line">只查看系统内存cat /proc/meminfo</span><br><span class="line">查看每个进程的情况cat /proc/<span class="number">5346</span>/status</span><br><span class="line">查看负载w</span><br><span class="line">查看系统整体状态 top</span><br></pre></td></tr></table></figure><p>4）<strong>服务器间怎么实现无密码登录。列举操作步骤</strong></p><p>ssh-keygen #生成本地私钥，一路Enter即可</p><p>ssh-copy-id <a href="mailto:root@192.168.1.137" target="_blank" rel="noopener">root@192.168.1.137</a> #上传本地私钥到目标服务器137</p><p>ssh <a href="mailto:root@192.168.1.137" target="_blank" rel="noopener">root@192.168.1.137</a> #免密码登陆服务器137</p><p><strong>5）Netstat的常用用法</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">netstat -a   列出所有当前的连接</span><br><span class="line"></span><br><span class="line">netstat -at使用 -t 选项列出 TCP 协议的连接</span><br><span class="line"></span><br><span class="line">netstat -au使用 -u 选项列出 UDP 协议的连接</span><br><span class="line"></span><br><span class="line">netstat -ant 使用 -n 选项禁用域名解析功能,也就是只显示ip,不显示主机名</span><br><span class="line"></span><br><span class="line">netstat -tnl  使用 -l 选项列出正在监听的套接字连接</span><br><span class="line"></span><br><span class="line">netstat -nlpt 使用 -p 选项查看进程信息</span><br><span class="line"></span><br><span class="line">netstat -ltpe  使用 -ep 选项可以同时查看进程名和用户名</span><br><span class="line"></span><br><span class="line">netstat -s 列出所有网络包的统计情况，netstat 可以打印出网络统计数据，包括某个协议下的收发包数量</span><br><span class="line"></span><br><span class="line">netstat -rn 使用 -r 选项打印内核路由信息。打印出来的信息与 route 命令输出的信息一样。</span><br><span class="line"></span><br><span class="line">netstat -ie  netstat 也能打印网络接口信息，-i 选项就是为这个功能而生，也就是相对于ifconfig</span><br><span class="line"></span><br><span class="line">netstat -ct这个命令可持续输出 TCP 协议信息， -c 选项持续输出信息</span><br><span class="line"></span><br><span class="line">netstat -nat |awk <span class="string">'&#123;print $6&#125;'</span>|sort|uniq -c查看TCP各种状态列表</span><br><span class="line"></span><br><span class="line">netstat -atnp | grep ESTA</span><br><span class="line"></span><br><span class="line">active 状态的套接字连接用 <span class="string">"ESTABLISHED"</span> 字段表示，所以我们可以使用 grep 命令获得 active 状态的连接</span><br><span class="line"></span><br><span class="line">查看连接某服务端口最多的的IP地址</span><br><span class="line"></span><br><span class="line">netstat -nat | grep <span class="string">"192.168.1.15:22"</span> |awk <span class="string">'&#123;print  $5&#125;'</span>|awk -F: <span class="string">'&#123;print $1&#125;'</span>|sort|uniq -c|sort -nr|head -<span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="6、软件类问题"><a href="#6、软件类问题" class="headerlink" title="6、软件类问题"></a><strong>6、软件类问题</strong></h3><h3 id="keepalived和heartbeat的优缺点，适合哪些场合"><a href="#keepalived和heartbeat的优缺点，适合哪些场合" class="headerlink" title="keepalived和heartbeat的优缺点，适合哪些场合"></a><strong>keepalived和heartbeat的优缺点，适合哪些场合</strong></h3><p>Keepalived使用的vrrp协议方式，虚拟路由冗余协议 (Virtual Router Redundancy Protocol，简称VRRP)；<br>Heartbeat是基于主机或网络的服务的高可用方式；<br>keepalived的目的是模拟路由器的双机<br>heartbeat的目的是用户service的双机<br>lvs的高可用建议用keepavlived<br>业务的高可用用heartbeat</p><p>1）Keepalived使用更简单：从安装、配置、使用、维护等角度上对比，Keepalived都比Heartbeat要简单得多，尤其是</p><p>Heartbeat 2.1.4后拆分成3个子项目，安装、配置、使用都比较复杂，尤其是出问题的时候，都不知道具体是哪个子系</p><p>统出问题了；而Keepalived只有1个安装文件、1个配置文件，配置文件也简单很多；</p><p>2）Heartbeat功能更强大：Heartbeat虽然复杂，但功能更强大，配套工具更全，适合做大型集群管理，而Keepalived主</p><p>要用于集群倒换，基本没有管理功能；</p><p>3）协议不同：Keepalived使用VRRP协议进行通信和选举，Heartbeat使用心跳进行通信和选举；Heartbeat除了走网络</p><pre><code>外，还可以通过串口通信，貌似更可靠；</code></pre><p>4）使用方式基本类似：如果要基于两者设计高可用方案，最终都要根据业务需要写自定义的脚本，Keepalived的脚本没有任</p><p>何约束，随便怎么写都可以；Heartbeat的脚本有约束，即要支持service start/stop/restart这种方式，而且Heartbeart</p><p>提供了很多默认脚本，简单的绑定ip，启动apache等操作都已经有了；</p><p><strong>使用建议：优先使用Keepalived，当Keepalived不够用的时候才选择Heartbeat</strong></p><h3 id="LVS-haproxy-nginx-各个优缺点，适合哪些场合"><a href="#LVS-haproxy-nginx-各个优缺点，适合哪些场合" class="headerlink" title="LVS haproxy nginx 各个优缺点，适合哪些场合"></a><strong>LVS haproxy nginx 各个优缺点，适合哪些场合</strong></h3><p>Nginx/LVS/HAProxy的基于Linux的开源免费的负载均衡软件。</p><p>LVS：使用集群技术和Linux操作系统实现一个高性能、高可用的服务器，它具有很好的可伸缩性、可靠性和可管理性，是一款强大实用的开源软件。</p><h3 id="LVS的优点："><a href="#LVS的优点：" class="headerlink" title="LVS的优点："></a>LVS的优点：</h3><p>1：抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最</p><p>强的，也保证了均衡器I/O的性能不会受到大流量的影响。；</p><p>2：lvs是专门的负载均衡软件，对任何应用都可以做负载均衡；</p><p>3：工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，目前用的比较多的是lvs+keepalived，比较大型的</p><p>用的多的是lvs+heartbeat。</p><h3 id="nginx的优点："><a href="#nginx的优点：" class="headerlink" title="nginx的优点："></a>nginx的优点：</h3><p>1：Nginx的高并发，同时能承载上万个并发连接；</p><p>2：nginx有充足的第三方功能模块的支持，主要通过upstream模块进行负载均衡；</p><p>3：nginx对网络的依赖较小，理论上只要Ping得通，网页访问正常，nginx就能连得通；</p><p>4：工作在网络的7层之上，可以针对http应用做一些分流的策略，它的正则规则比haproxy更为强大和灵活，这也是它目</p><p>前广泛流行的主要原因之一，nginx单凭这点可利用的场合就远多于lvs了。</p><h3 id="nginx的缺点："><a href="#nginx的缺点：" class="headerlink" title="nginx的缺点："></a>nginx的缺点：</h3><p>1：将Nginx当做反向代理时，负载均衡功能不是很好，对后端服务器的健康检查功能较弱；</p><p>2：nginx仅能支持http、https和email协议，这样就在适用范围上面小些，这个是它的缺点；</p><p>3：nginx只支持通过端口来检测，不支持通过url来检测。</p><h3 id="haproxy的优点："><a href="#haproxy的优点：" class="headerlink" title="haproxy的优点："></a>haproxy的优点：</h3><p>1：HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url</p><p>来检测后端服务器的状态；</p><p>2：haproxy也是专门的负载均衡软件，Haproxy可以负载http，还可以负载均衡mysql；</p><p>3：HAProxy是支持虚拟主机的。</p><p>总结这么多，我觉得根据不同的需求，不同的功能，可以选择不同的软件类的负载均衡软件，当然也是可以选择硬件类的负载均衡器。</p><p>像对于大型的，需要进行高并发的网站或者对网络不太严格的时候，可以使用nginx；</p><p>对于大型的Web服务器的时候可以使用haproxy；</p><p>对性能有严格要求的时候可以使用lvs，就单纯从负载均衡的角度来说，lvs也许会成为主流，更适合现在大型的互联网公司。</p><p><strong>Apache nginx lighttpd 各个优缺点，适合哪些场合</strong></p><p><strong>1. lighttpd</strong></p><p>Lighttpd是一个具有非常低的内存开销，cpu占用率低，效能好，以及丰富的模块等特点。lighttpd是众多OpenSource轻量级的web server中较为优秀的一个。支持FastCGI, CGI, Auth, 输出压缩(output compress), URL重写, Alias等重要功能。</p><p>Lighttpd使用fastcgi方式运行php,它会使用很少的PHP进程响应很大的并发量。</p><h3 id="Fastcgi的优点在于："><a href="#Fastcgi的优点在于：" class="headerlink" title="Fastcgi的优点在于："></a>Fastcgi的优点在于：</h3><p>(1)从稳定性上看, fastcgi是以独立的进程池运行来cgi,单独一个进程死掉,系统可以很轻易的丢弃,然后重新分配新的进程来运行逻辑.</p><p>(2)从安全性上看, fastcgi和宿主的server完全独立, fastcgi怎么down也不会把server搞垮,</p><p>(3)从性能上看, fastcgi把动态逻辑的处理从server中分离出来, 大负荷的IO处理还是留给宿主server, 这样宿主server</p><p>可以一心一意作IO,对于一个普通的动态网页来说, 逻辑处理可能只有一小部分, 大量的图片等静态IO处理完全不需要逻</p><p>辑程序的参与(注1)</p><p>(4)从扩展性上讲, fastcgi是一个中立的技术标准, 完全可以支持任何语言写的处理程序(php,java,python…)</p><h3 id="apache"><a href="#apache" class="headerlink" title="apache"></a><strong>apache</strong></h3><p>apache是世界排名第一的web服务器, 根据netcraft(<a href="http://www.netsraft.co.uk/" target="_blank" rel="noopener">www.netsraft.co.uk</a>)所作的调查,世界上百分之五十以上的web服务器在使用apache.</p><p>1995年4月, 最早的apache(0.6.2版)由apache group公布发行. apache group 是一个完全通过internet进行运作的非盈利机构, 由它来决定apache web服务器的标准发行版中应该包含哪些内容. 准许任何人修改隐错, 提供新的特征和将它移植到新的平台上, 以及其它的工作. 当新的代码被提交给apache group时, 该团体审核它的具体内容, 进行测试, 如果认为满意, 该代码就会被集成到apache的主要发行版中.</p><h3 id="apache-的特性"><a href="#apache-的特性" class="headerlink" title="apache 的特性:"></a>apache 的特性:</h3><p>1) 几乎可以运行在所有的计算机平台上.</p><p>2) 支持最新的http/1.1协议</p><p>3) 简单而且强有力的基于文件的配置(httpd.conf).</p><p>4) 支持通用网关接口(cgi)</p><p>5) 支持虚拟主机.</p><p>6) 支持http认证.</p><p>7) 集成perl.</p><p>8) 集成的代理服务器</p><p>9) 可以通过web浏览器监视服务器的状态, 可以自定义日志.</p><p>10) 支持服务器端包含命令(ssi).</p><p>11) 支持安全socket层(ssl).</p><p>12) 具有用户会话过程的跟踪能力.</p><p>13) 支持fastcgi</p><p>14) 支持java servlets</p><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a><strong>nginx</strong></h3><p>Nginx是俄罗斯人编写的十分轻量级的HTTP服务器,Nginx，它的发音为“engine X”， 是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器．Nginx是由俄罗斯人 Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发.</p><p>Nginx以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。其拥有匹配 Lighttpd的性能，同时还没有Lighttpd的内存泄漏问题，而且Lighttpd的mod_proxy也有一些问题并且很久没有更新。但是Nginx并不支持cgi方式运行，原因是可以减少因此带来的一些程序上的漏洞。所以必须使用FastCGI方式来执行PHP程序。</p><h3 id="nginx做为HTTP服务器，有以下几项基本特性："><a href="#nginx做为HTTP服务器，有以下几项基本特性：" class="headerlink" title="nginx做为HTTP服务器，有以下几项基本特性："></a>nginx做为HTTP服务器，有以下几项基本特性：</h3><p>处理静态文件，索引文件以及自动索引；打开文件描述符缓冲．</p><p>无缓存的反向代理加速，简单的负载均衡和容错．</p><p>FastCGI，简单的负载均衡和容错．</p><p>模块化的结构。包括gzipping, byte ranges, chunked responses,以及 SSI-filter等filter。如果由FastCGI或其它</p><p>代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待。</p><p>Nginx专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率。它支持内核Poll模型，能经受高负载的考验,有报告表明能支持高达 50,000个并发连接数。</p><p>Nginx具有很高的稳定性。其它HTTP服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前apache一旦上到200个以上进程，web响应速度就明显非常缓慢了。而Nginx采取了分阶段资源分配技术，使得它的CPU与内存占用率非常低。nginx官方表示保持10,000个没有活动的连接，它只占2.5M内存，所以类似DOS这样的攻击对nginx来说基本上是毫无用处的。就稳定性而言,nginx比lighthttpd更胜一筹。</p><p>Nginx支持热部署。它的启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。</p><h3 id="squid-vamish各个优缺点，适合哪些场合"><a href="#squid-vamish各个优缺点，适合哪些场合" class="headerlink" title="squid vamish各个优缺点，适合哪些场合"></a><strong>squid vamish各个优缺点，适合哪些场合</strong></h3><p>Squid是一个缓存internet数据的一个软件，它接收用户的下载申请，并自动处理所下载的数据，熟称代理。</p><p>当一个用户象要下载一个主页时，它向Squid发出一个申请，要Squid替它下载，然后Squid连接所申请网站并请求该主页，接着把该主页传给用户同时保留一个备份，当别的用户申请同样的页面时，Squid把保存的备份立即传给用户，使用户觉得速度相当快。目前，Squid 可以代理HTTP, FTP, GOPHER, SSL 和 WAIS 协议，暂不能代理POP, NNTP等协议。</p><p>Squid和vamish的比较，我了解的是在CDN的开发上。</p><p>CDN开发软件常用有Squid、Vamish、nginx、HAProxy、ATS，每种开发软件有其优缺点，如何根据性能对比来选择合适的CDN开发软件，将影响着CDN加速效果。</p><p>Squid：不能多核是硬伤，磁盘缓存容量有优势，功能多，支持ACL角色控制，支持ICP缓存协议，支持外部规则文件读取及热加载，支持热启动，典型的是网宿（网宿科技和锐网科技都是老牌的CDN服务商）</p><p>Varnish多核支持，内存缓存，性能强，功能够用，不支持集群，支持后端存活检查，不支持外部文件读取，需转义，支持热启动。</p><h3 id="raid磁盘阵列"><a href="#raid磁盘阵列" class="headerlink" title="raid磁盘阵列"></a>raid磁盘阵列</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Raid0 ：最少需要两块盘， 没用冗余数据，不做备份，任何一块磁盘损坏都无法运行。n块磁盘（同类型）的阵列理论上读写速度是单块磁盘的n倍（实际达不到），风险性也是单一n倍（实际更高），是磁盘阵列中存储性能最好的。适用于安全性不高，要求比较高性能的图形工作站或者个人站。</span><br><span class="line"></span><br><span class="line">Raid1：至少需要两块盘，磁盘数量是<span class="number">2</span>的n倍，每一块磁盘要有对应的备份盘，利用率是<span class="number">50</span>%，只要有一对磁盘没有损坏就可以正常使用。n组磁盘（<span class="number">2</span>n块同类型磁盘）的阵列理论上读取速度是单块磁盘的n倍（实际达不到），风险性是单一磁盘的n分之一（实际更低）。换盘后需要长时间的镜像同步，不影响外界访问，但整个系统性能下降。磁盘控制器负载比较大。适用于安全性较高，且能较快恢复数据的场合。</span><br><span class="line"></span><br><span class="line">Raid0+<span class="number">1</span>： 至少需要四块盘，磁盘数量也是<span class="number">2</span>的n倍。既有数据镜像备份，也能保证较高的读写速度。成本比较大。</span><br><span class="line"></span><br><span class="line">Raid3：至少需要<span class="number">3</span>块盘（<span class="number">2</span>块盘没有校验的意义）。将数据存放在n+<span class="number">1</span>块盘上，有效空间是n块盘的总和，最后一块存储校验信息。数据被分割存储在n块盘上，任一数据盘出现问题，可由其他数据盘通过校正监测恢复数据（可以带伤工作），换数据盘需要重新恢复完整的校验容错信息。对阵列写入时会重写校验盘的内容，对校验盘的负载较大，读写速度相较于Raid0较慢，适用于读取多而写入少的应用环境，比如数据库和web服务器。使用容错算法和分块的大小决定了Raid3在通常情况下用于大文件且安全性要求较高的应用，比如视频编辑、硬盘播出机、大型数据库等。</span><br><span class="line"></span><br><span class="line">Raid5：至少需要<span class="number">3</span>块盘，读取速度接近Raid0，但是安全性更高。安全性上接近Raid1，但是磁盘的利用率更高。可以认为是Raid0和Raid1的一个折中方案。只允许有一块盘出错，可以通过另外多块盘来计算出故障盘的数据，故障之后必须尽快更换。比Raid0+<span class="number">1</span>的磁盘利用率高，是目前比较常用的一种方案。</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;1、&lt;strong&gt;解释top命令和vmstat命令&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;top命令用来的监控linux系统的状况，比如系
      
    
    </summary>
    
      <category term="面试题" scheme="http://www.python100.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://www.python100.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="http://www.python100.com/2018/07/26/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%87%BD%E6%95%B0%E8%83%8C%E8%AF%B5/"/>
    <id>http://www.python100.com/2018/07/26/第二阶段函数背诵/</id>
    <published>2018-07-26T01:44:00.000Z</published>
    <updated>2018-07-31T15:51:27.149Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 函数  是一个容器，里面包含了代码执行语句，还有一系列的变量数据</span></span><br><span class="line">函数的参数是在定义函数时括号中的内容</span><br><span class="line">形参是一个待赋值的变量</span><br><span class="line">实参是函数实际调用时传递进去的值</span><br><span class="line">形参是被实参所赋值</span><br><span class="line">实参在传递的时候要和形参一一对应</span><br><span class="line">缺省参数：</span><br><span class="line">在函数定义时，指明一个形参的默认值，就可以不给这个具有默认值得参数传递参数了</span><br><span class="line">    给一个具有默认参数的形参传递一个实参，那么会覆盖原有的默认值</span><br><span class="line">    缺省参数的定义顺序一点是从右向左，从后向前</span><br><span class="line">    <span class="comment">#缺省参数可以让形参具有默认值</span></span><br><span class="line"><span class="comment">#缺省参数的定义一定是从右向左</span></span><br><span class="line"><span class="comment">#缺省参数后面要么是缺省，要么就没参数了</span></span><br><span class="line">不定长参数：</span><br><span class="line">元组不定长*arg</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line">            print(args)</span><br><span class="line">        func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'abc'</span>,<span class="string">'中国'</span>)</span><br><span class="line">     字典不定长：</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">            print(kwargs)   <span class="comment">#*args 用来接收不定长参数保存成元组</span></span><br><span class="line">    func(a=&#123;<span class="string">'name'</span>:<span class="string">'小明'</span>,<span class="string">'sex'</span>:<span class="string">'man'</span>&#125;,b=<span class="number">2</span>,c=<span class="number">3</span>)</span><br><span class="line">        形参：a,b,c</span><br><span class="line">        实参：就是后面的数据</span><br><span class="line">     不定长参数可以接收空值</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i,j,*args,**kwargs)</span>:</span></span><br><span class="line">            <span class="comment">#**kwargs 用来接收不定长参数保存成字典，而且在函数调用时，</span></span><br><span class="line">            <span class="comment">#一定要注意使用命名传参的方式</span></span><br><span class="line">            print(i,j,args,kwargs)</span><br><span class="line">         func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">     传递的时候首先传递单纯变量作为元组不定长，键值对不定长必须在后</span><br><span class="line">命名参数</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,c,d,e,f)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        func(b=<span class="number">1</span>,a=<span class="number">2</span>,d=<span class="number">3</span>,f=<span class="number">4</span>,e=<span class="number">3</span>,c=<span class="number">5</span>)</span><br><span class="line">        <span class="comment">#命名传参可以打乱顺序</span></span><br><span class="line">返回值</span><br><span class="line">    - 函数内部的一些操作，不能影响外界的事务</span><br><span class="line">    - <span class="keyword">return</span> 语句 在函数执行完成之后返回一个结果</span><br><span class="line">    - <span class="keyword">return</span> 会终止函数运行</span><br><span class="line">    - 函数调用完成之后会返回结果</span><br><span class="line">    - 默认的函数如果没有返回值，那么返回<span class="keyword">None</span></span><br><span class="line">    - 函数返回值可以任意多个</span><br><span class="line">    - 只要是合理的数据，**模块**，对象，函数名均可以返回</span><br></pre></td></tr></table></figure><h5 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a><strong>函数作用域</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment">#全局就是全局</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">2</span> <span class="comment">#局部就是局部</span></span><br><span class="line">        <span class="comment">#修改全局a变为2  错误</span></span><br><span class="line">        <span class="comment">#在局部空间创建一个新的同名a 正确</span></span><br><span class="line">    print(<span class="string">"内:"</span>,a)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">global</span> 把一个局部变量声明成全局的</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span> <span class="comment">#全局就是全局</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a <span class="comment">#升级局部变量成为全局的</span></span><br><span class="line">    a = <span class="number">2</span> <span class="comment">#局部就是局部</span></span><br><span class="line">        <span class="comment">#修改全局a变为2  正确</span></span><br><span class="line">        <span class="comment">#在局部空间创建一个新的同名a  错误的</span></span><br><span class="line">    print(<span class="string">"内:"</span>,a)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#局部作用域：函数内空间</span></span><br><span class="line"><span class="comment">#全局作用域：整个脚本空间</span></span><br><span class="line"></span><br><span class="line">- 形参都是局部的</span><br><span class="line">- 不可变数据对象，在函数内外的值，用到了引用计数</span><br><span class="line">- 全局变量可以被局部作用域使用</span><br><span class="line">- 但是局部变量不可以被全局作用域所使用，除非你用<span class="keyword">global</span>语句升级，声明为全局变量</span><br><span class="line">- 全局可变对象,在函数内部使用的时,其实是一个共享状态</span><br><span class="line">- 是因为列表的指针域 是一个 也会存在引用计数的情况</span><br><span class="line">- 解决办法就是在函数内部使用深浅拷贝</span><br><span class="line"><span class="comment">#内外其实现在共同使用同一个列表</span></span><br><span class="line"><span class="comment">#内外互相影响，用的就是同一个列表</span></span><br><span class="line"><span class="comment">#这样的数据可以在函数之间进行通信</span></span><br><span class="line">可变数据在传递参数时</span><br><span class="line">    - 在函数内部直接通过形参修改,也会影响原有数据</span><br><span class="line">    - 可变对象在传递参数时,只是一个引用</span><br><span class="line">不可变数据在传递参数时</span><br><span class="line">- 在函数内部直接通过形参修改,不会影响原有数据</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+= 或者 = 号赋值都会使一个不可变数据类型在函数的局部作用域下成为一个局部变量</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">a = a + <span class="number">1</span></span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个作用域下的a都是来自于同一个作用域的</span></span><br><span class="line"><span class="comment">#你不能说 第一个a是局部的、第二个a是全局的</span></span><br><span class="line">    <span class="comment">#这样的话，一个a在一个内存空间下可以表示两个值了，这就二义性了</span></span><br><span class="line"><span class="comment"># 现在的a 就是一个局部变量了</span></span><br><span class="line"><span class="comment"># 局部变量a 需要 局部变量a + 1</span></span><br><span class="line"><span class="comment"># 这个代码会报错</span></span><br><span class="line"><span class="comment"># local variable 'a' referenced before assignment</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    mylist[<span class="number">0</span>] = <span class="string">'a'</span></span><br><span class="line">    print(<span class="string">'内:'</span>,mylist)</span><br><span class="line">    <span class="comment">#内外其实现在共同使用同一个列表</span></span><br><span class="line">    <span class="comment">#内外互相影响，用的就是同一个列表</span></span><br><span class="line">    <span class="comment">#这样的数据可以在函数之间进行通信</span></span><br><span class="line">func()</span><br><span class="line">print(<span class="string">'外:'</span>,mylist)</span><br><span class="line"></span><br><span class="line"><span class="comment">#==================</span></span><br><span class="line"></span><br><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] <span class="comment">#全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    new_list = mylist.copy() <span class="comment">#浅拷贝之后，互不影响</span></span><br><span class="line">    new_list[<span class="number">0</span>] = <span class="string">'a'</span> <span class="comment">#局部变量</span></span><br><span class="line">    print(<span class="string">'内:'</span>,new_list)</span><br><span class="line">func()</span><br><span class="line">print(<span class="string">'外:'</span>,mylist)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mydict = &#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'Small White'</span>,</span><br><span class="line">    <span class="string">'money'</span>:<span class="number">500</span></span><br><span class="line">&#125; <span class="comment">#字典是一个可变的 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(key,value)</span>:</span></span><br><span class="line">    mydict[key] += value</span><br><span class="line">move_dict = &#123;</span><br><span class="line">    <span class="string">'中彩'</span>: [func,<span class="number">20</span>],</span><br><span class="line">    <span class="string">'生病'</span>: [func,<span class="number">-20</span>],</span><br><span class="line">    <span class="comment">#字典的value要给定一个实际的值</span></span><br><span class="line">&#125;</span><br><span class="line">move = <span class="string">'中彩'</span></span><br><span class="line">move_dict[move][<span class="number">0</span>](<span class="string">'money'</span>,move_dict[move][<span class="number">1</span>])</span><br><span class="line"><span class="comment">#move_dict[move][0] 取到函数</span></span><br><span class="line"><span class="comment">#move_dict[move][1] 取到应该修改的值</span></span><br><span class="line">print(mydict)</span><br></pre></td></tr></table></figure><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><strong>匿名函数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">lambda</span> 表达式</span><br><span class="line">- 除了def语句,我们还可以通过lambda语句来创建函数</span><br><span class="line">- <span class="keyword">lambda</span>创建的函数 因为默认不具有名字，他需要我们来指定一个变量名来保存</span><br><span class="line">- 表达式的结果，将作为返回值自动返回</span><br><span class="line">- 轻量级的函数 一般使用<span class="keyword">lambda</span>来实现</span><br><span class="line">a = <span class="keyword">lambda</span> x: x*<span class="number">2</span></span><br><span class="line">a(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#lamdba 参数 : 表达式</span></span><br><span class="line"></span><br><span class="line">mylist = [<span class="keyword">lambda</span> x,y:x**y,<span class="keyword">lambda</span> x,y:x**(y+<span class="number">1</span>),<span class="keyword">lambda</span> x,y:x**(y+<span class="number">2</span>)] <span class="comment">#跳转表</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">5</span>): <span class="comment">#取出来0-4的数据</span></span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> mylist:</span><br><span class="line">        res = func(var,<span class="number">2</span>)</span><br><span class="line">        print(res)</span><br><span class="line">   print(<span class="string">'-------------'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算器</span></span><br><span class="line">oper_func_dict = &#123;</span><br><span class="line">    <span class="string">'+'</span>:<span class="keyword">lambda</span> x,y : x + y <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> x - y,</span><br><span class="line">    <span class="string">'-'</span>:<span class="keyword">lambda</span> x,y : x-y,</span><br><span class="line">    <span class="string">'*'</span>:<span class="keyword">lambda</span> x,y : x*y,</span><br><span class="line">    <span class="string">'/'</span>:<span class="keyword">lambda</span> x,y : x/y,</span><br><span class="line">&#125;</span><br><span class="line">res = oper_func_dict[<span class="string">'+'</span>](x=<span class="number">0</span>,y=<span class="number">1</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h5 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a><strong>三元表达式</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x + <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> x - <span class="number">1</span></span><br><span class="line"><span class="comment">#当条件满足时(x &gt; 0) 执行表达式左边的,反之执行表达式右边的</span></span><br></pre></td></tr></table></figure><h5 id="跳转表：包含函数的字典或者列表"><a href="#跳转表：包含函数的字典或者列表" class="headerlink" title="跳转表：包含函数的字典或者列表"></a>跳转表：包含函数的字典或者列表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mylist = [<span class="keyword">lambda</span> x,y:x**y,<span class="keyword">lambda</span> x,y:x**(y+<span class="number">1</span>),<span class="keyword">lambda</span> x,y:x**(y+<span class="number">2</span>)]</span><br><span class="line"><span class="comment">#列表中的每一数据都是一个函数</span></span><br><span class="line"><span class="comment">#求出0-4数据的每一个2，3，4次方的结果</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">5</span>): <span class="comment">#取出来0-4的数据</span></span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> mylist:</span><br><span class="line">        <span class="comment">#func = lambda x:x**2</span></span><br><span class="line">        <span class="comment">#func = lambda x:x**3</span></span><br><span class="line">        <span class="comment">#func = lambda x:x**4</span></span><br><span class="line">        res = func(var,<span class="number">2</span>)</span><br><span class="line">        print(res)</span><br><span class="line">    <span class="comment">#外层for循环取出每一个值</span></span><br><span class="line">        <span class="comment">#传递到内存循环中执行三次，分别求出2，3，4的方结果</span></span><br><span class="line">    print(<span class="string">'-------------'</span>)</span><br><span class="line"><span class="comment">#跳转表：包含函数的字典或者列表</span></span><br></pre></td></tr></table></figure><h5 id="作业：模拟人生"><a href="#作业：模拟人生" class="headerlink" title="作业：模拟人生"></a><strong>作业：模拟人生</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">move_dict = &#123;</span><br><span class="line">    <span class="string">'w'</span>: <span class="keyword">lambda</span> y: y + <span class="number">1</span>,</span><br><span class="line">    <span class="string">'s'</span>: <span class="keyword">lambda</span> y: y - <span class="number">1</span>,</span><br><span class="line">    <span class="string">'a'</span>: <span class="keyword">lambda</span> x: x - <span class="number">1</span>,</span><br><span class="line">    <span class="string">'d'</span>: <span class="keyword">lambda</span> x: x + <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">y = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    move = input(<span class="string">'你要怎么移动:'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'w'</span> == move <span class="keyword">or</span> <span class="string">'s'</span> == move:</span><br><span class="line">        y = move_dict[move](y.</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'a'</span> == move <span class="keyword">or</span> <span class="string">'d'</span> == move:</span><br><span class="line">        x = move_dict[move](x)</span><br><span class="line">    print(<span class="string">'你当前的位置:%s:%s'</span> % (x,y))</span><br></pre></td></tr></table></figure><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 当函数自身包含了对自身的调用，那么就是递归</span><br><span class="line">- 递归有最大上限次数:<span class="number">1000</span>次左右</span><br><span class="line">- 递归每一次都在开启一个新的函数空间</span><br><span class="line">- 递归会非常占用内存</span><br><span class="line">- 递归一定要确定终止条件</span><br><span class="line">普通循环 <span class="keyword">for</span> <span class="keyword">while</span> 一般适用于解决线性循环</span><br><span class="line">递归的优势在与解决非线性的</span><br></pre></td></tr></table></figure><h5 id="递归求和作业练习："><a href="#递归求和作业练习：" class="headerlink" title="递归求和作业练习："></a><strong>递归求和作业练习：</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>],<span class="number">5</span>,[<span class="number">6</span>,[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],<span class="number">1</span>,<span class="number">2</span>] <span class="comment">#-&gt; 44</span></span><br><span class="line"><span class="comment">#试一下用循环求和，</span></span><br><span class="line"><span class="comment">#如果列表变化，那么代码可以兼容，可以直接复用，不能改变</span></span><br><span class="line">mysum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sum</span><span class="params">(iter)</span>:</span><span class="comment">#接收一个等待求和的多层序列</span></span><br><span class="line">    <span class="comment">#iter 中 无非两种数据类型: list int</span></span><br><span class="line">    <span class="keyword">global</span> mysum</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> iter:</span><br><span class="line">        <span class="keyword">if</span> type(var) == int: <span class="comment">#当前取出来的数据是int</span></span><br><span class="line">        <span class="comment">#if type(var) == type([])</span></span><br><span class="line">            mysum += var</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            get_sum(var) <span class="comment">#遇到的又是一个列表，那么我们继续遍历</span></span><br><span class="line">    <span class="comment">#for循环结束的时候，递归结束</span></span><br><span class="line">get_sum(mylist)</span><br><span class="line">print(mysum)</span><br></pre></td></tr></table></figure><p>递归统计每一个出现的字符出现的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="string">'asdazxc'</span>,<span class="string">'adxzc'</span>,[<span class="string">'12390145fcsdjfhzkjxcmnasd'</span>,<span class="string">'123987189asjkdsajkb'</span>],<span class="string">'asdqwewqerq'</span>,[<span class="string">'asd890q8390'</span>],<span class="string">'asdhquiweqysa'</span>,<span class="string">'asdhjkzhxjkckjasdh'</span>]</span><br><span class="line"><span class="comment">#把一样的提出来</span></span><br><span class="line"><span class="comment">#统计每一个出现的字符出现的次数</span></span><br><span class="line"><span class="comment">#for循环实现</span></span><br><span class="line">dict_num = &#123;&#125;</span><br><span class="line"><span class="comment">#key:对应的字符</span></span><br><span class="line"><span class="comment">#value:出现的次数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="comment">#字典是可变数据类型，所以直接可以在函数作用域内进行修改</span></span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> seq: <span class="comment">#遍历整个列表数据</span></span><br><span class="line">        <span class="keyword">if</span> type(var) == list:</span><br><span class="line">            <span class="comment">#如果取出来的还是一个列表，那么就继续递归</span></span><br><span class="line">            get_num(var)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#如果碰到的是一个字符串</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> var:  <span class="comment">#遍历字符串，记录次数</span></span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> dict_num:</span><br><span class="line">                    <span class="comment"># 如果获取到的字符，已经存在了字典中，那么他的次数+1</span></span><br><span class="line">                    dict_num[i] = dict_num[i] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果获取到的字符没出现过，那么就创建默认值1就行</span></span><br><span class="line">                    dict_num[i] = <span class="number">1</span></span><br><span class="line">get_num(mylist)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict_num:</span><br><span class="line">    print(key,<span class="string">':'</span>,dict_num[key])</span><br></pre></td></tr></table></figure><h5 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a><strong>回文判断</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#问题：使用递归 判断一个字符串是否是回文:</span></span><br><span class="line"></span><br><span class="line">mystr = input(<span class="string">"请输入一个你觉得是回文的字符串我来帮你判断:"</span>)</span><br><span class="line"><span class="keyword">if</span> mystr == mystr[::<span class="number">-1</span>]:</span><br><span class="line">    print(<span class="string">'这就是回文'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'这不是回文'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_h</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(obj) &lt; <span class="number">2</span>: <span class="comment">#'a'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="comment">#返回 结束</span></span><br><span class="line">    <span class="keyword">elif</span> obj[<span class="number">0</span>] != obj[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment">#如果判断对应索引位置的值不一样，那么就返回False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="comment"># 现在我判断完了0和-1位置，是不是就可以不要他们了</span></span><br><span class="line">    <span class="keyword">return</span> p_h(obj[<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">print(p_h(mystr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#奇数一定有1，偶数一定没有</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_h_2</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="comment">#7 - 1 / 2 = 3</span></span><br><span class="line">    <span class="comment">#7 / 2 - 1  /  2</span></span><br><span class="line">    <span class="comment">#结果少了小数点后的</span></span><br><span class="line">    index = len(obj) // <span class="number">2</span> <span class="comment">#取出中间索引位置</span></span><br><span class="line">    <span class="comment">#取出下一半字符串</span></span><br><span class="line">    b = obj[index:] <span class="keyword">if</span> <span class="keyword">not</span> (len(obj) &amp; <span class="number">1</span>) <span class="keyword">else</span> obj[index+<span class="number">1</span>:]</span><br><span class="line">        <span class="comment">#判断是否是奇或 偶数位</span></span><br><span class="line">        <span class="comment">#三元表达式 当 if条件成立，那么返回左边的，反之返回右边的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> obj[:index] == b[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">print(p_h_2(mystr))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#回文判断</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_h_2</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="comment">#7 - 1 / 2 = 3</span></span><br><span class="line">    <span class="comment">#7 / 2 - 1  /  2   #结果少了小数点后的</span></span><br><span class="line">    index = len(obj) // <span class="number">2</span> <span class="comment">#取出中间索引位置</span></span><br><span class="line">    <span class="comment">#取出下一半字符串</span></span><br><span class="line">    b = obj[index:] <span class="keyword">if</span> <span class="keyword">not</span> (len(obj) &amp; <span class="number">1</span>) <span class="keyword">else</span> obj[index+<span class="number">1</span>:]</span><br><span class="line">        <span class="comment">#判断是否是奇或 偶数位</span></span><br><span class="line">        <span class="comment">#三元表达式 当 if条件成立，那么返回左边的，反之返回右边的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> obj[:index] == b[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">print(p_h_2(mystr))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归回文判断</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_h</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(obj) &lt; <span class="number">2</span>: <span class="comment">#'a'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="comment">#返回 结束</span></span><br><span class="line">    <span class="keyword">elif</span> obj[<span class="number">0</span>] != obj[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment">#如果判断对应索引位置的值不一样，那么就返回False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="comment"># 现在我判断完了0和-1位置，是不是就可以不要他们了</span></span><br><span class="line">    <span class="keyword">return</span> p_h(obj[<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">print(p_h(mystr))</span><br></pre></td></tr></table></figure><h5 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a><strong>os模块</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">- os模块支持以下平台，他会根据平台来对应处理你调用的函数</span><br><span class="line">  - posix：类Unix操作 安卓 Centos ubuntu Debian</span><br><span class="line">  - nt：Win</span><br><span class="line">  - mac：MacOS</span><br><span class="line">    - <span class="number">4</span>月<span class="number">28</span>号早上<span class="number">8</span>点多的时候我的mac丢了</span><br><span class="line">  - dos：DOS</span><br><span class="line">    - dos必须关机 开机的阶段才能看到</span><br><span class="line">  - U盘安装dos操作系统</span><br><span class="line">- os.name</span><br><span class="line">  输出当前os模块在哪个平台下</span><br><span class="line">- os.getcwd() -&gt; str</span><br><span class="line">  - 获取当前的程序工作目录</span><br><span class="line">  - 工作目录：是我们程序在运行期间的时候，如果你需要和当前运行环境(操作系统)进行交互，相对路径互相参照，工作目录可以在程序运行期间修改</span><br><span class="line">  - 运行目录：维护当前程序是从哪个路径下被执行的</span><br><span class="line">- os.listdir(path=os.getcwd()) -&gt; list</span><br><span class="line">  - 返回指定path目录下的所有文件及文件夹的列表</span><br><span class="line">  - 当你不传递一个路径的时候，默认的会返回当前的工作目录下的内容</span><br><span class="line">  - 该函数返回的结果，不会明确什么是文件，什么是文件夹</span><br><span class="line">  - 返回的结果是一个字符串列表，并且每一个路径都是相对路径的</span><br><span class="line">  - 该函数也会将隐藏文件展示</span><br><span class="line">- os.remove(file_path) <span class="comment">#rm </span></span><br><span class="line">  - 删除file_path所指定的一个文件</span><br><span class="line">  - 如果成功返回<span class="keyword">None</span>，失败了直接报错</span><br><span class="line">  - 删除的时候一定要指明文件的后缀</span><br><span class="line">        IsADirectoryError: [Errno <span class="number">21</span>] Is a directory: <span class="string">'test'</span></span><br><span class="line">        删除了一个文件夹</span><br><span class="line">        FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'tesasdjklajdkt'</span></span><br><span class="line">        删除了一个不存在的文件</span><br><span class="line">- os.rmdir(dir_path) <span class="comment"># rm -rf</span></span><br><span class="line">  - 删除dir_path指定的一个文件夹(目录)</span><br><span class="line">  - 如果成功返回<span class="keyword">None</span>，失败了直接报错</span><br><span class="line">  - 无法递归删除文件夹，如果文件夹不为空，那么删除不了</span><br><span class="line">- os.makedirs(<span class="string">'a/b/c'</span>)</span><br><span class="line">  - 递归创建目录</span><br><span class="line">  - 可以嵌套创建目录</span><br><span class="line">  - 成功返回<span class="keyword">None</span>，失败则报错</span><br><span class="line">- os.mkdir(<span class="string">'a'</span>)</span><br><span class="line">  - 创建目录</span><br><span class="line">  - 不能在linux下创建一个和文件名重名的文件夹</span><br><span class="line">  - 虽然类型不同，但是名字也不能是相同的</span><br><span class="line">  - 成功返回<span class="keyword">None</span>，失败则报错</span><br><span class="line">- os.chdir() </span><br><span class="line">  - 在程序运行期间可以通过该函数来改变工作目录</span><br><span class="line">  - os.listdir() 这个函数可以不传递参数执行，返回当前工作目录下的所有文件及文件夹的列表</span><br><span class="line"></span><br><span class="line">os模块下还有一个子模块叫os.path</span><br><span class="line"></span><br><span class="line">os.path可以处理和路径及文件类型有关的问题</span><br><span class="line"></span><br><span class="line">- os.path.isfile(path)  -&gt; Bool</span><br><span class="line">  - 判断路径是否是一个真正的文件 </span><br><span class="line">- os.path.isdir(path)  -&gt; Bool</span><br><span class="line">  - 判断路径是否是一个真正的目录</span><br><span class="line">- os.path.join(<span class="string">'path'</span>,<span class="string">'sub_path'</span>)</span><br><span class="line">  - 拼接path和sub_path</span><br><span class="line">  - 可以构成绝对路径</span><br><span class="line">  - 路径中重复的部分不会被去掉</span><br><span class="line">      &gt;&gt;&gt; os.path.join(<span class="string">'home'</span>,<span class="string">'home/CODE'</span>)</span><br><span class="line">      <span class="string">'home/home/CODE'</span></span><br><span class="line">- os.path.exists(path)</span><br><span class="line">  - 判断路径是否存在</span><br><span class="line">  - 如果存在返回<span class="keyword">True</span>，反之返回<span class="keyword">False</span></span><br><span class="line">- os.path.getsize(path)</span><br><span class="line">  - 返回路径对应的文件大小</span><br><span class="line">  - 返回的文件大小单位为Byte</span><br></pre></td></tr></table></figure><h5 id="os语音控制你的电脑"><a href="#os语音控制你的电脑" class="headerlink" title="os语音控制你的电脑"></a>os<strong>语音控制你的电脑</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">pip install PyAudio 是可以控制你的音频设备 录音还有播放</span></span><br><span class="line"><span class="string">pip install pyttsx3 是可以让你的电脑播放音频</span></span><br><span class="line"><span class="string">pip install requests 可以访问百度语音接口</span></span><br><span class="line"><span class="string">然后安装好pywin32软件即可</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1.你先向电脑传输音频</span></span><br><span class="line"><span class="string">2.解析音频 转换成字符串</span></span><br><span class="line"><span class="string">requests</span></span><br><span class="line"><span class="string">百度云接口</span></span><br><span class="line"><span class="string">3.说话后的字符串再分析</span></span><br><span class="line"><span class="string">4.os.system(处理分析后的字符串)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> pyttsx3 <span class="comment">#播放</span></span><br><span class="line"><span class="keyword">import</span> pyaudio <span class="comment">#录音</span></span><br><span class="line"><span class="keyword">import</span> time <span class="comment">#获取时间</span></span><br><span class="line"><span class="keyword">import</span> json <span class="comment">#用来分析json字符串</span></span><br><span class="line"><span class="keyword">import</span> requests <span class="comment">#访问链接</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen,Request <span class="comment">#访问连接</span></span><br><span class="line"><span class="keyword">import</span> base64 <span class="comment">#b64编码</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(data)</span>:</span></span><br><span class="line">eg = pyttsx3.init()</span><br><span class="line">eg.say(data)</span><br><span class="line">eg.runAndWait()</span><br><span class="line"></span><br><span class="line"><span class="comment">#向电脑说话</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_audio</span><span class="params">()</span>:</span></span><br><span class="line">pa = pyaudio.PyAudio() <span class="comment">#初始化音频设备</span></span><br><span class="line">audio_equip = pa.open(</span><br><span class="line">format=pyaudio.paInt16,<span class="comment">#存储位深</span></span><br><span class="line">channels=<span class="number">1</span>,<span class="comment">#声道</span></span><br><span class="line">rate=<span class="number">16000</span>,<span class="comment">#采样率</span></span><br><span class="line">input=<span class="keyword">True</span>,<span class="comment">#输入</span></span><br><span class="line">frames_per_buffer=<span class="number">1024</span>,<span class="comment">#获取的数据大小</span></span><br><span class="line">)</span><br><span class="line">times = <span class="number">0</span></span><br><span class="line">data = []</span><br><span class="line">print(<span class="string">'[+] 请说话...'</span>)</span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">while</span> times &lt; <span class="number">45</span>: <span class="comment">#控制到了说话时间为3秒</span></span><br><span class="line">audio_data = audio_equip.read(<span class="number">1024</span>) <span class="comment">#从设备中读取音频</span></span><br><span class="line">data.append(audio_data) <span class="comment">#吧每一次read读取到的音频 追加到我的data列表中</span></span><br><span class="line">times += <span class="number">1</span></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">'[+] 你说话耗时:%.2f'</span> % (end-start))</span><br><span class="line"></span><br><span class="line">audio_equip.close() <span class="comment">#关闭设备</span></span><br><span class="line">res = <span class="string">b''</span>.join(data) <span class="comment">#把列表中的所有数据拼接成整体</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">()</span>:</span></span><br><span class="line">url = <span class="string">'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s'</span></span><br><span class="line">client_id = <span class="string">'npFlwGurf1tMvMS8myW6W9AA'</span></span><br><span class="line">client_secret = <span class="string">'TZcTamTfVlYWilclkLbatZe18e8xYzIY'</span></span><br><span class="line">host = url % (client_id,client_secret)</span><br><span class="line">res = urlopen(host).read().decode() <span class="comment">#urlopen函数打开链接提交参数，获取Toekn</span></span><br><span class="line"><span class="comment">#但是这里获取到的是一个json的并且是编码过后的数据</span></span><br><span class="line">token = json.loads(res)[<span class="string">'access_token'</span>]</span><br><span class="line"><span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment">#百度音频解析 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bd_analysis</span><span class="params">()</span>:</span></span><br><span class="line">token = get_token()</span><br><span class="line">audio_data = get_audio()</span><br><span class="line">audio_data_len = len(audio_data)</span><br><span class="line">audio_data = base64.b64encode(audio_data).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment">#百度云在接收音频的时候，需要传递两个值</span></span><br><span class="line"><span class="comment">#第一个是音频的实际数据，用base64编码</span></span><br><span class="line"><span class="comment">#第二个是音频的长度, 一定是未编码之前的</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'format'</span>:<span class="string">'wav'</span>,</span><br><span class="line"><span class="string">'rate'</span>:<span class="number">16000</span>,</span><br><span class="line"><span class="string">'channel'</span>:<span class="number">1</span>,</span><br><span class="line"><span class="string">'cuid'</span>: <span class="string">'1804shuaideyipi'</span>,</span><br><span class="line"><span class="string">'dev_pid'</span>:<span class="number">1536</span>,</span><br><span class="line"><span class="string">'token'</span>:token,</span><br><span class="line"><span class="string">'speech'</span>:audio_data,</span><br><span class="line"><span class="string">'len'</span>:audio_data_len,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = json.dumps(data).encode() <span class="comment">#处理成json格式并且编码</span></span><br><span class="line">host = <span class="string">'http://vop.baidu.com/server_api'</span> <span class="comment">#把所有的东西都给到百度</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>, <span class="comment">#指明你提交的数据类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req = Request(url=host,headers=headers,data=data)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">res = json.loads(urlopen(req).read().decode())[<span class="string">'result'</span>][<span class="number">0</span>].replace(<span class="string">'，'</span>,<span class="string">''</span>)</span><br><span class="line"><span class="keyword">except</span> :</span><br><span class="line">res = <span class="string">'语音质量有问题,请重新喊话!'</span></span><br><span class="line">talk(<span class="string">'语音质量有问题,请重新喊话!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'[+] 你说话的内容:'</span>,res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="string">'yes'</span> <span class="keyword">in</span> bd_analysis():</span><br><span class="line">talk(<span class="string">'请告诉我，我要做什么！'</span>)</span><br><span class="line">res = bd_analysis()</span><br><span class="line"><span class="keyword">if</span> <span class="string">'计算器'</span> <span class="keyword">in</span> res:</span><br><span class="line">os.system(<span class="string">'calc'</span>)</span><br><span class="line">talk(<span class="string">'爷，你的计算器打开了'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="string">'取消关机'</span> <span class="keyword">in</span> res:</span><br><span class="line">os.system(<span class="string">'shutdown -a'</span>)</span><br><span class="line">talk(<span class="string">'已经取消关机了'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="string">'关机'</span> <span class="keyword">in</span> res:</span><br><span class="line">os.system(<span class="string">'shutdown -s -t 1000'</span>)</span><br><span class="line">talk(<span class="string">'OK给你关机!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">所有的文件都是在磁盘上的！</span><br><span class="line">CPU只能处理在内存中的数据，也就是说，CPU无法直接去阅读磁盘里的文件</span><br><span class="line">CPU &lt;-&gt; MEM &lt;-&gt; DISK</span><br><span class="line">- 文件操作，在程序里都是对内存中的文件进行操作！</span><br><span class="line">第一步：打开文件  fp = open(path, mode=<span class="string">'r'</span>) </span><br><span class="line">open函数返回的是一个文件的句柄，不是完全的文件展开体，只是一个可以导出整个文件的头指针</span><br><span class="line">第二步：读   </span><br><span class="line">fp.read(num)</span><br><span class="line">    函数直接阅读整个文件，并返回整个文件为一个字符串</span><br><span class="line">        把整个文件读到了内存</span><br><span class="line">        如果给read函数传递了num变量</span><br><span class="line">        那么他是通过num来读取对应文件中的指定字符个数</span><br><span class="line">        read函数获取到的文件内容会保留行末尾的\n\r</span><br><span class="line">    fp.readline()</span><br><span class="line">    readline函数一次可以读取文件中的一行内容</span><br><span class="line">        当遇到了\n\r则停止，代表当前是一行了</span><br><span class="line">        当遇到了EOF（文件结束标志）</span><br><span class="line">        readline如果去读取超过文件本身行数的次数，那么不会报错，只会返回空</span><br><span class="line">        readline不会一次性把整个文件展开在内存</span><br><span class="line">        但是需要我们手动的维护行数</span><br><span class="line">        readline函数在获取到文件内容的每一行后，也会保留结尾的\r\n</span><br><span class="line">fp.readlines()</span><br><span class="line">    返回了字符串列表</span><br><span class="line">        列表中每一个元素都是一行的数据</span><br><span class="line">        并且保留行末尾的换行符号</span><br><span class="line">第三步：关闭文件</span><br><span class="line">fp.close()</span><br><span class="line">fp.tell()  获取文件指针位置   </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'1.txt'</span>) <span class="keyword">as</span> fp  这里的<span class="keyword">with</span> <span class="keyword">as</span> 语句可以自动做资源创建和释放</span><br><span class="line">文件权限：</span><br><span class="line">w:权限可以让我们打开一个文件，进行写入，但是每一次打开都会将之前的文件内容清空</span><br><span class="line">       write函数在写入文件内容的时候，不会自动的带换行\r\n</span><br><span class="line">    a：append 追加，读写指针在文件末尾</span><br></pre></td></tr></table></figure><h5 id="缓冲和缓存"><a href="#缓冲和缓存" class="headerlink" title="缓冲和缓存"></a><strong>缓冲和缓存</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">缓冲区( 内存(临时) )  针对读写文件 </span><br><span class="line">- 缓冲区让效率慢的和效率快的组件之间可以协同工作，缓和速度之间的矛盾，不频繁的写入磁盘，可以保护设备。因为磁盘的寿命是由写次数决定的。</span><br><span class="line">    - 当你关闭文件的时候，缓冲区中的内容会刷新到磁盘上</span><br><span class="line">    - 手动刷新缓冲区：fp.flush()</span><br><span class="line">    </span><br><span class="line">- 磁盘是保存数据的</span><br><span class="line">- 内存是流通数据的</span><br><span class="line">- CPU才是真正计算数据的</span><br><span class="line">- CPU处理内存中的数据，而内存中的数据来自于磁盘</span><br><span class="line"></span><br><span class="line">缓存：为了提高数据流通速度</span><br><span class="line">缓存是在CPU里有</span><br><span class="line">缓存是一块超级告诉的数据流通空间（类似内存），但是太贵了，所以电脑上缓存空间一般不大</span><br><span class="line">L1：CPU经常从L1中拿取数据、控制线程和进程</span><br><span class="line">L2：存储数据</span><br><span class="line">L3：管控内存</span><br></pre></td></tr></table></figure><h5 id="读写指针修改"><a href="#读写指针修改" class="headerlink" title="读写指针修改"></a><strong>读写指针修改</strong></h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fp.seek(offset,when)</span><br><span class="line">offset：偏移量</span><br><span class="line">字节为单位</span><br><span class="line">when: 从哪里开始移动</span><br><span class="line"><span class="number">0</span>:文件开头</span><br><span class="line"><span class="number">1</span>:当前位置</span><br><span class="line"><span class="number">2</span>:文件末尾</span><br><span class="line">a模式下的文件末尾读写指针如何移动到文件头部呢？</span><br><span class="line">fp.seek(<span class="number">0</span>,<span class="number">0</span>) -&gt; 回到了文件开头</span><br><span class="line">fp.tell()  获取文件指针，返回的也是以一个字节为单位</span><br><span class="line"></span><br><span class="line">不同权限下读写指针位置：</span><br><span class="line">- r: 文件开头</span><br><span class="line">- w: 文件开头</span><br><span class="line">- a: 文件末尾</span><br></pre></td></tr></table></figure><h5 id="csv文件操作"><a href="#csv文件操作" class="headerlink" title="csv文件操作"></a><strong>csv</strong>文件操作</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- CSV文件是一个用于电子表格存储类型</span><br><span class="line">- csv文件是存储了以逗号分隔的数据</span><br><span class="line"></span><br><span class="line">csv文件默认写入的时候 会在每两行之间多一个空行</span><br><span class="line">解决办法：</span><br><span class="line">在打开文件的时候</span><br><span class="line">fp = open(<span class="string">'1.csv'</span>,<span class="string">'w'</span>,newline=<span class="string">''</span>)</span><br><span class="line"><span class="comment">#newline参数用来控制 每一次写入csv文件数据的时候，一行行之间是否需要空行</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: 处理普通文本对象为csv文本对象</span><br><span class="line">打开文件：</span><br><span class="line">fp = open(path,mode)</span><br><span class="line">加工：</span><br><span class="line">csv_read_fp = csv.reader(fp)  负责读取</span><br><span class="line">csv_write_fp = csv.writer(fp) 负责写入</span><br><span class="line"><span class="number">2</span>: 对csv_read_fp进行<span class="keyword">for</span>循环迭代，就可以一行行的访问csv表格中的内容</span><br><span class="line"><span class="keyword">for</span> var1,var2 <span class="keyword">in</span> csv_read_fp:</span><br><span class="line">print(var1,var2)</span><br><span class="line"><span class="number">3</span>: 对csv_write_fp文件写入内容，写入的是一些逗号分隔开的数据</span><br><span class="line">csv_write_fp.wirterow([seq])</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字典读取csv时：</span><br><span class="line">dict_read_csv = csv.DictReader(fp)</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> dict_read_csv:</span><br><span class="line">print(var[<span class="string">'name'</span>],var[<span class="string">'sex'</span>])</span><br><span class="line">csv文件中第一行是key值，下面的数据是value</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">字典写一个csv文件</span><br><span class="line">dict_write_csv = csv.DictWriter(fp,fileds)</span><br><span class="line">fp: </span><br><span class="line">打开的文件对象，需要加工成csv字典处理文件对象</span><br><span class="line">fileds： 标题行 第一行</span><br><span class="line">fileds 也是一个逗号分隔的数据 比如: fileds = [<span class="string">'name'</span>,<span class="string">'age'</span>,<span class="string">'sex'</span>]</span><br><span class="line"></span><br><span class="line">dict_write_csv.writeheader() <span class="comment">#将指定的标题行先写入到csv文件里</span></span><br><span class="line">dict_write_csv.writerow(&#123;<span class="string">'name'</span>:<span class="string">'BOB'</span>,<span class="string">'age'</span>:<span class="string">'16'</span>,<span class="string">'sex'</span>:<span class="string">'man'</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">fp = open(<span class="string">'test1.csv'</span>,<span class="string">'w'</span>,newline=<span class="string">''</span>)</span><br><span class="line">fileds = [<span class="string">'name'</span>,<span class="string">'age'</span>,<span class="string">'sex'</span>]  <span class="comment">#标题行</span></span><br><span class="line">name = [<span class="string">'Bob'</span>,<span class="string">'Jack'</span>,<span class="string">'Lucy'</span>]</span><br><span class="line">age = [<span class="number">10</span>,<span class="number">16</span>,<span class="number">18</span>]</span><br><span class="line">sex = [<span class="string">'man'</span>,<span class="string">'man'</span>,<span class="string">'woman'</span>]</span><br><span class="line">human_list = []</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment">#0-2 </span></span><br><span class="line"><span class="comment">#外层循环用来控制生产三个数据</span></span><br><span class="line">human_dict = &#123;&#125;</span><br><span class="line">human_dict[fileds[<span class="number">0</span>]] = name[index] <span class="comment">#name</span></span><br><span class="line">human_dict[fileds[<span class="number">1</span>]] = age[index] <span class="comment">#name</span></span><br><span class="line">human_dict[fileds[<span class="number">2</span>]] = sex[index] <span class="comment">#name</span></span><br><span class="line">human_list.append(human_dict)</span><br><span class="line"><span class="comment">#BOB = &#123;'name':'BOB','age':'16','sex':'man'&#125;</span></span><br><span class="line">dict_write_csv = csv.DictWriter(fp,fileds) <span class="comment">#加工文件对象，指明标题行</span></span><br><span class="line">print(help(csv.DictWriter)) <span class="comment">#写入标题行</span></span><br><span class="line"><span class="comment">#******************************</span></span><br><span class="line">dict_write_csv.writeheader() <span class="comment">#用来在csv文件中写入标题行</span></span><br><span class="line"><span class="comment">#******************************</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> human_list: <span class="comment">#遍历用户字典，分别写入csv文件中</span></span><br><span class="line">dict_write_csv.writerow(var)</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h5 id=&quot;函数参数&quot;&gt;&lt;a href=&quot;#函数参数&quot; class=&quot;headerlink&quot; title=&quot;函数参数&quot;&gt;&lt;/a&gt;&lt;strong&gt;函数参
      
    
    </summary>
    
      <category term="python" scheme="http://www.python100.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>函数进阶</title>
    <link href="http://www.python100.com/2018/07/26/%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
    <id>http://www.python100.com/2018/07/26/第三阶段函数进阶/</id>
    <published>2018-07-26T01:44:00.000Z</published>
    <updated>2018-07-31T15:51:42.402Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">实现闭包步骤：</span><br><span class="line">- <span class="number">1</span>: 你要先来一个函数嵌套</span><br><span class="line">  - 外函数里包装一个内函数</span><br><span class="line">- <span class="number">2</span>: 外函数作用域有一个局部数据对象</span><br><span class="line">- <span class="number">3</span>: 内部函数对于外部函数作用域里非全局变量的引用</span><br><span class="line">- <span class="number">4</span>: 外函数返回内部函数</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">()</span>:</span></span><br><span class="line">        a = <span class="number">1</span> <span class="comment">#a是属于wai函数作用域里的</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">()</span>:</span> <span class="comment">#nei函数就是一个载体了</span></span><br><span class="line">            print(a)</span><br><span class="line">        <span class="keyword">return</span> nei <span class="comment">#返回的是一个函数对象</span></span><br><span class="line">    func = wai() <span class="comment">#func -&gt; None</span></span><br><span class="line">    <span class="comment">#func == nei</span></span><br><span class="line">    func() <span class="comment"># a</span></span><br><span class="line">    <span class="comment">#返回的nei函数可以在wai函数执行完成之后，继续不报错执行</span></span><br><span class="line">    <span class="comment">#证明了在nei函数，也就是此时的func中，保留一个a变量。</span></span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>: 闭包内部创建载体，可以使一个局部变量续命</span><br><span class="line"><span class="number">2</span>:变量私有化：</span><br><span class="line">每一次闭包函数执行后的返回值都是一个新的，这是因为函数运行首先开辟的都   是一块新的函数临时空间</span><br><span class="line">每一次闭包函数执行后，都是返回了一个不一样的闭包函数载体，</span><br><span class="line">那么这个载体里的变量，也是不一样的</span><br><span class="line"><span class="number">3</span>: 变量状态维持：</span><br><span class="line">闭包函数载体(返回值)，只要存活着，那么它其中的变量也将会一直维护</span><br><span class="line"><span class="number">4</span>: 闭包会一直保存变量，所以呢，本该死去的局部变量现在无法及时得到释放,</span><br><span class="line">    消耗内存</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">1</span> <span class="comment">#局部变量 只能存活在函数运行期间</span></span><br><span class="line">    <span class="comment">#mylist[0] += 1 #在函数内部引用全局可变变量，那么其实你们都是全局的</span></span><br><span class="line">    mylist = [<span class="string">'a'</span>,<span class="string">'b'</span>] <span class="comment">#局部变量</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">func   <span class="comment">#函数对象 函数名</span></span><br><span class="line">func() <span class="comment">#函数调用</span></span><br><span class="line">print(mylist)</span><br><span class="line"></span><br><span class="line"><span class="comment">#让一个局部变量存活下来:</span></span><br><span class="line">    <span class="comment">#1: 返回值</span></span><br><span class="line">    <span class="comment">#2: global</span></span><br><span class="line">    <span class="comment">#3: 列表保存数据 全局共享同一个(只在函数内部做修改) 可变数据的引用</span></span><br><span class="line">    <span class="comment">#4: 闭包也可以给一个局部变量续命</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于可变数据对象：</span></span><br><span class="line">    <span class="comment">#赋值：我为自己创建了一个新得 找了新欢</span></span><br><span class="line">        <span class="comment">#直接创建了一个新的 ： 局部变量</span></span><br><span class="line">    <span class="comment">#修改：影响咱俩共有的女朋友</span></span><br><span class="line">        <span class="comment">#全局被局部所使用 ： 全局</span></span><br></pre></td></tr></table></figure><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a><strong>装饰器</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器可以在函数运行前添加功能，并且不影响原有函数内容</span></span><br><span class="line"></span><br><span class="line">函数三要素</span><br><span class="line">def func(arg): <span class="comment">#定义</span></span><br><span class="line">var = arg ** <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> var</span><br><span class="line">函数名: func</span><br><span class="line">函数参数(形参)：arg</span><br><span class="line">函数返回值: arg</span><br><span class="line">默认的，如果没有函数内的<span class="keyword">return</span>语句，函数默认返回None</span><br><span class="line"></span><br><span class="line">res = func(<span class="number">10</span>) <span class="comment">#执行</span></span><br><span class="line">函数名：func</span><br><span class="line">返回值：res</span><br><span class="line">参数(实参)：<span class="number">10</span></span><br><span class="line"></span><br><span class="line">- func：函数对象</span><br><span class="line">- func() ：函数调用</span><br></pre></td></tr></table></figure><h3 id="普通装饰器"><a href="#普通装饰器" class="headerlink" title="普通装饰器"></a><strong>普通装饰器</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">(b_func)</span>:</span> <span class="comment">#外函数的参数是一个函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"嘿嘿嘿"</span>) <span class="comment">#在nei函数里写的代码基本上都是添加的功能</span></span><br><span class="line">        <span class="keyword">return</span> b_func() <span class="comment">#这个是nei函数返回值，用来返回之前在wai函数所接收的参数</span></span><br><span class="line">        <span class="comment">#b_func()</span></span><br><span class="line">        <span class="comment">#return ''</span></span><br><span class="line">    <span class="keyword">return</span> nei <span class="comment">#返回了wai函数里的这个定义好的闭包容器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@wai #语法糖</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'哈哈哈哈'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'func'</span></span><br><span class="line"></span><br><span class="line">res = func() <span class="comment">#调用一个被装饰函数 其实相等于 wai(func)()</span></span><br><span class="line">print(<span class="string">'func的返回值:'</span>,res)</span><br><span class="line"><span class="comment">#func() 传统函数调用</span></span><br><span class="line">    <span class="comment">#1: print('哈哈哈')</span></span><br><span class="line">    <span class="comment">#2: return None</span></span><br><span class="line"><span class="comment">#func() 被装饰时调用 @wai</span></span><br><span class="line">    <span class="comment">#被装饰函数: func</span></span><br><span class="line">    <span class="comment">#装饰器函数: wai</span></span><br><span class="line">    <span class="comment">#1: wai(func) -&gt; return nei</span></span><br><span class="line">    <span class="comment">#2: nei() -&gt;</span></span><br><span class="line">        <span class="comment">#1: print("嘿嘿嘿")</span></span><br><span class="line">        <span class="comment">#2: return b_func()</span></span><br><span class="line">            <span class="comment">#1: b_func() -&gt; 'func'  #内部调用被装饰函数</span></span><br><span class="line">            <span class="comment">#2: return 'func' #内部闭包函数的返回值 其实是被装饰函数的返回值</span></span><br></pre></td></tr></table></figure><h3 id="被装饰函数带参数"><a href="#被装饰函数带参数" class="headerlink" title="被装饰函数带参数"></a><strong>被装饰函数带参数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">(func)</span>:</span> <span class="comment">#装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">(var1,var2)</span>:</span></span><br><span class="line">        var1 = <span class="number">100</span>  <span class="comment">#在闭包函数内部对被装饰函数参数进行干预</span></span><br><span class="line">        var2 = <span class="number">99</span></span><br><span class="line">        <span class="keyword">return</span> func(var1,var2)</span><br><span class="line">    <span class="keyword">return</span> nei</span><br><span class="line"></span><br><span class="line"><span class="meta">@wai</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">res = work(<span class="number">20</span>,<span class="number">30</span>)  <span class="comment">#wai(work)(a,b)</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h3 id="装饰器函数也可以有参数"><a href="#装饰器函数也可以有参数" class="headerlink" title="装饰器函数也可以有参数"></a><strong>装饰器函数也可以有参数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#商品</span></span><br><span class="line">mind = <span class="keyword">True</span></span><br><span class="line">zhekou = <span class="number">0.9</span> <span class="comment">#折扣的数值</span></span><br><span class="line">youhuiquan = <span class="number">5</span></span><br><span class="line"><span class="comment"># 当你的装饰器函数也需要参数的时候，只需要多一层包装即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dazhe</span><span class="params">(con,zk,yhq)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">(money)</span>:</span></span><br><span class="line">            print(<span class="string">'-----------'</span>)</span><br><span class="line">            <span class="keyword">if</span> con:</span><br><span class="line">                print(<span class="string">'打折!'</span>)</span><br><span class="line">                money = money * zk</span><br><span class="line">            <span class="keyword">elif</span> yhq:</span><br><span class="line">                print(<span class="string">"优惠券！"</span>)</span><br><span class="line">                money = money - yhq</span><br><span class="line">            <span class="keyword">return</span> func(money)</span><br><span class="line">        <span class="keyword">return</span> nei</span><br><span class="line">    <span class="keyword">return</span> wai</span><br><span class="line"><span class="comment">#dazhe -&gt; wai</span></span><br><span class="line"><span class="comment">#wai -&gt; nei</span></span><br><span class="line"><span class="comment">#nei -&gt; func()</span></span><br><span class="line"><span class="meta">@dazhe(mind,zhekou,youhuiquan)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apple</span><span class="params">(money)</span>:</span></span><br><span class="line">    print(<span class="string">'苹果的价钱是:%d'</span> % money)</span><br><span class="line">    <span class="keyword">return</span> money</span><br><span class="line"></span><br><span class="line"><span class="meta">@dazhe(mind,zhekou,youhuiquan)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pants</span><span class="params">(money)</span>:</span></span><br><span class="line">    print(<span class="string">'裤子的价钱是:%d'</span> % money)</span><br><span class="line">    <span class="keyword">return</span> money</span><br><span class="line"></span><br><span class="line"><span class="meta">@dazhe(mind,zhekou,youhuiquan)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skirt</span><span class="params">(money)</span>:</span></span><br><span class="line">    print(<span class="string">'裙子的价钱是:%d'</span> % money)</span><br><span class="line">    <span class="keyword">return</span> money</span><br><span class="line"></span><br><span class="line">apple(<span class="number">10</span>)</span><br><span class="line">pants(<span class="number">50</span>)</span><br><span class="line">skirt(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">(b_func)</span>:</span> <span class="comment">#外函数的参数是一个函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"嘿嘿嘿"</span>) <span class="comment">#在nei函数里写的代码基本上都是添加的功能</span></span><br><span class="line">        <span class="keyword">return</span> b_func() <span class="comment">#这个是nei函数返回值，用来返回之前在wai函数所接收的参数</span></span><br><span class="line">        <span class="comment">#b_func()</span></span><br><span class="line">        <span class="comment">#return ''</span></span><br><span class="line">    <span class="keyword">return</span> nei <span class="comment">#返回了wai函数里的这个定义好的闭包容器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@wai #语法糖</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'哈哈哈哈'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'func'</span></span><br><span class="line"></span><br><span class="line">res = func() <span class="comment">#调用一个被装饰函数 其实相等于 wai(func)()</span></span><br><span class="line">print(<span class="string">'func的返回值:'</span>,res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#func() 传统函数调用</span></span><br><span class="line">    <span class="comment">#1: print('哈哈哈')</span></span><br><span class="line">    <span class="comment">#2: return None</span></span><br><span class="line"><span class="comment">#func() 被装饰时调用 @wai</span></span><br><span class="line">    <span class="comment">#被装饰函数: func</span></span><br><span class="line">    <span class="comment">#装饰器函数: wai</span></span><br><span class="line">    <span class="comment">#1: wai(func) -&gt; return nei</span></span><br><span class="line">    <span class="comment">#2: nei() -&gt;</span></span><br><span class="line">        <span class="comment">#1: print("嘿嘿嘿")</span></span><br><span class="line">        <span class="comment">#2: return b_func()</span></span><br><span class="line">            <span class="comment">#1: b_func() -&gt; 'func'  #内部调用被装饰函数</span></span><br><span class="line">            <span class="comment">#2: return 'func' #内部闭包函数的返回值 其实是被装饰函数的返回值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'穿裙子'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'穿大衣'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'穿牛仔'</span>)</span><br><span class="line">func_dict = &#123;</span><br><span class="line">    <span class="string">'裙子'</span>:func_1,</span><br><span class="line">    <span class="string">'大衣'</span>:func_2,</span><br><span class="line">    <span class="string">'牛仔'</span>:func_3,</span><br><span class="line">&#125;</span><br><span class="line">choice = random.choice(list(func_dict.keys()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_wai</span><span class="params">(choice)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">()</span>:</span></span><br><span class="line">            func_dict[choice]()</span><br><span class="line">            <span class="keyword">return</span> func()</span><br><span class="line">        <span class="keyword">return</span> nei</span><br><span class="line">    <span class="keyword">return</span> wai</span><br><span class="line"></span><br><span class="line"><span class="meta">@_wai(choice)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">girl</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'上班了！'</span>)</span><br><span class="line"></span><br><span class="line">girl() <span class="comment">#装饰这个函数</span></span><br></pre></td></tr></table></figure><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a><strong>异常捕获</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">常见错误：</span><br><span class="line">IndentationError: unexpected indent缩进错误</span><br><span class="line">ZeroDivisionError: division by zero除数为<span class="number">0</span></span><br><span class="line">NameError: name <span class="string">'b'</span> is not defined访问未声明变量</span><br><span class="line">IndexError: list index out of range访问越界(超过了原有数据的长度)变量</span><br><span class="line">KeyError: <span class="number">2</span>访问字典中(JSON类似)不存在key值</span><br><span class="line">AttributeError: module <span class="string">'socket'</span> has no attribute <span class="string">'create'</span></span><br><span class="line">访问一个对象(变量，函数，类，模块)不存在的属性</span><br><span class="line"></span><br><span class="line">异常捕获的作用：</span><br><span class="line">- 异常捕获可以提高代码的健壮性</span><br><span class="line">- 让我们的代码在不同情况下，可以让程序继续向下，而不是直接中断</span><br><span class="line">- 有一些异常错误，需要额外导入模块才可以使用，切记。</span><br><span class="line"></span><br><span class="line">异常的类型：</span><br><span class="line">SystemExit(系统中断异常)</span><br><span class="line">KeyboardInterrupt(ctrl+c)</span><br><span class="line">Exception(内建异常类) </span><br><span class="line">Python中的异常都是继承自这个Exception而来的</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'打开文件'</span>)  <span class="comment">#捕获异常</span></span><br><span class="line">    fp = open(<span class="string">'1.txt'</span>)</span><br><span class="line">except FileNotFoundError :</span><br><span class="line">    print(<span class="string">'这个文件不存在'</span>)   <span class="comment">#捕获到异常后要做的事情</span></span><br><span class="line">except Exception as e:</span><br><span class="line"><span class="comment">#捕获所有错误，一般不用</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment">#不管错误是否发生，都执行这里的代码，比如关闭文件</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"关闭文件"</span>)</span><br><span class="line">    fp.close()</span><br><span class="line"><span class="comment">#else 分支可以在没有异常出现的时候 执行</span></span><br></pre></td></tr></table></figure><h3 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a><strong>手动抛出异常</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#手动抛出异常，就是直接raiseraise MyError('你能不能好好传参')</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">'我心情不好，我就是要报错'</span>)</span><br><span class="line">    <span class="comment">#raise语句去将一个合法的异常</span></span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    print(<span class="string">'这是我刚才自己要抛出来的异常，现在我要捕获他'</span>)</span><br><span class="line">print(<span class="string">"哈哈哈哈哈哈"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name,age)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> type(name) == str <span class="keyword">and</span> type(age) == int:</span><br><span class="line">        print(<span class="string">'%s:%d'</span> % (name,age,abc))  <span class="comment">#定义了传入参数的类型，类型不对就报错</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'你能不能好好传参'</span>)</span><br><span class="line">    <span class="comment">#%d只能接受数字</span></span><br><span class="line">name = <span class="string">'小明'</span></span><br><span class="line">age = <span class="string">'18'</span></span><br><span class="line">func(name,age)</span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span> <span class="comment">#面向对象的继承方法</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment">#什么都不干，过！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#继承已又的异常基类，从这个基础来创建自己的异常</span></span><br><span class="line"><span class="comment"># 现在已经创建出来了一个自己的错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name,age)</span>:</span></span><br><span class="line">    <span class="comment">#name str</span></span><br><span class="line">    <span class="comment">#age int</span></span><br><span class="line">    <span class="keyword">if</span> type(name) == str <span class="keyword">and</span> type(age) == int:</span><br><span class="line">        print(<span class="string">'%s:%d'</span> % (name,age,abc))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> MyError(<span class="string">'你能不能好好传参'</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="string">'小明'</span></span><br><span class="line">age = <span class="string">'18'</span></span><br><span class="line">func(name,age)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="comment">#2,3版本是两个Python</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line">    <span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> urlopen,URLError</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.asdaskljdklasjdsajdlk.com'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    res = urlopen(url)</span><br><span class="line">    print(res.read())</span><br><span class="line"><span class="keyword">except</span> URLError:</span><br><span class="line">    print(<span class="string">'[+] 链接异常，无法访问'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">human = &#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'小明'</span>,</span><br><span class="line">    <span class="string">'company'</span>:<span class="string">'小红'</span>,</span><br><span class="line">    <span class="comment">#'gays':'小暗'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'%s的老婆是%s'</span> % (human[<span class="string">'name'</span>],human[<span class="string">'company'</span>],human[<span class="string">'gays'</span>]))</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'company'</span> <span class="keyword">in</span> str(e):</span><br><span class="line">        print(<span class="string">'他没老婆'</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'gays'</span> <span class="keyword">in</span> str(e):</span><br><span class="line">        print(<span class="string">'他没老公'</span>)</span><br></pre></td></tr></table></figure><h3 id="时间模块time"><a href="#时间模块time" class="headerlink" title="时间模块time"></a><strong>时间模块time</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">- time.time()  -&gt; float_time</span><br><span class="line">  - linux时间：从<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日， <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">  - 获取从Unix时间到现在经过的秒数 -&gt; 浮点数</span><br><span class="line">- time.localtime(float_time)  -&gt; 时间元组</span><br><span class="line">  - 如果不传递参数，那么默认返回本地时间的一个时间元组</span><br><span class="line">    </span><br><span class="line">res = time.localtime() -&gt; 时间结果是具备时区的</span><br><span class="line">time.struct_time(</span><br><span class="line">    tm_year=<span class="number">2018</span>,  年</span><br><span class="line">    tm_mon=<span class="number">6</span>,  月</span><br><span class="line">    tm_mday=<span class="number">9</span>,  日</span><br><span class="line">    tm_hour=<span class="number">10</span>,  时</span><br><span class="line">    tm_min=<span class="number">17</span>,  分</span><br><span class="line">    tm_sec=<span class="number">9</span>,  秒</span><br><span class="line">    tm_wday=<span class="number">5</span>,  星期几  星期一数字是<span class="number">0</span> 从<span class="number">0</span>开始 表示星期几</span><br><span class="line">    tm_yday=<span class="number">160</span>,  今年第几天</span><br><span class="line">    tm_isdst=<span class="number">0</span>  夏令时</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">res.tm_year</span><br><span class="line">res.tm_mon</span><br><span class="line">通过返回值的内置属性来获取到对应的值</span><br><span class="line"></span><br><span class="line">time.sleep(seconds)  --&gt; 程序休眠，让程序挂起</span><br><span class="line">time.clock()  ---&gt;   一般衡量程序的耗时</span><br><span class="line">- win：</span><br><span class="line">          - 第一次调用：返回当前的CPU时间</span><br><span class="line">          - 第二次调用：返回距离上一次调用所花费的时间</span><br><span class="line">    - linux：</span><br><span class="line">         - 直接返回程序运行到执行这个函数所花费的时间</span><br><span class="line">time.asctime(时间元组)</span><br><span class="line">time.strftime(格式，时间元组)  -&gt; 良好可读性的字符串</span><br><span class="line">将时间元组根据你指定的格式来成为一个良好可读性的字符串</span><br><span class="line">time.strptime(良好可读性的字符串，格式) -&gt; 时间元组</span><br><span class="line">把一个字符串变成时间元组。</span><br><span class="line"></span><br><span class="line">%Y: 年份 Year</span><br><span class="line">%m: 月份 month</span><br><span class="line">%d: 天数 day</span><br><span class="line"><span class="comment">#年月日，时分秒中，只有月和天是小写的，其他都是大写的</span></span><br><span class="line">%H：时 Hour</span><br><span class="line">%M：分 Minute</span><br><span class="line">%S：秒 Seconds</span><br><span class="line"><span class="comment">#以上六个死记硬背</span></span><br><span class="line"><span class="string">'%Y-%m-%d %H:%M:%S'</span></span><br><span class="line"></span><br><span class="line">%x 月/日/年</span><br><span class="line">%A: 星期的全称英语</span><br><span class="line">%a：星期的缩写英语</span><br><span class="line"></span><br><span class="line">%F 年/月/日</span><br><span class="line">%T 时/分/秒</span><br><span class="line"></span><br><span class="line">- strf  将时间元组变成字符串</span><br><span class="line">- strp 将字符串变成时间元组</span><br><span class="line">- 时间元组用来被处理，时间字符串只是一个展示的</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.time()</span><br><span class="line"><span class="number">1530412385.3557775</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.localtime()</span><br><span class="line">time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">1</span>, tm_hour=<span class="number">10</span>, tm_min=<span class="number">33</span>, tm_sec=<span class="number">14</span>, tm_wday=<span class="number">6</span>, tm_yday=<span class="number">182</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.asctime(time.localtime())</span><br><span class="line"><span class="string">'Sun Jul  1 10:33:39 2018'</span></span><br></pre></td></tr></table></figure><h3 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a><strong>datetime模块</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">datetime.datetime</span><br><span class="line">    - 处理年月日，时分秒的</span><br><span class="line">    - datetime.datetime.now()</span><br><span class="line">    - datetime.datetime.today()</span><br><span class="line">      - 获取当前的时间</span><br><span class="line">      - 返回值：datetime.datetime类型</span><br><span class="line">      - 返回值类型支持差值运算，用来求出两个时间区间的秒数，或者说你指定的时间单位</span><br><span class="line"></span><br><span class="line">datetime.date</span><br><span class="line">    - 处理年月日</span><br><span class="line">    - datetime.date.today()</span><br><span class="line">      - 年月日返回当前时间</span><br><span class="line">datetime.time</span><br><span class="line">    - 只能处理时分秒</span><br><span class="line">    - 多用来创建时分秒的时间</span><br><span class="line">    </span><br><span class="line">创建时间</span><br><span class="line">    datetime.datetime(<span class="number">2018</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">59</span>) 创建年月日，时分秒</span><br><span class="line">    datetime.date(<span class="number">2018</span>,<span class="number">6</span>,<span class="number">6</span>) 创建年月日</span><br><span class="line">    datetime.time(<span class="number">10</span>,<span class="number">50</span>,<span class="number">59</span>) 创建时分秒</span><br><span class="line">    </span><br><span class="line"><span class="comment">#我想求出再过20天是啥时候</span></span><br><span class="line">&gt;&gt;&gt; de = datetime.timedelta(days=<span class="number">25</span>)</span><br><span class="line">&gt;&gt;&gt; now = datetime.datetime.now()</span><br><span class="line">&gt;&gt;&gt; now + de </span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">286059</span>)</span><br><span class="line"><span class="comment">#结果中，会自动把天数，月数向上换算</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now()</span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">36</span>, <span class="number">190926</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>de=datetime.timedelta(days=<span class="number">20</span>)  <span class="comment">#求20天后日期时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now=datetime.datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now+de</span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">31</span>, <span class="number">53</span>, <span class="number">726784</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>de=datetime.timedelta(days=<span class="number">-20</span>)  <span class="comment">#使用-20求的是20天之前的日期时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now+de</span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">31</span>, <span class="number">53</span>, <span class="number">726784</span>)</span><br></pre></td></tr></table></figure><h3 id="随机模块random"><a href="#随机模块random" class="headerlink" title="随机模块random"></a><strong>随机模块random</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- random.randrange(stop)</span><br><span class="line">  - 生产出从<span class="number">0</span>到stop区间内的一个随机整数</span><br><span class="line">  - 不包含stop</span><br><span class="line">- random.randrange(start,stop,step)  </span><br><span class="line">  - 生产出从<span class="number">0</span>到stop区间内以步长为step的一个随机整数</span><br><span class="line">  - 不包含stop</span><br><span class="line">- random.randint(start,stop)</span><br><span class="line">  - 返回start和stop区间内的一个随机整数</span><br><span class="line">  - 起点和终点都可能被取到</span><br><span class="line">- random.getrandbits(num)</span><br><span class="line">  - 传入一个num值，<span class="number">0</span>-<span class="number">2</span>**num次方，去一个随机的整数</span><br><span class="line">  - 如果传递的num是<span class="number">1</span>，<span class="number">0</span> - <span class="number">2</span> ** <span class="number">1</span>  <span class="number">0</span> -<span class="number">2</span></span><br><span class="line">  - 不能取到终点：如果你传递的是<span class="number">2</span>**<span class="number">3</span>,那么取不到<span class="number">8</span></span><br><span class="line">- 随机浮点数</span><br><span class="line">- random.random()  -&gt;   &lt;<span class="number">1</span></span><br><span class="line">  - 返回介于<span class="number">0</span>到<span class="number">1</span>之间的浮点数</span><br><span class="line">- random.uniform(start,stop)</span><br><span class="line">  - 取出一个从start开始到stop结束的一个随机浮点数</span><br><span class="line">  - 这里start也可能出现</span><br><span class="line">  - stop的值是不取的</span><br><span class="line">- 随机序列</span><br><span class="line">- random.choice(seq) </span><br><span class="line">  - 从一个非空序列中随机选择一个元素</span><br><span class="line">  - 序列为空则报错</span><br><span class="line">  - 序列：字符串，列表，元组 支持索引操作的数据</span><br><span class="line">- random.shuffle(seq)</span><br><span class="line">  - 打乱序列的顺序</span><br><span class="line">- random.sample(seq,num)</span><br><span class="line">  - num是我要从seq中随机抽取数据的长度，num 一定要小于 len(seq)</span><br><span class="line">  - 从seq中 随机抽取num个数据 返回成一个列表</span><br><span class="line">  - num代表取几个</span><br></pre></td></tr></table></figure><h3 id="SYS模块"><a href="#SYS模块" class="headerlink" title="SYS模块"></a><strong>SYS模块</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sys.argv:</span><br><span class="line">获取当前程序的命令行参数</span><br><span class="line">命令行参数 就是你在执行.py脚本时传递的</span><br><span class="line">参数的列表</span><br><span class="line">sys.argv[<span class="number">0</span>]: 当前程序的名字</span><br><span class="line">sys.platform</span><br><span class="line">  - 用来输出当前的环境平台</span><br><span class="line">  - os.name</span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line">  直接退出程序</span><br><span class="line">sys.path</span><br><span class="line">  - 环境变量列表</span><br><span class="line">IO流处理：</span><br><span class="line">i: <span class="keyword">in</span> 进去</span><br><span class="line">- 键盘向程序输入内容</span><br><span class="line">- 写文件</span><br><span class="line">- 接受其他服务器反馈</span><br><span class="line">o: out 出来</span><br><span class="line">- print向屏幕打印</span><br><span class="line">- 读文件</span><br><span class="line">- 向其他服务器发送请求</span><br><span class="line">IO是影响程序性能,print操作是IO操作，那么尽量少在代码里print</span><br><span class="line"></span><br><span class="line">sys.stdin </span><br><span class="line">    - 标准输入   input</span><br><span class="line">    sys.stdin.readline()[:-<span class="number">1</span>] == input()</span><br><span class="line">sys.stdout</span><br><span class="line">- 标准输出 print</span><br><span class="line">sys.stdout.write(<span class="string">'abc\n'</span>) == print(<span class="string">'abc'</span>)</span><br><span class="line">sys.stderr</span><br><span class="line">- 标准出错</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;&lt;strong&gt;闭包&lt;/stron
      
    
    </summary>
    
      <category term="python" scheme="http://www.python100.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>python基础数据类型</title>
    <link href="http://www.python100.com/2018/07/26/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E8%83%8C%E8%AF%B5/"/>
    <id>http://www.python100.com/2018/07/26/第一阶段背诵/</id>
    <published>2018-07-26T01:44:00.000Z</published>
    <updated>2018-07-31T15:51:57.633Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><p><strong>数据类型：数字，字符串，列表，元组，集合，字典</strong></p><h5 id="数字"><a href="#数字" class="headerlink" title="数字"></a><strong>数字</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">整数：int</span><br><span class="line">浮点数：float</span><br><span class="line">布尔值：大小写敏感  非空非零为真，<span class="number">0</span>或空为假</span><br><span class="line">复数：以J或j结尾，</span><br><span class="line"></span><br><span class="line">type(判断谁)</span><br><span class="line">查看类型</span><br></pre></td></tr></table></figure><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">字符串里面的东西是无意义的</span><br><span class="line">索引：从左到右，从<span class="number">0</span>开始，从右到左，从<span class="number">-1</span>开始</span><br><span class="line">切片：左闭右开</span><br><span class="line">    a[start:stop(不取):step]</span><br><span class="line">    step 步长  start起点 stop终点(不取)</span><br><span class="line">同符号情况下，如果步长是负数，那么应该从大到小</span><br><span class="line">start &gt; stop</span><br><span class="line">如果步长是个正的，那么从小大到</span><br><span class="line">start &gt; stop</span><br><span class="line">字符串是一个不可变数据类型</span><br><span class="line">一般对于不可变数据的函数处理，操作只会返回一个新的值，不会影响自己本身</span><br><span class="line">字符串支持 加法和乘法  分别是拼接和多次输出</span><br></pre></td></tr></table></figure><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">列表(list)</span><br><span class="line">语法:  a = [1,2,3,4,5]</span><br><span class="line">支持索引和切片</span><br><span class="line">一个列表里可以存储任意的数据类型</span><br><span class="line">可以创建一个空列表</span><br><span class="line">列表可变，可以通过索引访问修改</span><br><span class="line">通过切片重新赋值</span><br><span class="line">切片修改的时候，只要给的值和坑对应了就行</span><br><span class="line">列表的范围赋值：</span><br><span class="line">切片赋值：</span><br><span class="line">步长绝对值为1时，取一个数据集合的每一个值，放置到这个之前的位置</span><br><span class="line">步长绝对值大于1时，一个萝卜一个坑，要一一对应</span><br><span class="line">切片的步长包含起点</span><br></pre></td></tr></table></figure><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a><strong>元组</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">元组(tuple) </span><br><span class="line">()</span><br><span class="line">不可变</span><br><span class="line">创建一个只含有一个数据的元组</span><br><span class="line">a = (&apos;a&apos;,)</span><br><span class="line">只含有单个数据的元组，要加逗号</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">字符串、列表、元组  都是有顺序的一个数据集，也就是有序的序列</span><br><span class="line">序列就是有顺序的数据集。字符串 列表 元组都是序列。</span><br><span class="line">可变数据：  列表 （可变而的是列表中的数据，而不是这个对象）</span><br><span class="line">不可变数据：  数、字符串、元组</span><br><span class="line">可变不可变性质:不可变的是类型其中的数据</span><br><span class="line">不可变数据对象，不可变的是指向关系，不是这个变量名</span><br><span class="line">不可变的变量，变量在变的时候，重新给了新的指向关系，原来的不可变指向关系被抛弃了！</span><br><span class="line">可变的变量，直接就能变指向关系</span><br><span class="line"></span><br><span class="line">iterable</span><br><span class="line">可迭代的对象</span><br><span class="line">含有数据是一个集合</span><br><span class="line">数据前后可以互相找到</span><br><span class="line">有序的序列就是可迭代的对象，如字符串，列表和元组。</span><br></pre></td></tr></table></figure><h5 id="序列"><a href="#序列" class="headerlink" title="序列"></a><strong>序列</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">序列包含：字符串，元组，列表</span><br><span class="line">序列支持索引和切片</span><br><span class="line">序列是可迭代的对象</span><br></pre></td></tr></table></figure><h5 id="变量的本质"><a href="#变量的本质" class="headerlink" title="变量的本质"></a><strong>变量的本质</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">变量本质：</span><br><span class="line">变量不需要先定义(不需要声明大小类型)，可以直接使用，直接赋值a = <span class="number">1</span></span><br><span class="line">变量可以重复赋值，哪怕更换类型</span><br><span class="line">同时可以给多个变量赋值</span><br><span class="line">命名风格，不要和模块名，常用函数 <span class="keyword">print</span>，不能用数字开头，字母，数字，下划线，在python3，中文也可以做变量名</span><br><span class="line">__num__ 特殊的python内置变量</span><br><span class="line">不支持自增和自减</span><br><span class="line">引用计数： 就是针对一些不可变数据</span><br><span class="line">    变量的内存分配方式</span><br><span class="line">变量在创建的时候，首先不会直接开辟空间，会先去查找，已有的空间</span><br><span class="line">如果有这个数据了，那么他不会创建新的，而是利用已有的</span><br><span class="line"><span class="keyword">del</span>语句可以删除一个变量名，但是不会释放变量数据占据的空间</span><br><span class="line"><span class="keyword">del</span>语句还把引用计数减<span class="number">1</span>了，数据的空间只有在引用计数真正为<span class="number">0</span>的时候才会释放</span><br><span class="line">python中的del语句释放数据内存? x</span><br><span class="line">查看变量的内存地址：id(变量名)</span><br><span class="line"><span class="keyword">import</span> sys sys.getrefcount()  查看变量的引用计数</span><br><span class="line">注意：</span><br><span class="line">python解释器有没有在用</span><br><span class="line">赋值语句是否是单独创建，还是借用别人</span><br></pre></td></tr></table></figure><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a><strong>引用计数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">引用计数：</span><br><span class="line">常见变量会使用引用计数的方式分配内存，</span><br><span class="line">一个变量创建的时候，不会去直接创建一个新的地址，先去查找已有的(不可变数据：元组，字符串，整数)</span><br><span class="line"><span class="keyword">del</span> 引用计数减一</span><br><span class="line">当一个对象真正最后引用计数为<span class="number">0</span>的时候，才会被释放，延迟性</span><br><span class="line"><span class="keyword">del</span>切断了变量名和具体数据的内存地址的连接，该变量所使用的数据的引用计数减去<span class="number">1</span></span><br><span class="line">使用引用计数的原因：定义变量开辟空间，变量多，占用多，值相同的内存空间，相互共享，而不用创建</span><br></pre></td></tr></table></figure><h5 id="运算表达式"><a href="#运算表达式" class="headerlink" title="运算表达式"></a><strong>运算表达式</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">算数表达式:</span><br><span class="line">+ - * /   //  %  ** </span><br><span class="line">逻辑表达式 返回值类型是Bool</span><br><span class="line">a = <span class="number">1</span>非空非<span class="number">0</span>为真</span><br><span class="line">    b = <span class="number">0</span>  <span class="number">0</span>或空为假</span><br><span class="line">    <span class="keyword">not</span> a 逻辑非</span><br><span class="line">    a <span class="keyword">and</span> b  逻辑与</span><br><span class="line">    a <span class="keyword">or</span> b 逻辑或</span><br><span class="line">    a <span class="keyword">is</span> b  a和b是不是同一个对象</span><br><span class="line">    a <span class="keyword">is</span> <span class="keyword">not</span> b  a和b不是同一个对象</span><br><span class="line">    </span><br><span class="line"><span class="keyword">is</span>不光是判断值相同，还要判断是否是同一地址</span><br><span class="line">与：and -&gt; False 真真为真，真假为假，假假为假，只要有假则为假</span><br><span class="line">或：or -&gt; True真真为真，真假为真，假假为假，只要有真则为真</span><br><span class="line">关系表达式 如果不是数字来判断，那么判断的就是阿斯克码</span><br><span class="line">表达式          汉译              返回值类型</span><br><span class="line">    a==b         a,b是否值相等            bool</span><br><span class="line">    a!=b         a,b是否值不相等          bool</span><br><span class="line">    a&lt;&gt;b         a,b是否值不相等          bool</span><br><span class="line">    a&gt;b          a是否大于b               bool</span><br><span class="line">    a&lt;b          a是否小于b               bool</span><br><span class="line">    a&gt;=b          a是否大于等于b          bool</span><br><span class="line">    a&lt;=b          a是否小于等于b          bool</span><br><span class="line">    </span><br><span class="line">    小写字母a的十进制 ascii：<span class="number">97</span></span><br><span class="line">    大写字母A的十进制 ascii：<span class="number">65</span></span><br><span class="line">位运算：</span><br><span class="line">表达式           汉译               操作解释</span><br><span class="line">    ~a               按位取反             -(a+<span class="number">1</span>)</span><br><span class="line">    a&lt;&lt;n             左移n位              -</span><br><span class="line">    a&gt;&gt;n             右移n位              -</span><br><span class="line">    a&amp;b              a和b按位与           11-&gt;1  00-&gt;0  01-&gt;0(都是1时才得1)</span><br><span class="line">    a|b              a和b按位或           01-&gt;1  11-&gt;1  00-&gt;0(只要有1就得1)</span><br><span class="line">    a^b              a和b按位异或         01-&gt;1  11-&gt;0  00-&gt;0(相同得0，不同得1)</span><br><span class="line"></span><br><span class="line">    计算机中存储的都是二进制</span><br><span class="line">所有的运算，到最后，都是二进制的补码在运算，补码才是真正在计算机里存储的，</span><br><span class="line">符号位参与运算，计算完成的结果也是补码</span><br><span class="line">    原码，反码，补码</span><br><span class="line">    正数的原码，反码，补码都是本身</span><br><span class="line">    负数：</span><br><span class="line">        原码：<span class="number">1000</span> <span class="number">0001</span> 最高位是符号位</span><br><span class="line">        反码：<span class="number">1111</span> <span class="number">1110</span> 符号位不变，其余各位取反</span><br><span class="line">        补码：<span class="number">1111</span> <span class="number">1111</span> <span class="number">-1</span> 补码是反码加一</span><br><span class="line">所有的运算都是 补码在做运算</span><br><span class="line">       <span class="number">1</span>              <span class="number">-1</span></span><br><span class="line">    原码  <span class="number">0000</span> <span class="number">0001</span>     <span class="number">1000</span> <span class="number">0001</span> </span><br><span class="line">    反码  <span class="number">0000</span> <span class="number">0001</span>     <span class="number">1111</span> <span class="number">1110</span>  负数的反码 符号为不变，其余各位取反</span><br><span class="line">    补码  <span class="number">0000</span> <span class="number">0001</span>     <span class="number">1111</span> <span class="number">1111</span>  反码+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    对补码在求一次补码即可求出原码</span><br><span class="line">    </span><br><span class="line">    a &gt;&gt; n 向右移动  位移的位置包含起点，其实就位移了一位。类似切片中的步长，步长计算也包含起点</span><br><span class="line">    ------------------------</span><br><span class="line">    a &amp; b  a和b按位与 ，位上的值，只要有<span class="number">0</span>，结果为<span class="number">0</span></span><br><span class="line">    a | b   a和b按位或，位上的值，只要有<span class="number">1</span>，结果为<span class="number">1</span></span><br><span class="line">    a ^ b  a和b按位异或，只要值不同，结果才为<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    所有的运算，都是补码在运算！！！</span><br></pre></td></tr></table></figure><h5 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a><strong>条件分支语句</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> …. <span class="keyword">else</span>… 语句中 如果有一个条件满足，其他不会执行</span><br><span class="line"><span class="keyword">else</span>条件也可以没有,<span class="keyword">elif</span>条件也可以没有</span><br><span class="line"><span class="keyword">elif</span> 可以 继续细分条件</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>条件语句返回值为<span class="keyword">True</span>时，执行语句才会被执行</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 访问可迭代的对象</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> 可迭代的对象(str,list,tuple):</span><br><span class="line">一次次的从里面取一个值</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">条件满足时，直接跳出循环</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">条件满足时，只是跳过本次循环</span><br><span class="line">循环搭配<span class="keyword">else</span>语句来使用，这里<span class="keyword">else</span>语句中的内容会在循环正常结束之后来执行</span><br><span class="line"></span><br><span class="line"><span class="comment">#for var in seq:</span></span><br><span class="line">    <span class="comment">#遍历一个序列(前后数据间有顺序关系)，然后去其中一次次的拿取值</span></span><br><span class="line">    <span class="comment">#for循环一般不用来实现死循环</span></span><br><span class="line">    <span class="comment">#for次数一般由我们的数据长度来决定</span></span><br><span class="line">    <span class="comment">#for循环每次会向后遍历</span></span><br><span class="line">    <span class="comment">#for循环的死循环 需要构建环形或者无限延申的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#from itertools import cycle</span></span><br><span class="line">    <span class="comment">#cycle([1,2,3]) -&gt; 圈</span></span><br></pre></td></tr></table></figure><h5 id="python3和python2区别"><a href="#python3和python2区别" class="headerlink" title="python3和python2区别"></a><strong>python3和python2区别</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">python3:</span><br><span class="line">print() %s接收到的可以是任意的数据类型</span><br><span class="line">%d 用来输出整数</span><br><span class="line">%f 用来输出浮点数，%.100f 控制输出的精度</span><br><span class="line">input()所有接收到的都是字符串</span><br><span class="line">range() 抽象,不会生成数据，只有在使用的时候才会生成数据</span><br><span class="line">python2:</span><br><span class="line">    print()</span><br><span class="line">    input()  有效的数据，代码输入进来也是有效的，缓冲区溢出攻击</span><br><span class="line">    raw_input() 所有接收到的都是字符串</span><br><span class="line">    range() 具象的，会立即创建出实际的数据，很耗费内存</span><br><span class="line">xrange() 抽象的，不会生成数据，只有在使用的时候才会生成数据</span><br></pre></td></tr></table></figure><h5 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a><strong>深浅拷贝</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">拷贝： 可变数据对象的指针被共享了(引用计数)，所以需要我们引入拷贝</span><br><span class="line">创建变量的时候，我们希望的只是值相等，而不是互相影响</span><br><span class="line">a[:] 这是返回了一个新的列表，只是值和原先的a是一样的</span><br><span class="line">浅拷贝的方法：</span><br><span class="line">切片拷贝，只能是复制浅层的数据对象，返回一个新的地址中的数据，内层的数据并没有实现拷贝</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">    b=a[:]</span><br><span class="line">    <span class="keyword">import</span> copy</span><br><span class="line">    b=copy.copy(a)</span><br><span class="line">深拷贝：</span><br><span class="line">深拷贝可以实现地址不同</span><br><span class="line">    深拷贝，拷贝的都是列表中的指向关系，对应列表中的数据还是使用引用计数的</span><br><span class="line">    <span class="keyword">import</span> copy</span><br><span class="line">    a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>]]</span><br><span class="line">    b = copy.deepcopy(a)</span><br></pre></td></tr></table></figure><h5 id="作业：使用切片实现深拷贝"><a href="#作业：使用切片实现深拷贝" class="headerlink" title="作业：使用切片实现深拷贝"></a><strong>作业：使用切片实现深拷贝</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>]]]</span><br><span class="line">b=a[:]</span><br><span class="line">b[<span class="number">-1</span>]=a[<span class="number">-1</span>][:]  <span class="comment">#[1,2,3,[1,2,[1,2],3]]</span></span><br><span class="line">b[<span class="number">-1</span>][<span class="number">-1</span>]=a[<span class="number">-1</span>][<span class="number">-1</span>][:]   <span class="comment">#[1,2,[1,2],3]</span></span><br><span class="line">b[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">2</span>]=a[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">2</span>][:]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"a:"</span>,a)</span><br><span class="line">print(<span class="string">"b:"</span>,b)</span><br><span class="line">print(<span class="string">"------------"</span>)</span><br><span class="line">b[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">2</span>][<span class="number">-1</span>]=<span class="string">'abc'</span></span><br><span class="line">print(<span class="string">"a:"</span>,a)</span><br><span class="line">print(<span class="string">"b:"</span>,b)</span><br></pre></td></tr></table></figure><h5 id="作业：求出mylist中每一个值"><a href="#作业：求出mylist中每一个值" class="headerlink" title="作业：求出mylist中每一个值"></a><strong>作业：求出mylist中每一个值</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,(<span class="string">'a'</span>,<span class="string">'b'</span>)],<span class="string">'c'</span>,<span class="string">'def'</span>]</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="keyword">if</span> type(var) == type([<span class="number">1</span>]):<span class="comment">#print('----',var)#当前满足列表</span></span><br><span class="line">        <span class="keyword">for</span> var1 <span class="keyword">in</span> var:</span><br><span class="line">            <span class="keyword">if</span> type(var1) == type((<span class="number">1</span>,)):<span class="comment">#var1此时是元组</span></span><br><span class="line">                <span class="keyword">for</span> var2 <span class="keyword">in</span> var1:</span><br><span class="line">                    print(var2)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(var1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(var)</span><br><span class="line">print(<span class="string">'---------------------'</span>)</span><br></pre></td></tr></table></figure><h5 id="作业：两数交换有几种办法"><a href="#作业：两数交换有几种办法" class="headerlink" title="作业：两数交换有几种办法"></a><strong>作业：两数交换有几种办法</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">两数交换有几种办法？分别列举</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line">最笨的方法：x=a a=b b=x</span><br><span class="line">方法一：a,b=b,a</span><br><span class="line">方法二：a=a+b  a=a-b b=a-b</span><br><span class="line">方法三：a=a*b  b=a/b a=a/b</span><br><span class="line">方法四：a=a|b  b=a^b a=a^b</span><br></pre></td></tr></table></figure><h5 id="作业：实现99乘法表"><a href="#作业：实现99乘法表" class="headerlink" title="作业：实现99乘法表"></a><strong>作业：实现99乘法表</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> i&gt;j:</span><br><span class="line">print(<span class="string">"%s x %s = %s   "</span>%(j,i,i*j),end=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print()</span><br><span class="line">j+=<span class="number">1</span></span><br><span class="line">i+=<span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="作业：机器学习代码"><a href="#作业：机器学习代码" class="headerlink" title="作业：机器学习代码"></a><strong>作业：机器学习代码</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">"data.pkl"</span>):</span><br><span class="line">f=open(<span class="string">"data.pkl"</span>,<span class="string">"rb"</span>)</span><br><span class="line">mydict=pickle.load(f)</span><br><span class="line"><span class="comment"># print("数据已存在！")</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">mydict=&#123;<span class="string">'hello'</span>:<span class="string">'hello'</span>&#125;</span><br><span class="line">f=open(<span class="string">"data.pkl"</span>,<span class="string">"wb"</span>)</span><br><span class="line">pickle.dump(mydict,f)</span><br><span class="line"><span class="comment"># print("新建数据库信息！")</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">ques=input(<span class="string">"请输入困扰你的问题： "</span>)</span><br><span class="line"><span class="keyword">if</span> ques != <span class="string">"quit"</span>:</span><br><span class="line"><span class="keyword">if</span> ques <span class="keyword">in</span> mydict:</span><br><span class="line">print(mydict[ques])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">ans=input(<span class="string">"你教教俺吧。。。"</span>)</span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">mydict[ques]=ans</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">f=open(<span class="string">"data.pkl"</span>,<span class="string">"wb"</span>)</span><br><span class="line">pickle.dump(mydict,f)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h5 id="作业：实现计算器"><a href="#作业：实现计算器" class="headerlink" title="作业：实现计算器"></a><strong>作业：实现计算器</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">cm = input(<span class="string">"请输入你要计算的表达式:"</span>)</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> cm:</span><br><span class="line">    <span class="keyword">if</span> var <span class="keyword">in</span> &#123;<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>&#125;:</span><br><span class="line">        l_num,r_num = float(cm[:index]),float(cm[index+<span class="number">1</span>:])</span><br><span class="line">        <span class="comment">#取出左边的数据,并且转换成浮点型</span></span><br><span class="line">        <span class="comment">#取出右边的数据,并且转换成浮点型</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    index += <span class="number">1</span> <span class="comment">#index是操作符在输入表达式的里面</span></span><br><span class="line">cau = &#123;</span><br><span class="line">    <span class="string">'+'</span>: l_num + r_num,</span><br><span class="line">    <span class="string">'-'</span>: l_num - r_num,</span><br><span class="line">    <span class="string">"*"</span>: l_num * r_num,</span><br><span class="line">&#125; <span class="comment">#if条件远远不如字典判断快</span></span><br><span class="line"><span class="keyword">if</span> r_num != <span class="number">0</span>:</span><br><span class="line">    cau[<span class="string">'/'</span>] = l_num / r_num</span><br><span class="line">print(<span class="string">'result:'</span>,cau.get(cm[index]))</span><br><span class="line"><span class="comment">#get方法在key值不存在的时候，不会爆错</span></span><br><span class="line"><span class="comment">#cm[index]: 获取到了操作符</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line">expr = input(<span class="string">'请输入一个运算表达式:'</span>)</span><br><span class="line"><span class="comment">#'    2  |*| 0'</span></span><br><span class="line">index = <span class="number">0</span> <span class="comment">#用来查找表达式中 + - * /符号的位置</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> expr: <span class="comment">#定位表达式中操作符的位置</span></span><br><span class="line">    <span class="keyword">if</span> var <span class="keyword">in</span> &#123;<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>&#125;:</span><br><span class="line">        print(<span class="string">"[+] 操作符位置:%d"</span> % index)</span><br><span class="line">        print(<span class="string">"[+] 操作符:%s"</span> % var)</span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># 找到了操作符，那么就跳出循环即可</span></span><br><span class="line">        <span class="comment">#%d 可以整形转义输出</span></span><br><span class="line">        <span class="comment">#%s 转移输出字符串</span></span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line"><span class="comment">#找到左右两个数字</span></span><br><span class="line"><span class="comment">#通过切片访问到字符串中的所有两个数字</span></span><br><span class="line">l_num = float(expr[:index]) <span class="comment">#左边的操作数</span></span><br><span class="line">r_num = float(expr[index+<span class="number">1</span>:]) <span class="comment">#右边的操作数 不能是0</span></span><br><span class="line"><span class="comment">#除法 被除数不能为0</span></span><br><span class="line">oper = expr[index] <span class="comment">#找到了操作符</span></span><br><span class="line"></span><br><span class="line">res = &#123;</span><br><span class="line">    <span class="string">'+'</span>: l_num + r_num,</span><br><span class="line">    <span class="string">'-'</span>: l_num - r_num,</span><br><span class="line">    <span class="string">'*'</span>: l_num * r_num,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r_num != <span class="number">0</span>: <span class="comment">#当第二个操作不为0的时候 才支持除法</span></span><br><span class="line">    res[<span class="string">'/'</span>] = l_num / r_num</span><br><span class="line"></span><br><span class="line">print(<span class="string">'你的结果是: %s'</span> % res.get(oper))</span><br><span class="line"><span class="comment">#get获取字典中不存在key值不会报错，只会返回None</span></span><br><span class="line">    <span class="comment"># %d 只能支持数字(整数)</span></span><br><span class="line">    <span class="comment"># %s 随意一些，支持所有的类型</span></span><br></pre></td></tr></table></figure><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a><strong>字典</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">创建方法：</span><br><span class="line"><span class="number">1</span>、语法大括号包裹：创建字典 = &#123;key:value&#125;</span><br><span class="line"><span class="number">2</span>、工厂方法创建字典：res = dict(([<span class="number">1</span>, <span class="number">2</span>],[<span class="string">'a'</span>, <span class="string">'b'</span>]))</span><br><span class="line">    <span class="number">3</span>、内建方法：dict.fromkeys( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="string">'a'</span> )</span><br><span class="line">   批量创建key值，无法单独为每个key分配具体的value</span><br><span class="line">字典的key是绝对唯一的，不可变的数据才可以做key值</span><br><span class="line">字典的value可以重复，可以是任意的数据类型</span><br><span class="line">字典来自于hash表构成的，hash的检索特别块，hash之后，key值对应的hash值会指向一个具体value地址，也就是为啥我们通过key值访问value很快，就是因为hash表</span><br><span class="line">hash算法处理后的数据，不管之前有多么接近，之后绝对是唯一的，所以需要，key值是一个不能变的</span><br><span class="line">字典也算的上是个无序的数据类型，在python3<span class="number">.6</span> 字典有序了</span><br><span class="line"></span><br><span class="line">字典： &#123; key: value  &#125;</span><br><span class="line">key：</span><br><span class="line"><span class="number">1</span>：hash运算key创建出hash表</span><br><span class="line"><span class="number">2</span>：hash表的查询速度很快</span><br><span class="line"><span class="number">3</span>：字典，他是不可以做索引，切片</span><br><span class="line"><span class="number">4</span>：key值必须是一个不可变数据对象：数字，字符串，元组，</span><br><span class="line"><span class="number">5</span>：key值必须是一个唯一的</span><br><span class="line">value：</span><br><span class="line"><span class="number">1</span>：可以存储不同的数据类型</span><br><span class="line"><span class="number">2</span>：多个key同时对应一个value</span><br><span class="line">&#123;<span class="number">1</span>:<span class="string">'a'</span> , <span class="number">2</span>: <span class="string">'a'</span>&#125;</span><br><span class="line">访问字典：</span><br><span class="line">mydict[key]</span><br><span class="line">mydict.keys()获取字典中所有的key值</span><br><span class="line">mydict.values()获取字典中所有的value值</span><br><span class="line">更新字典：</span><br><span class="line">mydict[key]=value</span><br><span class="line">如果key存在的话，就更新value，如果key不存在的话就创建一个先的key:value的值</span><br><span class="line">删除字典：</span><br><span class="line"><span class="keyword">del</span> mydict[key]直接删除key值</span><br><span class="line">    mydict.pop()  在删除key值得过程中，还会把value值返回</span><br><span class="line">    mydict.clear() 清空字典</span><br><span class="line">    <span class="keyword">del</span> mydict  直接删除字典</span><br><span class="line">mydict.get(key)  此命令在key存在的时候返回对应的value，若key不存在，返回空，不报错</span><br></pre></td></tr></table></figure><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">可变集合：myset=set()</span><br><span class="line">不可变集合：myset=frozenset()</span><br><span class="line"></span><br><span class="line">做爬虫的时候使用集合保存爬取的URL，可以处理重复的连接</span><br><span class="line">集合中的数据没有前后关系，而且是无序的，不能使用<span class="keyword">for</span>循环来遍历</span><br><span class="line">集合的特性：</span><br><span class="line"><span class="number">1</span>、集合是无序的，无法使用<span class="keyword">for</span>来遍历,不可以索引和切片</span><br><span class="line">    <span class="number">2</span>、集合的数据是去重的</span><br><span class="line">    <span class="number">3</span>、集合不能存储可变数据对象，因为可变数据对象无法进行hash运算</span><br><span class="line">    <span class="number">4</span>、集合中的所有数据元素都要经过hash运算，会维护hash表</span><br><span class="line">    <span class="number">5</span>、一个空集合只能通过set()的方式来创建</span><br><span class="line">    myset=&#123;&#125;这个创建的是一个字典</span><br><span class="line">    <span class="number">6</span>、没有value的字典就是集合</span><br><span class="line">    <span class="number">7</span>、普通集合是可变的，不可变集合是frozenset(序列)</span><br><span class="line">更新集合：</span><br><span class="line">set.add(不可变数据类型)</span><br><span class="line">    如果这个类型是不可变序列，这个序列会原样加进集合中</span><br><span class="line">    set.update(数据集str,list,tuple,dict,set)</span><br><span class="line">    数据集将拆分成单个的元素，去掉重复的，然后加入到集合中</span><br><span class="line">        数据集不允许含有可变数据对象</span><br><span class="line">        数据集：str,list,tuple,dict(key值作为集合中的数据)，set,frozenset</span><br><span class="line">可变集合---删除集合</span><br><span class="line">set.remove(集合中的数据元素) 删除后没有任何返回</span><br><span class="line">    set.pop() 不接收任何参数，随机删除，并返回被删除的元素</span><br><span class="line">    <span class="keyword">del</span> myset  直接删除这个变量</span><br><span class="line">可变集合和不可变集合都只能通过<span class="keyword">for</span>循环迭代访问</span><br><span class="line">可用<span class="keyword">in</span> 和 <span class="keyword">not</span> <span class="keyword">in</span> 判断元素是否在集合中</span><br><span class="line">可以用<span class="keyword">in</span>和<span class="keyword">not</span> <span class="keyword">in</span>去获取一个数据集中是否有某个元素</span><br><span class="line">字符串，元组，列表，字典，集合</span><br><span class="line">    <span class="keyword">in</span>是去判断数据库里读取的数据集</span><br><span class="line">更新集合：</span><br><span class="line">myset.add(seq) 直接修改集合本身，会保留和维护数据的形态到集合中</span><br><span class="line">    myset.update(seq) 直接修改集合本身，会将数据拆分去重后加入到集合中</span><br><span class="line">    并且update不接收一个不可拆分的数据，比如整数</span><br><span class="line">        update也可以接收一个列表</span><br><span class="line">删除集合:</span><br><span class="line">    myset.pop()  随机删除并返回删除的值</span><br><span class="line">    myset.remove(obj) 在集合中删除obj,删除一个不存在的值会报错</span><br><span class="line">    myset.discard(obj) 在集合中删除obj,删除一个不存在的值不会报错</span><br><span class="line">    <span class="keyword">del</span>  myset  直接把集合删除了，集合的引用计数减去<span class="number">1</span></span><br><span class="line">集合的运算</span><br><span class="line">a的元素b都有</span><br><span class="line">        子集：a.issubset(b)  a是b的子集</span><br><span class="line">        超集：b.isuperset(b)  b是a的超集</span><br><span class="line">        交集(&amp;)：a和b中共同含有的数据，去重后返回的新的集合就a和b的交集</span><br><span class="line">        并集(|)：a和b两个集合所有元素放到一起，去掉重复返回的新的集合就是a和b的交集</span><br><span class="line">        差集(-)：a-b 从a中去掉a和b共有的，也就是b中有的a都不要了，返回一个新德集合</span><br><span class="line">        对称差分(^)：找出两个集合中各自单独有的数据，也就是a和b的交集减去并集的数据</span><br></pre></td></tr></table></figure><h5 id="系统内置函数"><a href="#系统内置函数" class="headerlink" title="系统内置函数"></a><strong>系统内置函数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">enumerate(iter):接受一个可迭代的对象作为参数，返回一个enumerate对象，</span><br><span class="line">        也是一个迭代器，该对象生成由iter每个元素的index值和item值</span><br><span class="line">len(seq):返回seq长度</span><br><span class="line">max(iter,key=<span class="keyword">None</span>) <span class="keyword">or</span> max(arg0,arg1...key=<span class="keyword">None</span>):</span><br><span class="line">    返回iter或(arg0,arg1)中的最大值，如果指定了key，</span><br><span class="line">    这个key必须是可以传给sort()方法的，用于比较回调的函数</span><br><span class="line">min(iter,key=<span class="keyword">None</span>) <span class="keyword">or</span> min(arg0,arg1...key=<span class="keyword">None</span>):</span><br><span class="line">    返回iter或(arg0,arg1)中的最大值，如果指定了key，</span><br><span class="line">    这个key必须是可以传给sort()方法的，用于比较回调的函数</span><br><span class="line">    &gt;&gt;&gt; max(<span class="string">'a123'</span>,<span class="string">'b123'</span>,key=<span class="keyword">lambda</span> x:x[<span class="number">2</span>])</span><br><span class="line">    &gt;&gt;&gt; <span class="string">'a123'</span></span><br><span class="line">max函数之后的<span class="keyword">lambda</span>表达式，在指定出元素之后，</span><br><span class="line">    会按照你选择的元素来排序，x[<span class="number">2</span>]就是x的第二个元素进行排序</span><br><span class="line">reversed(seq):接受一个序列作为参数，返回一个以逆序访问的迭代器</span><br><span class="line">sorted(iter,cmp=<span class="keyword">None</span>,key=<span class="keyword">None</span>):</span><br><span class="line">    接受一个可迭代的对象作为参数，返回一个有序的列表，可选参数是一个排序方式</span><br><span class="line">sum(seq,init=<span class="number">0</span>):返回seq和可选参数init的总和</span><br><span class="line">zip(it0,it1,...itN):返回一个列表，用法如下：</span><br><span class="line">    可以将对应的序列 对应的索引位置 拼接成一个二元组或者多元组</span><br><span class="line">如果序列长度不一，以短的为主。</span><br><span class="line">    zip函数返回的是一个抽象的数据，保证内存安全，实现了迭代器(可以延迟生产数据)</span><br><span class="line">    </span><br><span class="line">    &gt;&gt;&gt; a=zip(<span class="string">'123'</span>,<span class="string">'abcdef'</span>,<span class="string">'ABC'</span>)</span><br><span class="line">    &lt;zip object at <span class="number">0x000001E28964C848</span>&gt;</span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        ...    print(i)</span><br><span class="line">        ...</span><br><span class="line">        (<span class="string">'1'</span>, <span class="string">'a'</span>,<span class="string">'A'</span>)</span><br><span class="line">        (<span class="string">'2'</span>, <span class="string">'b'</span>,<span class="string">'B'</span>)</span><br><span class="line">        (<span class="string">'3'</span>, <span class="string">'c'</span>,<span class="string">'C'</span>)</span><br><span class="line">map(func,seq):map函数第一个参数可以是一个函数对象，第二个是一个序列</span><br><span class="line">    map函数可以传入的函数依次作用在序列的每一个元素上。</span><br><span class="line">    实例：</span><br><span class="line">    &gt;&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">ys</span><span class="params">(x)</span>:</span></span><br><span class="line">        ...     <span class="keyword">return</span> x*x+<span class="number">1</span></span><br><span class="line">    &gt;&gt;&gt; mylist=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    &gt;&gt;&gt; yes=map(ys,mylist)</span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> yes:</span><br><span class="line">        ...     print(i)</span><br><span class="line">        <span class="number">2</span></span><br><span class="line">        <span class="number">5</span></span><br><span class="line">        <span class="number">10</span></span><br><span class="line">        <span class="number">17</span></span><br><span class="line">        <span class="number">26</span></span><br><span class="line">reduce函数(导入reduce函数 <span class="keyword">from</span> functools <span class="keyword">import</span> reduce)</span><br><span class="line">    用法：reduce把一个函数作用在一个序列[x1,x2,x3...]上，这个函数必须接收两个参数</span><br><span class="line">    reduce把结果继续和序列的下一个元素左累积计算，效果如下：</span><br><span class="line">    &gt;&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        ...     <span class="keyword">return</span> x+y</span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">    &gt;&gt;&gt; mylist=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    &gt;&gt;&gt; reduce(add,mylist)</span><br><span class="line">    <span class="number">15</span></span><br><span class="line">    &gt;&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">cf</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        ...     <span class="keyword">return</span> x*y+<span class="number">1</span></span><br><span class="line">    &gt;&gt;&gt; reduce(cf,mylist)</span><br><span class="line">    <span class="number">120</span></span><br><span class="line">eval(字符串对象)  -&gt; 一般不要用</span><br><span class="line">    会把无意义的字符串变成了合法的表达式</span><br><span class="line">    表达式 一个有效的可以得出结果的式子</span><br><span class="line">repr(表达式)  </span><br><span class="line">将一个表达式变成无意义的字符串</span><br></pre></td></tr></table></figure><h5 id="str内置函数"><a href="#str内置函数" class="headerlink" title="str内置函数"></a><strong>str内置函数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">字符串内建函数--大小写转换函数</span><br><span class="line">    string.lower():字母大写转换为小写</span><br><span class="line">    string.upper():字母小写转换为大写</span><br><span class="line">    string.swapcase():字母大写转换为小写,小写转大写</span><br><span class="line">    string.title():将语句中所有单词的首字母大写</span><br><span class="line">    string.capitalize():将语句中首字母大写，其他小写</span><br><span class="line">字符串内建函数--搜索函数</span><br><span class="line">    string.find(str,[start=<span class="number">0</span>,stop=len(string)])</span><br><span class="line">        计算string中出现str的第一个字母的索引，如果没有出现，则返回<span class="number">-1</span></span><br><span class="line">    string.index(str,[start=<span class="number">0</span>,stop=len(string)])</span><br><span class="line">        计算string中出现str的第一个字母的索引，如果没有出现，出现异常</span><br><span class="line">    string.count(str,[start=<span class="number">0</span>,stop=len(string)]):</span><br><span class="line">        计算str在string中出现的次数</span><br><span class="line">    string.endswith(str,[start=<span class="number">0</span>,stop=len(string)])</span><br><span class="line">        检查sring是否是以str结尾，如果是返回<span class="keyword">True</span>，反之返回<span class="keyword">False</span></span><br><span class="line">字符串内建函数--替换函数</span><br><span class="line">    string.replace(str1,str2,[num=string.count(str1)])</span><br><span class="line">        将str1替换为str2，num为替换次数，默认次数为str1出现的次数</span><br><span class="line">    string.strip(chr):在string的开头和结尾删除chr，当chr为空时，默认删除空白符(\r,\n,\t,<span class="string">" "</span>)</span><br><span class="line">    string.rstrip():删除string字符串末尾的空格，或者换行符号</span><br><span class="line">    string.lstrip():删除string字符串开头的空格，或者换行符号</span><br><span class="line">字符串内建函数--判断函数</span><br><span class="line">    string.isdigit():如果string只包含数字，则返回<span class="keyword">True</span>，否则返回<span class="keyword">False</span></span><br><span class="line">    string.islower():如果字符串中的字母都是小写则返回<span class="keyword">True</span>，否则返回<span class="keyword">False</span></span><br><span class="line">    string.isupper():如果字符串中的字母都是大写则返回<span class="keyword">True</span>，否则返回<span class="keyword">False</span></span><br><span class="line">    string.isspace():字符串中只包含空白字符，返回<span class="keyword">True</span>，否则返回<span class="keyword">False</span></span><br></pre></td></tr></table></figure><h5 id="列表内置函数"><a href="#列表内置函数" class="headerlink" title="列表内置函数"></a><strong>列表内置函数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list.append(obj):在尾部追加obj</span><br><span class="line">list.count():返回一个对象在列表中出现的次数</span><br><span class="line">list.extend(seq):把序列seq中的内容添加到列表中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.extend(<span class="string">'abc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">list.insert(index,obj):在索引index的位置插入obj，原位置数据向后移动</span><br><span class="line">list.pop(index):删除并返回index位置的数据对象，默认是最后一个对象</span><br><span class="line">list.reverse():反转列表</span><br></pre></td></tr></table></figure><h5 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a><strong>元组内置函数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple.index(obj,beg=<span class="number">0</span>,end=len(string)):检查obj是否包含在tuple中</span><br><span class="line">tuple.count(obj):返回obj出现的次数</span><br></pre></td></tr></table></figure><h5 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a><strong>推导式</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">推导式：</span><br><span class="line">一种方便的结合<span class="keyword">for</span>循环进行数据处理的方式</span><br><span class="line">for循环 -&gt; 序列中一个个的取值</span><br><span class="line">列表推导式</span><br><span class="line">[ 表达式 <span class="keyword">for</span> var <span class="keyword">in</span> iterable <span class="keyword">if</span> 过滤条件 ]</span><br><span class="line"><span class="number">1</span>：<span class="keyword">for</span>循环从iterable取值</span><br><span class="line"><span class="number">2</span>：取到的值首先要经过<span class="keyword">if</span>条件判断</span><br><span class="line"><span class="number">3</span>：判断条件成立的数据，放到表达式运算，运算后的结果，作为新列表中的值</span><br><span class="line">集合推导式</span><br><span class="line">&#123; key <span class="keyword">for</span> var <span class="keyword">in</span> iterable <span class="keyword">if</span> 过滤条件 &#125;</span><br><span class="line"></span><br><span class="line">字典推导式</span><br><span class="line">&#123; key:value <span class="keyword">for</span> var <span class="keyword">in</span> iterable <span class="keyword">if</span> 过滤条件 &#125;</span><br><span class="line"></span><br><span class="line">元组推导式 == 迭代器</span><br><span class="line">( key for var in iterable if 过滤条件 )  -&gt; iter</span><br><span class="line">    </span><br><span class="line">列表表达式： [ 表达式 <span class="keyword">for</span> value <span class="keyword">in</span> 序列 <span class="keyword">if</span> 过滤条件 ]</span><br><span class="line">元组表达式： ( 表达式 <span class="keyword">for</span> value <span class="keyword">in</span> 序列 <span class="keyword">if</span> 过滤条件 )</span><br><span class="line">    所有从这个<span class="keyword">for</span>循环出来的每一个数据首先会经过<span class="keyword">if</span>条件过滤，然后执行前面的表达式，</span><br><span class="line">    最后重新返回成一个新的列表，过滤条件可有可无</span><br><span class="line">    &gt;&gt;&gt; mylist=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">    &gt;&gt;&gt; [var*var <span class="keyword">for</span> var <span class="keyword">in</span> mylist <span class="keyword">if</span> var!=<span class="number">3</span>]</span><br><span class="line">    [<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>]</span><br><span class="line">    &gt;&gt;&gt; (var*var <span class="keyword">for</span> var <span class="keyword">in</span> mylist <span class="keyword">if</span> var!=<span class="number">3</span>)</span><br><span class="line">    &lt;generator object &lt;genexpr&gt; at <span class="number">0x00000238D160B3B8</span>&gt;</span><br><span class="line">    &gt;&gt;&gt; my_tuple=(var*var <span class="keyword">for</span> var <span class="keyword">in</span> mylist <span class="keyword">if</span> var!=<span class="number">3</span>)</span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> my_tuple:</span><br><span class="line">    ...     print(i)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">16</span></span><br><span class="line">    &gt;&gt;&gt; my_tuple=(var*var <span class="keyword">for</span> var <span class="keyword">in</span> mylist <span class="keyword">if</span> var!=<span class="number">3</span>)</span><br><span class="line">    &gt;&gt;&gt; my_tuple.__next__()</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    &gt;&gt;&gt; my_tuple.__next__()</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    &gt;&gt;&gt; my_tuple.__next__()</span><br><span class="line">    <span class="number">16</span></span><br><span class="line">    &gt;&gt;&gt; my_tuple.__next__()</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">      File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    StopIteration</span><br><span class="line"></span><br><span class="line">    通过列表推导式就可以把我们含有大小写的列表改成全部大写的列表</span><br><span class="line">    我们生成出所有经过表达式的一个结果序列，并且是列表类型的</span><br><span class="line">元组表达式就是生成器，只有在使用到的时候才生成，比较节约内存</span><br><span class="line"></span><br><span class="line">字典推导式：</span><br><span class="line">    和列表类似，只不过需要两个值存在来维护字典的键值对形式</span><br><span class="line">    &#123;key:value <span class="keyword">for</span> key <span class="keyword">in</span> 序列 <span class="keyword">if</span> 过滤条件&#125;</span><br><span class="line"></span><br><span class="line">    enumerate(obj):这个函数会返回两个值，一个是序列的下标，一个是下标对应的值</span><br><span class="line">    &gt;&gt;&gt; mylist=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line">    &gt;&gt;&gt; mydict=&#123;key:value <span class="keyword">for</span> key,value <span class="keyword">in</span> enumerate(mylist)&#125;</span><br><span class="line">    &gt;&gt;&gt; mydict</span><br><span class="line">    &#123;<span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span>, <span class="number">3</span>: <span class="string">'d'</span>&#125;</span><br><span class="line">    </span><br><span class="line">mydict = &#123;<span class="string">'初心'</span>:&#123;<span class="string">'money'</span>:<span class="number">100000</span>,<span class="string">'sex'</span>:<span class="string">'male'</span>&#125;,<span class="string">'Infor'</span>:&#123;<span class="string">'Money'</span>:<span class="number">110000</span>,<span class="string">'sex'</span>:<span class="string">'male'</span>&#125;&#125;</span><br><span class="line"><span class="comment">#list(mydict[var].keys())[0]</span></span><br><span class="line">newdict = &#123;var:&#123;list(mydict[var].keys())[<span class="number">0</span>]:mydict[var][list(mydict[var].keys())[<span class="number">0</span>]]+<span class="number">1000</span>&#125; <span class="keyword">for</span> var <span class="keyword">in</span> mydict&#125;</span><br><span class="line">print(newdict)</span><br><span class="line"></span><br><span class="line">集合推到式：</span><br><span class="line">    集合推导式跟列表推导式非常相似，唯一的区别在于用&#123;&#125;代替[]</span><br><span class="line">    &#123;表达式 <span class="keyword">for</span> value <span class="keyword">in</span> 序列 <span class="keyword">if</span> 过滤条件&#125;</span><br><span class="line">    &gt;&gt;&gt; mylist</span><br><span class="line">    [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line">    &gt;&gt;&gt; myset=&#123;var*<span class="number">2</span> <span class="keyword">for</span> var <span class="keyword">in</span> mylist&#125;</span><br><span class="line">    &gt;&gt;&gt; myset</span><br><span class="line">    &#123;<span class="string">'aa'</span>, <span class="string">'bb'</span>, <span class="string">'cc'</span>, <span class="string">'dd'</span>&#125;</span><br><span class="line"></span><br><span class="line">推到式：表达式  <span class="keyword">for</span> var <span class="keyword">in</span> 序列 <span class="keyword">if</span> 过滤</span><br></pre></td></tr></table></figure><h5 id="作业：2万以下的-加工资"><a href="#作业：2万以下的-加工资" class="headerlink" title="作业：2万以下的 加工资"></a><strong>作业：2万以下的 加工资</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">salary_list = [<span class="number">13000</span>,<span class="number">12700</span>,<span class="number">15000</span>,<span class="number">14000</span>,<span class="number">25000</span>,<span class="number">16000</span>,<span class="number">18000</span>,<span class="number">22000</span>,<span class="number">32000</span>]</span><br><span class="line"><span class="comment">#2万以下的 加工资</span></span><br><span class="line"><span class="comment">#加1000</span></span><br><span class="line">new_list = []</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> salary_list:</span><br><span class="line">    <span class="keyword">if</span> var &lt;= <span class="number">20000</span>:</span><br><span class="line">        var+=<span class="number">1000</span></span><br><span class="line">    new_list.append(var)</span><br><span class="line">print(new_list)</span><br><span class="line"></span><br><span class="line">res = [ var + <span class="number">1000</span> <span class="keyword">for</span> var <span class="keyword">in</span> salary_list <span class="keyword">if</span> var &lt;= <span class="number">20000</span> ]</span><br><span class="line">salary_list[:len(res)] = res</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#1: for循环取值</span></span><br><span class="line"><span class="comment">#2: 经过if条件判断</span></span><br><span class="line"><span class="comment">#3: 放到最前面，作为新列表的值</span></span><br><span class="line">    <span class="comment">#if...else  if如果不满足，那么执行else</span></span><br><span class="line">    <span class="comment">#for...else  可以循环正常结束的时候，for...else执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把新的列表替换原来的列表元素</span></span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line"></span><br><span class="line">mylist = [<span class="number">13000</span>,<span class="number">15000</span>,<span class="number">15000</span>,<span class="number">17000</span>,<span class="number">20000</span>,<span class="number">14500</span>,<span class="number">23400</span>,<span class="number">27000</span>]</span><br><span class="line">        <span class="comment">#15000 + 2000 - &gt; 17000</span></span><br><span class="line">        <span class="comment">#这个17000和后面的17000重复了，所以会替换多次，一个15000到最后多添加了好几次呢</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(old,new)</span>:</span></span><br><span class="line">    <span class="comment">#不要因为数据相同而重复替换 要避免这个</span></span><br><span class="line">    <span class="comment">#直接修改mylist 这个变量本身</span></span><br><span class="line">    <span class="keyword">global</span> mylist <span class="comment">#使用全局变量mylist及index_list</span></span><br><span class="line">    <span class="keyword">global</span> index_list</span><br><span class="line">    <span class="keyword">for</span> _index,var <span class="keyword">in</span> enumerate(mylist):</span><br><span class="line">        <span class="keyword">if</span> var == old <span class="keyword">and</span> _index <span class="keyword">not</span> <span class="keyword">in</span> index_list: <span class="comment">#如果这个索引还没出现过，那么就替换</span></span><br><span class="line">            print(<span class="string">'当前替换的是:'</span>,mylist[_index])</span><br><span class="line">            mylist[_index] = new</span><br><span class="line">            index_list.append(_index) <span class="comment">#替换完成，记录一下</span></span><br><span class="line">    print(<span class="string">"--------------"</span>) <span class="comment">#函数之行一次之后打印一次横线</span></span><br><span class="line">        <span class="comment">#函数没有返回值，那么就返回None</span></span><br><span class="line"></span><br><span class="line">[replace(var,var+<span class="number">2000</span>) <span class="keyword">for</span> var <span class="keyword">in</span> mylist <span class="keyword">if</span> var &lt; <span class="number">20000</span>]</span><br><span class="line">    <span class="comment">#var : old</span></span><br><span class="line">    <span class="comment">#var + 2000 : new</span></span><br><span class="line">print(<span class="string">'new:'</span>,mylist)</span><br></pre></td></tr></table></figure><h5 id="作业：做一个自己的帮助文档"><a href="#作业：做一个自己的帮助文档" class="headerlink" title="作业：做一个自己的帮助文档"></a><strong>作业：做一个自己的帮助文档</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        这就是我的帮助文档</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#__doc__  可以调取帮助文档</span></span><br><span class="line">help(func)</span><br><span class="line">print(func.__doc__)</span><br><span class="line">res = dir(str)</span><br><span class="line">help_dict = &#123;&#125;</span><br><span class="line"><span class="comment">#帮助文档的列表</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> res: <span class="comment">#提取每个函数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'__'</span> <span class="keyword">in</span> func: <span class="comment">#过滤下划线函数</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    help_dict[func] = func.__doc__ <span class="comment">#把帮助文档追加到列表</span></span><br><span class="line">        <span class="comment">#有则修改，没有则增加</span></span><br><span class="line">    <span class="comment">#key: func 函数名字符串</span></span><br><span class="line">    <span class="comment">#value: func.__doc__ 帮助文档</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> help_dict:</span><br><span class="line">    print(key) <span class="comment">#首先打印函数名</span></span><br><span class="line">    print(help_dict[key]) <span class="comment">#在打印帮助文档</span></span><br><span class="line">    print(<span class="string">'-------------------------'</span>)</span><br><span class="line"><span class="comment">#Web GUI</span></span><br><span class="line">***************************************************************************************</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">print(<span class="string">'退出请输入: q/Q\n'</span>)</span><br><span class="line">user_req = input(<span class="string">'请输入查询序列类型(str/list/tuple/dict/set):\n'</span>)</span><br><span class="line">print()</span><br><span class="line"><span class="keyword">if</span> user_req == <span class="string">'q'</span> <span class="keyword">or</span> user_req == <span class="string">'Q'</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">res = dir(eval(user_req))</span><br><span class="line">print(res)</span><br><span class="line">print()</span><br><span class="line">search_req = input(<span class="string">'请输入查询函数:\n'</span>)</span><br><span class="line">print()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">help(eval(user_req + <span class="string">'.'</span> + search_req))</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> first_reason:</span><br><span class="line">print(<span class="string">'请重新输入!!!The reason: '</span>,str(first_reason))</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> second_reason:</span><br><span class="line">print(<span class="string">"错啦,重新输入!!!The reason: "</span>,str(second_reason))</span><br></pre></td></tr></table></figure><h5 id="作业：每个爷们加1000工资"><a href="#作业：每个爷们加1000工资" class="headerlink" title="作业：每个爷们加1000工资"></a><strong>作业：每个爷们加1000工资</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mydict = &#123;</span><br><span class="line">    <span class="string">'KM'</span>:        &#123;<span class="string">'sex'</span>:<span class="string">'male'</span>,  <span class="string">'工作'</span>:<span class="string">'Star'</span>, <span class="string">'money'</span>:<span class="number">13000</span>,&#125;,</span><br><span class="line">    <span class="string">'Charles'</span>:   &#123;<span class="string">'money'</span>:<span class="number">13000</span>, <span class="string">'性别'</span>:<span class="string">'male'</span>,  <span class="string">'like'</span>:<span class="string">'DJ'</span>&#125;,</span><br><span class="line">    <span class="string">'Mark Smith'</span>:&#123;<span class="string">'salary'</span>:<span class="number">13000</span>, <span class="string">'sex'</span>:<span class="string">'male'</span>,  <span class="string">'job'</span>:<span class="string">'Rap'</span>&#125;,</span><br><span class="line">    <span class="string">'QQ'</span>:        &#123;<span class="string">'money'</span>:<span class="number">15000</span>, <span class="string">'性别'</span>:<span class="string">'female'</span>,<span class="string">'job'</span>:<span class="string">'Dancer'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#dict keys values dict[key] for key in dict</span></span><br><span class="line"><span class="comment">#推导式实现一下，每个爷们加个1000</span></span><br><span class="line"><span class="comment">#job要留下来,money要留下来</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(var)</span>:</span></span><br><span class="line">    var = list(var)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'male'</span> <span class="keyword">in</span> var:<span class="comment">#先判断是否是个男的</span></span><br><span class="line">        <span class="keyword">for</span> _index,value <span class="keyword">in</span> enumerate(var): <span class="comment">#判断是不是个数字</span></span><br><span class="line">            <span class="keyword">if</span> type(value) == int:</span><br><span class="line">                var[_index] = value + <span class="number">1000</span> <span class="comment">#数个数字 加1000</span></span><br><span class="line">    <span class="keyword">return</span> tuple(var)</span><br><span class="line"></span><br><span class="line">new_dict = &#123; key:dict( zip( list( mydict[key].keys() ), func( mydict[key].values() ) ) ) <span class="keyword">for</span> key <span class="keyword">in</span> mydict &#125;</span><br><span class="line"><span class="comment">#只有工资对应的value值是一个整数 int</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> new_dict:</span><br><span class="line">    print(key,<span class="string">':'</span>,new_dict[key])</span><br><span class="line">print(<span class="string">"=================="</span>)</span><br></pre></td></tr></table></figure><h5 id="作业：四色五入"><a href="#作业：四色五入" class="headerlink" title="作业：四色五入"></a><strong>作业：四色五入</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123.9443712837819</span></span><br><span class="line">float_index = <span class="number">2</span> <span class="comment">#我就要2位小数</span></span><br><span class="line">int_part = str(a).split(<span class="string">'.'</span>)[<span class="number">0</span>] <span class="comment">#123 整数部分 str</span></span><br><span class="line">float_part = str(a).split(<span class="string">'.'</span>)[<span class="number">-1</span>] <span class="comment">#90182039 小数部分 str</span></span><br><span class="line">print(<span class="string">"原有数据:"</span>,a)</span><br><span class="line">print(<span class="string">'整数部分:'</span>,int_part)</span><br><span class="line">print(<span class="string">'小数部分:'</span>,float_part)</span><br><span class="line"><span class="comment">#字符串判断整数 直接对比值大小</span></span><br><span class="line"><span class="comment">#字符串判断的是字母 那就是对比ascii码 a 97 A 65</span></span><br><span class="line"><span class="keyword">if</span> len(float_part) &lt;= float_index: <span class="comment">#判断小数长度与精度位数的大小</span></span><br><span class="line">    print(<span class="string">"处理完成之后的小数:"</span>,a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> int(float_part[float_index]) &gt;= <span class="number">5</span>: <span class="comment">#获取小数部分最后一位</span></span><br><span class="line">        print(<span class="string">'小数部分最后一位:'</span>,float_part[float_index])</span><br><span class="line">        print(<span class="string">'扔掉最后一位的结果:'</span>,float_part[:float_index])</span><br><span class="line">        float_part = str( int(float_part[:float_index]) + <span class="number">1</span> )</span><br><span class="line">        print(<span class="string">'最后的小数部分:'</span>,float_part)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#如果说位数精度的数字小于5，不满足上位的条件，那么直接把后面的位省去</span></span><br><span class="line">        print(<span class="string">'小数部分最后一位:'</span>,float_part[float_index])</span><br><span class="line">        print(<span class="string">'扔掉最后一位的结果:'</span>,float_part[:float_index])</span><br><span class="line">        float_part = str( int(float_part[:float_index]) )</span><br><span class="line">        print(<span class="string">'最后的小数部分:'</span>,float_part)</span><br><span class="line">    res = float(<span class="string">'.'</span>.join( [int_part,float_part] ))</span><br><span class="line">    <span class="comment">#res = float(int_part + '.' + float_part)</span></span><br><span class="line">    print(<span class="string">'整数和小数拼接:'</span>,res)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(var,f_index)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        func(var,f_index) -&gt; float</span></span><br><span class="line"><span class="string">        这个函数用来做四舍五入的精度处理</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            var是你传入的小数</span></span><br><span class="line"><span class="string">            f_index是你需要的精度</span></span><br><span class="line"><span class="string">        返回值：</span></span><br><span class="line"><span class="string">            处理后的小数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    int_part = str(var).split(<span class="string">'.'</span>)[<span class="number">0</span>] <span class="comment">#123 整数部分 str</span></span><br><span class="line">    float_part = str(var).split(<span class="string">'.'</span>)[<span class="number">-1</span>] <span class="comment">#90182039 小数部分 st</span></span><br><span class="line">    <span class="keyword">if</span> len(float_part) &lt;= f_index: <span class="comment">#判断小数长度与精度位数的大小</span></span><br><span class="line">        float_part = float_part.ljust(f_index,<span class="string">'0'</span>) <span class="comment">#需要补位的长度</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#如果需要来维护精度，本身的浮点数长度大于了精度要求</span></span><br><span class="line">        <span class="keyword">if</span> int(float_part[f_index]) &gt;= <span class="number">5</span>: <span class="comment">#获取小数部分最后一位</span></span><br><span class="line">            float_part = str( int(float_part[:f_index]) + <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#如果说位数精度的数字小于5，不满足上位的条件，那么直接把后面的位省去</span></span><br><span class="line">            float_part = str( int(float_part[:f_index]) )</span><br><span class="line">    res = float(<span class="string">'.'</span>.join( [int_part,float_part] ))</span><br><span class="line">    <span class="comment">#res = float(int_part + '.' + float_part)</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">res = func(<span class="number">1.2</span>,<span class="number">5</span>) <span class="comment">#-&gt;1.124</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h5 id="作业：人生"><a href="#作业：人生" class="headerlink" title="作业：人生"></a><strong>作业：人生</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># seq 序列: str list tuple set dict</span></span><br><span class="line"><span class="comment"># iterable 可迭代的对象: str list tuple set dict 文件 数据库句柄 数据库返回结果集 生成器迭代器</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#baby -&gt; 小孩</span></span><br><span class="line"><span class="comment">#babe、sweet、my cup of tea -&gt; 宝贝</span></span><br><span class="line">    <span class="comment">#you are my cup of tea</span></span><br><span class="line"><span class="comment">#random choice -&gt; a random element from a non-empty sequence.</span></span><br><span class="line"><span class="comment">#choice(seq) method of random.Random instance</span></span><br><span class="line">    <span class="comment">#Choose a random element from a non-empty sequence.</span></span><br><span class="line">    <span class="comment">#从一个不为空的序列中去取一个值</span></span><br><span class="line">te = &#123;  <span class="comment">#个人信息</span></span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'human'</span>,</span><br><span class="line">    <span class="string">'age'</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="string">'job'</span>:<span class="string">'tea'</span>,</span><br><span class="line">    <span class="string">'like'</span>:<span class="string">'study'</span>,</span><br><span class="line">    <span class="string">'babe'</span>:&#123;&#125;,</span><br><span class="line">        <span class="comment">#保存你的娃</span></span><br><span class="line">        <span class="comment">#娃的名字，娃的性别</span></span><br><span class="line">&#125;</span><br><span class="line">sex_list = [<span class="string">'male'</span>,<span class="string">'female'</span>] <span class="comment">#人的性别</span></span><br><span class="line">mind_list = [<span class="string">'不好'</span>,<span class="string">'还行'</span>,<span class="string">'非常好'</span>,<span class="string">' '</span>] <span class="comment">#情绪的列表，为了可以随机抽样选择</span></span><br><span class="line">things_list = [<span class="string">'normal'</span>,<span class="string">'dangours'</span>,<span class="string">'love'</span>,<span class="string">'gay'</span>,<span class="string">'moeny'</span>,<span class="string">'babe'</span>]</span><br><span class="line">active_dict = &#123; <span class="comment">#当你情绪不一样的时候，所要做的事情</span></span><br><span class="line">    <span class="string">'不好'</span>: <span class="string">'play computer'</span>, <span class="comment">#可以这样创建，但是后面的表达式 会实际的运行的</span></span><br><span class="line">    <span class="string">'还行'</span>: <span class="string">'eat'</span>,</span><br><span class="line">    <span class="string">'非常好'</span> : <span class="string">'不上课了 我要到外面的世界'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#字典不具体的来保存行为，他只是来保存我们要做的事情</span></span><br><span class="line">    <span class="comment">#这个事情一定不要在定义字典的时候来实现</span></span><br><span class="line"><span class="comment">#赋值语句是没有返回值的，直接修改的是对象本身</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">365</span> * <span class="number">80</span>):</span><br><span class="line">    mind = random.choice(mind_list) <span class="comment">#随机抽取今天的情绪</span></span><br><span class="line">    things = random.choice(things_list) <span class="comment">#随机抽取时间</span></span><br><span class="line">    active = active_dict.get(mind) <span class="comment">#执行今天这个心情我要做的事情</span></span><br><span class="line">    <span class="keyword">if</span> things == <span class="string">'babe'</span>:</span><br><span class="line">        print(<span class="string">'今天是第%d天,今天生了!'</span> % var)</span><br><span class="line">        print(<span class="string">'         *         '</span>)</span><br><span class="line">        print(<span class="string">'        ***        '</span>)</span><br><span class="line">        print(<span class="string">'       ******     '</span>)</span><br><span class="line">        print(<span class="string">'         **       '</span>)</span><br><span class="line">        print(<span class="string">'         **       '</span>)</span><br><span class="line">        babe_name = <span class="string">'babe'</span> + str(var) <span class="comment">#宝宝名字命名</span></span><br><span class="line">        babe_sex = random.choice(sex_list)</span><br><span class="line">        te[<span class="string">'babe'</span>][babe_name] = babe_sex</span><br><span class="line">    <span class="keyword">elif</span> things == <span class="string">'dangours'</span>:</span><br><span class="line">        print(<span class="string">'这是第%d天,今天GG了'</span> % var)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#其他时候都是平平淡淡</span></span><br><span class="line">        <span class="keyword">if</span> active:</span><br><span class="line">            te[<span class="string">'like'</span>] = active</span><br><span class="line">        print(<span class="string">'今天是第%d天,今天我遇到了%s: 今天的心情%s, 我要做的事情%s'</span> % (var, things, mind, te[<span class="string">'like'</span>] ))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'完美结束'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'----------人生总结----------'</span>)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> te:</span><br><span class="line">    print(<span class="string">'%s:%s'</span> % (key,te[key]))</span><br><span class="line">    <span class="keyword">if</span> key == <span class="string">'babe'</span>:</span><br><span class="line">        print(<span class="string">"你还有孩子，在下面-------"</span>)</span><br><span class="line">        <span class="keyword">for</span> babe_name <span class="keyword">in</span> te[key]: <span class="comment">#拿到我的孩子列表</span></span><br><span class="line">            print(<span class="string">'%s:%s'</span> % (babe_name,te[key][babe_name]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#'rich':富有</span></span><br><span class="line"><span class="comment">#'handsome':帅气</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;数据类型：数字，字符串，列表，元组，集合，字典&lt;/strong&gt;&lt;/p&gt;&lt;h5 id=&quot;数字&quot;&gt;&lt;a href=&quot;#数字&quot; clas
      
    
    </summary>
    
      <category term="python" scheme="http://www.python100.com/categories/python/"/>
    
    
      <category term="python基础数据类型" scheme="http://www.python100.com/tags/python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>常用函数</title>
    <link href="http://www.python100.com/2018/07/26/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <id>http://www.python100.com/2018/07/26/常见函数用法/</id>
    <published>2018-07-26T01:44:00.000Z</published>
    <updated>2018-07-31T15:52:10.545Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h3 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">map(func, seq1[, seq2,…]) </span><br><span class="line">第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个集合。</span><br><span class="line">Python函数编程中的map()函数是将func作用于seq中的每一个元素，并将所有的调用的结果作为一个list返回。如果func为<span class="keyword">None</span>，作用同zip()。</span><br><span class="line"><span class="comment">#使用lambda</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">lambda</span> x: x % <span class="number">2</span>, range(<span class="number">7</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">一个seq时，可以使用filter()函数代替</span><br><span class="line">当seq多于一个时，map可以并行（注意是并行）地对每个seq执行</span><br><span class="line">每个seq的同一位置的元素同时传入一个多元的func函数之后，得到一个返回值，并将这个返回值存放在一个列表中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">lambda</span> x , y : x ** y, [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">[<span class="number">8</span>, <span class="number">16</span>, <span class="number">6</span>]     <span class="comment">#执行过程[2**3,4**2,6**1]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">lambda</span> x , y : (x ** y, x + y), [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">[(<span class="number">8</span>, <span class="number">5</span>), (<span class="number">16</span>, <span class="number">6</span>), (<span class="number">6</span>, <span class="number">7</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">None</span>, [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])  <span class="comment">#func为NONE时，就同zip一样了</span></span><br><span class="line">[(<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">2</span>), (<span class="number">6</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">其他用法例子：</span><br><span class="line">***将元组转换成list***</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(int, (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">***将字符串转换成list***</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(int, <span class="string">'1234'</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">***提取字典的key，并将结果存放在一个list中***</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(int, &#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>,<span class="number">3</span>:<span class="number">4</span>&#125;)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">***字符串转换成元组，并将结果以列表的形式返回***</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(tuple, <span class="string">'agdf'</span>)</span><br><span class="line">[(<span class="string">'a'</span>,), (<span class="string">'g'</span>,), (<span class="string">'d'</span>,), (<span class="string">'f'</span>,)]</span><br><span class="line"><span class="comment">#将小写转成大写</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">u_to_l</span> <span class="params">(s)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> s.upper()</span><br><span class="line"><span class="keyword">print</span> map(u_to_l,<span class="string">'asdfd'</span>)</span><br></pre></td></tr></table></figure><h3 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">zip函数返回一个以元组为元素的列表，其中第 i 个元组包含每个参数序列的第 i 个元素。返回的列表长度被截断为最短的参数序列的长度。只有一个序列参数时，它返回一个<span class="number">1</span>元组的列表。没有参数时，它返回一个空的列表。</span><br><span class="line">概括起来一句话：zip函数返回的是一个列表，但是列表里面的元素是由一个个元组构成的..</span><br><span class="line">做机器学习分类的时候，就可以利用zip函数，将我们的数据点与我们的数据点对应的标签进行关联..</span><br><span class="line"><span class="comment">#例一：</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">z = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">xyz = zip(x, y, z)</span><br><span class="line"><span class="keyword">print</span> xyz</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="comment">#例二：</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x = zip(x)</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,)]</span><br><span class="line"><span class="comment">#例三：</span></span><br><span class="line">x = zip()</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line">[]</span><br><span class="line"><span class="comment">#例四：</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">z = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">xyz = zip(x, y, z)</span><br><span class="line">u = zip(*xyz)</span><br><span class="line"><span class="keyword">print</span> u</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line">一般认为这是一个unzip的过程，它的运行机制是这样的：</span><br><span class="line">在运行zip(*xyz)之前，xyz的值是：[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]</span><br><span class="line">那么，zip(*xyz) 等价于 zip((<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>))</span><br><span class="line">所以，运行结果是：[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="comment">#例五：</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">r = zip(* [x] * <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> r</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)]</span><br><span class="line">它的运行机制是这样的：</span><br><span class="line">[x]生成一个列表的列表，它只有一个元素x</span><br><span class="line">[x] * <span class="number">3</span>生成一个列表的列表，它有<span class="number">3</span>个元素，[x, x, x]</span><br><span class="line">zip(* [x] * <span class="number">3</span>)的意思就明确了，zip(x, x, x)</span><br></pre></td></tr></table></figure><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">result1=random.random() <span class="comment">#随机生成一个浮点数[0,1)</span></span><br><span class="line">result2=random.randint(<span class="number">1</span>, <span class="number">10</span>) <span class="comment">#产生1-10的一个随机整数,包含1和10</span></span><br><span class="line">result3=random.uniform(<span class="number">1.1</span>, <span class="number">2.1</span>) <span class="comment">#产生1.1-2.2之间的随机浮点数</span></span><br><span class="line">result4=random.choice(<span class="string">"python"</span>)  <span class="comment">#参数是一个可以迭代的类型，从参数中随机选一个元素</span></span><br><span class="line">result5=random.randrange(<span class="number">1</span>,<span class="number">50</span>,<span class="number">2</span>) <span class="comment">#随机产生1-50，间隔为2随机整数，左闭右开，不包含50</span></span><br><span class="line">test_list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">random.shuffle(test_list) <span class="comment">#需要注意的是这个操作是在原来参数的基础上操作的，不会返回新的数据</span></span><br><span class="line">print(<span class="string">"test_list:"</span>+str(test_list))</span><br><span class="line">test_list:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>]   <span class="comment">#shuffle就是将原有列表的顺序打乱，也就是重新洗牌的功能</span></span><br><span class="line">random.sample(seq,n)  <span class="comment">#可以从指定的序列中，随机的截取指定长度的片断，不作原地修改。</span></span><br></pre></td></tr></table></figure><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当前使用平台：</span></span><br><span class="line">os.name  <span class="comment">#返回当前使用平台的代表字符，Windows用'nt'表示，Linux用'posix'表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前路径和文件</span></span><br><span class="line">os.getcwd()  <span class="comment">#返回当前工作目录</span></span><br><span class="line">os.listdir(path)  <span class="comment">#返回path目录下所有文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#abspath()  将相对路径转化为绝对路径</span></span><br><span class="line">path = <span class="string">'./boys'</span><span class="comment">#相对</span></span><br><span class="line">result = os.path.abspath(path)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#系统操作：</span></span><br><span class="line">os.system()  <span class="comment">#运行shell命令</span></span><br><span class="line">&gt;&gt;&gt;os.system(<span class="string">'cmd'</span>)  <span class="comment">#Windows下打开终端</span></span><br><span class="line">&gt;&gt;&gt;os.system(<span class="string">'ls'</span>)  <span class="comment">#Linux下查看当前目录所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件名或目录：</span></span><br><span class="line">os.path.split(path)  <span class="comment">#将path的目录和文件名分开为元组，split() 将一个完整的路径切割成目录部分和主体部分</span></span><br><span class="line">os.path.join(path1,path2,...)  <span class="comment">#将path1，怕path2，...进行组合，若path2为绝对路径，则会将path1删除</span></span><br><span class="line">os.path.dirname(path)  <span class="comment">#返回path中的目录（文件夹部分），结果不包含'\'</span></span><br><span class="line">os.path.basename(path)  <span class="comment">#返回path中的文件名</span></span><br><span class="line"><span class="comment">#dirname()  获取完整路径当中的目录部分  &amp;  basename()获取完整路径当中的主体部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建目录：</span></span><br><span class="line">os.mkdir(path)  <span class="comment">#创建path目录（只能创建一级目录，如'F:\XXX\WWW'）,在XXX目录下创建WWW目录</span></span><br><span class="line">os.makedirs(path)  <span class="comment">#创建多级目录（如'F:\XXX\SSS'），在F盘下创建XXX目录，继续在XXX目录下创建SSS目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除文件或目录：</span></span><br><span class="line">os.remove(path)  <span class="comment">#删除文件（必须是文件）</span></span><br><span class="line">os.rmdir(path)  <span class="comment">#删除path目录(只能删除一级目录，如'F:\XXX\SSS'),只删除SSS目录，只能删除空目录</span></span><br><span class="line">os.removedirs(path)  <span class="comment">#删除多级目录（如'F:\XXX\SSS'）,必须为空目录，删除SSS、FFF目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更改路径：</span></span><br><span class="line">os.chdir(path)  <span class="comment">#将当前工作目录更改为指定路径path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件时间：</span></span><br><span class="line">os.path.getmtime(path)  <span class="comment">#返回文件或目录的最后修改时间，结果为秒数</span></span><br><span class="line">os.path.getatime(path)  <span class="comment">#返回文件或目录的最后访问时间，结果为秒数</span></span><br><span class="line">os.path.getctime(path)  <span class="comment">#返回文件或目录得创建时间，结果为秒数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件大小：</span></span><br><span class="line">os.path.getsize(path)  <span class="comment">#返回文件的大小，若是目录则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件：</span></span><br><span class="line">os.path.exists(path)  <span class="comment">#判断path是否存在，存在返回True,不存在返回False</span></span><br><span class="line">os.path.isfile(path)  <span class="comment">#判断path是否为文件，是返回True,不是返回False</span></span><br><span class="line">os.path.isdir(path)  <span class="comment">#判断path是否目录，是返回True，不是返回False</span></span><br><span class="line">os.path.islink(path) <span class="comment">#islink() 检测是否是链接</span></span><br><span class="line">os.path.isabs(path) <span class="comment">#isabs() 检测一个路径是否是绝对路径</span></span><br><span class="line">os.path.samefile(path1,path2) <span class="comment">#samefile() 检测2个路径是否是同一个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取文件和目录：</span></span><br><span class="line">os.walk(path)   <span class="comment">#递归返回path下的目录（包括path目录）、子目录、文件名的三元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获得shell命令返回值：</span></span><br><span class="line">fp=os.popen(cmd)   <span class="comment">#打开命令cmd或从命令cmd打开管道，返回值是连接到管道的文件对象</span></span><br><span class="line">rlt=fp.read()或 rlt=fp.readlines()  <span class="comment">#读取结果</span></span><br><span class="line">os.system(<span class="string">'dir'</span>)  <span class="comment">#获取系统命令的返回结果，但无法保存到一个变量里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rename() 文件或文件夹重命名</span></span><br><span class="line">os.rename(<span class="string">'/home/sy/a'</span>,<span class="string">'/home/sy/alibaba'</span>）</span><br><span class="line">os.rename(<span class="string">'02.txt'</span>,<span class="string">'002.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#stat() 获取文件或者文件夹的信息</span></span><br><span class="line">result = os.stat(<span class="string">'/home/sy/PycharmProject/Python3/10.27/01.py)</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">#getenv() 获取系统的环境变量</span></span><br><span class="line"><span class="string">result = os.getenv('</span>PATH<span class="string">')</span></span><br><span class="line"><span class="string">print(result.split('</span>:<span class="string">'))</span></span><br><span class="line"><span class="string">                 </span></span><br><span class="line"><span class="string">#putenv() 将一个目录添加到环境变量中(临时增加仅对当前脚本有效)</span></span><br><span class="line"><span class="string">os.putenv('</span>PATH<span class="string">','</span>/home/sy/下载<span class="string">')</span></span><br><span class="line"><span class="string">os.system('</span>syls<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#常用变量</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; os.curdir #curdir  表示当前文件夹   .表示当前文件夹  一般情况下可以省略</span></span><br><span class="line"><span class="string">'</span>.<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; os.pardir #pardir  表示上一层文件夹   ..表示上一层文件夹  不可省略!</span></span><br><span class="line"><span class="string">'</span>..<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; os.name #name 获取代表操作系统的名称字符串</span></span><br><span class="line"><span class="string">'</span>nt<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; os.sep #sep 获取系统路径间隔符号  window -&gt;\    linux -&gt;/</span></span><br><span class="line"><span class="string">'</span>\\<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; os.extsep #extsep 获取文件名称和后缀之间的间隔符号  window &amp; linux -&gt; .</span></span><br><span class="line"><span class="string">'</span>.<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; repr(os.linesep) #linesep  获取操作系统的换行符号  window -&gt; \r\n  linux/unix -&gt; \n</span></span><br><span class="line"><span class="string">"'</span>\\r\\n<span class="string">'"</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">&gt;&gt;&gt; path = '</span>/home/sy/<span class="number">000.</span>py<span class="string">'   </span></span><br><span class="line"><span class="string">#splitext() 将一个路径切割成文件后缀和其他两个部分,主要用于获取文件的后缀</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; result = os.path.splitext(path)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(result)</span></span><br><span class="line"><span class="string">('</span>/home/sy/<span class="number">000</span><span class="string">', '</span>.py<span class="string">')</span></span><br></pre></td></tr></table></figure><h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sys.argv: </span></span><br><span class="line">实现从程序外部向程序传递参数。</span><br><span class="line">可以用sys.argv获取当前正在执行的命令行参数的参数列表(list)</span><br><span class="line">sys.argv[<span class="number">0</span>] 当前程序名</span><br><span class="line">sys.argv[<span class="number">1</span>] 第一个参数</span><br><span class="line">sys.argv[<span class="number">0</span>] 第二个参数</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.exit([arg]): </span></span><br><span class="line">程序中间的退出，arg=<span class="number">0</span>为正常退出。</span><br><span class="line">调用sys.exit(n)可以中途退出程序，当参数非<span class="number">0</span>时，会引发一个SystemExit异常，从而可以在主程序中捕获该异常。</span><br><span class="line">sys.getdefaultencoding(): 获取系统当前编码，一般默认为ascii。</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.setdefaultencoding():</span></span><br><span class="line">设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding(<span class="string">'utf8'</span>)，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.getfilesystemencoding(): </span></span><br><span class="line">获取文件系统使用编码方式，Windows下返回<span class="string">'mbcs'</span>，mac下返回<span class="string">'utf-8'</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.path: </span></span><br><span class="line">获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中<span class="keyword">import</span>时正确找到。</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.platform: </span></span><br><span class="line">获取当前系统平台。如win32表示是Windows <span class="number">32</span>bit操作系统，linux2表示是linux平台；</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.stdin,sys.stdout,sys.stderr: </span></span><br><span class="line">stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而<span class="keyword">print</span> 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdin.readline()  <span class="comment">#从标准输入读一行</span></span><br><span class="line">sfdsafkjl</span><br><span class="line"><span class="string">'sfdsafkjl\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">"AAA"</span>)  </span><br><span class="line">AAA3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">"BBBBBb"</span>)</span><br><span class="line">BBBBBb6</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.modules</span></span><br><span class="line">功能：sys.modules是一个全局字典，该字典是python启动后就加载在内存中。每当程序员导入新的模块，sys.modules将自动记录该模块。当第二次再导入该模块时，python会直接到字典中查找，从而加快了程序运行的速度。它拥有字典所拥有的一切方法。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules.keys()   <span class="comment">#返回所有已经导入模块列表</span></span><br><span class="line">dict_keys([<span class="string">'builtins'</span>, <span class="string">'sys'</span>, <span class="string">'_frozen_importlib'</span>, <span class="string">'_imp'</span>, <span class="string">'_warnings'</span>, <span class="string">'_thread'</span>, <span class="string">'_weakref'</span>, <span class="string">'_frozen_importlib_external'</span>, <span class="string">'_io'</span>, <span class="string">'marshal'</span>, <span class="string">'nt'</span>, <span class="string">'winreg'</span>, <span class="string">'zipimport'</span>, <span class="string">'encodings'</span>, <span class="string">'codecs'</span>, <span class="string">'_codecs'</span>, <span class="string">'encodings.aliases'</span>, <span class="string">'encodings.utf_8'</span>, <span class="string">'_signal'</span>, <span class="string">'__main__'</span>, <span class="string">'encodings.latin_1'</span>, <span class="string">'io'</span>, <span class="string">'abc'</span>, <span class="string">'_weakrefset'</span>, <span class="string">'site'</span>, <span class="string">'os'</span>, <span class="string">'errno'</span>, <span class="string">'stat'</span>, <span class="string">'_stat'</span>, <span class="string">'ntpath'</span>, <span class="string">'genericpath'</span>, <span class="string">'os.path'</span>, <span class="string">'_collections_abc'</span>, <span class="string">'_sitebuiltins'</span>, <span class="string">'sysconfig'</span>, <span class="string">'_bootlocale'</span>, <span class="string">'_locale'</span>, <span class="string">'encodings.gbk'</span>, <span class="string">'_codecs_cn'</span>, <span class="string">'_multibytecodec'</span>, <span class="string">'atexit'</span>, <span class="string">'pydoc'</span>, <span class="string">'importlib'</span>, <span class="string">'importlib._bootstrap'</span>, <span class="string">'importlib._bootstrap_external'</span>, <span class="string">'types'</span>, <span class="string">'functools'</span>, <span class="string">'_functools'</span>, <span class="string">'collections'</span>, <span class="string">'operator'</span>, <span class="string">'_operator'</span>, <span class="string">'keyword'</span>, <span class="string">'heapq'</span>, <span class="string">'_heapq'</span>, <span class="string">'itertools'</span>, <span class="string">'reprlib'</span>, <span class="string">'_collections'</span>, <span class="string">'weakref'</span>, <span class="string">'collections.abc'</span>, <span class="string">'warnings'</span>, <span class="string">'importlib.machinery'</span>, <span class="string">'importlib.util'</span>, <span class="string">'importlib.abc'</span>, <span class="string">'contextlib'</span>, <span class="string">'inspect'</span>, <span class="string">'ast'</span>, <span class="string">'_ast'</span>, <span class="string">'dis'</span>, <span class="string">'opcode'</span>, <span class="string">'_opcode'</span>, <span class="string">'enum'</span>, <span class="string">'linecache'</span>, <span class="string">'tokenize'</span>, <span class="string">'re'</span>, <span class="string">'sre_compile'</span>, <span class="string">'_sre'</span>, <span class="string">'sre_parse'</span>, <span class="string">'sre_constants'</span>, <span class="string">'copyreg'</span>, <span class="string">'token'</span>, <span class="string">'pkgutil'</span>, <span class="string">'platform'</span>, <span class="string">'subprocess'</span>, <span class="string">'time'</span>, <span class="string">'signal'</span>, <span class="string">'threading'</span>, <span class="string">'traceback'</span>, <span class="string">'msvcrt'</span>, <span class="string">'_winapi'</span>, <span class="string">'urllib'</span>, <span class="string">'urllib.parse'</span>, <span class="string">'tempfile'</span>, <span class="string">'shutil'</span>, <span class="string">'fnmatch'</span>, <span class="string">'posixpath'</span>, <span class="string">'zlib'</span>, <span class="string">'bz2'</span>, <span class="string">'_compression'</span>, <span class="string">'_bz2'</span>, <span class="string">'lzma'</span>, <span class="string">'_lzma'</span>, <span class="string">'random'</span>, <span class="string">'math'</span>, <span class="string">'hashlib'</span>, <span class="string">'_hashlib'</span>, <span class="string">'_blake2'</span>, <span class="string">'_sha3'</span>, <span class="string">'bisect'</span>, <span class="string">'_bisect'</span>, <span class="string">'_random'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.modules[<span class="string">"os"</span>])</span><br><span class="line">&lt;module <span class="string">'os'</span> <span class="keyword">from</span> <span class="string">'D:\\Program Files (x86)\\Python36-35\\lib\\os.py'</span>&gt;</span><br><span class="line"><span class="comment">#还可以通过key值获取模块所处路径</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.hexversion <span class="comment">#获取python解释器的版本值，16进制格式</span></span><br><span class="line"><span class="number">50726384</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.version <span class="comment">#获取python解释器的版本信息</span></span><br><span class="line"><span class="string">'3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 16:07:46) [MSC v.1900 32 bit (Intel)]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.copyright <span class="comment">#返回python版权相关信息</span></span><br><span class="line"><span class="string">'Copyright (c) 2001-2018 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n\nCopyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\nAll Rights Reserved.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.api_version <span class="comment">#解释器的C的API版本</span></span><br><span class="line"><span class="number">1013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.version_info  <span class="comment">#python版本信息，final表示最终版本，candidate表示候选，还有后续发行版本</span></span><br><span class="line">sys.version_info(major=<span class="number">3</span>, minor=<span class="number">6</span>, micro=<span class="number">5</span>, releaselevel=<span class="string">'final'</span>, serial=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.executable  <span class="comment">#返回python解释器的路径</span></span><br><span class="line"><span class="string">'D:\\Program Files (x86)\\Python36-35\\python.exe'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getwindowsversion() <span class="comment">#获取windows的版本信息</span></span><br><span class="line">sys.getwindowsversion(major=<span class="number">10</span>, minor=<span class="number">0</span>, build=<span class="number">17134</span>, platform=<span class="number">2</span>, service_pack=<span class="string">''</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;map函数&quot;&gt;&lt;a href=&quot;#map函数&quot; class=&quot;headerlink&quot; title=&quot;map函数&quot;&gt;&lt;/a&gt;map函数&lt;/h
      
    
    </summary>
    
      <category term="python" scheme="http://www.python100.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>kvm安装</title>
    <link href="http://www.python100.com/2018/07/24/%E5%AE%89%E8%A3%85kvm/"/>
    <id>http://www.python100.com/2018/07/24/安装kvm/</id>
    <published>2018-07-24T10:09:00.000Z</published>
    <updated>2018-07-31T15:52:41.951Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><p>VMware虚机在启动之前开启CPU虚拟化<br><img src="/images/kvm/虚拟化" alt="1"></p><p>1、安装桌面GUI</p><pre><code>yum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot; </code></pre><p>2、安装kvm</p><pre><code>yum -y install libcanberra-gtk2 qemu-kvm.x86_64 qemu-kvm-tools.x86_64  libvirt.x86_64 libvirt-cim.x86_64 libvirt-client.x86_64 libvirt-java.noarch  libvirt-python.x86_64 libiscsi-1.7.0-5.el6.x86_64  dbus-devel  virt-clone tunctl virt-manager libvirt libvirt-python python-virtinst</code></pre><p>查看kvm模块是否已经安装成功<br><img src="/images/kvm/lsmod" alt="2"></p><p>3、安装桥接网络，并设置/</p><p>yum -y install bridge-utils</p><p><img src="/images/kvm/br0" alt="3"></p><p><img src="/images/kvm/ifconfig" alt="4"></p><p>设置完成后重启网络，并查看网络</p><pre><code>[root@localhost network-scripts]# brctl showbridge name    bridge id        STP enabled    interfacesbr0        8000.000c29c12e49    yes        ens37virbr0        8000.525400c9ff4e    yes        virbr0-nic</code></pre><p>4、重启libvirt,设置开机自启动</p><pre><code>systemctl start libvirtdsystemctl enable libvirtd</code></pre><p>5、使用virt-manager图形化来管理kvm虚机<br><img src="/images/kvm/1-1" alt="1531910233741"><br><img src="/images/kvm/1-2" alt="1531910233741"><br><img src="/images/kvm/1-3" alt="1531910233741"><br><img src="/images/kvm/1-4" alt="1531910233741"><br><img src="/images/kvm/1-5" alt="1531910233741"><br><img src="/images/kvm/1-6" alt="1531910233741"><br><img src="/images/kvm/1-7" alt="1531910233741"><br><img src="/images/kvm/1-8" alt="1531910233741"><br><img src="/images/kvm/1-9" alt="1531910233741"><br><img src="/images/kvm/1-10" alt="1531910233741"></p><p>之后就是正常安装系统的步骤</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;p&gt;VMware虚机在启动之前开启CPU虚拟化&lt;br&gt;&lt;img src=&quot;/images/kvm/虚拟化&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;p&gt;1、安装桌面GUI&lt;/
      
    
    </summary>
    
      <category term="kvm" scheme="http://www.python100.com/categories/kvm/"/>
    
    
  </entry>
  
  <entry>
    <title>virsh相关命令</title>
    <link href="http://www.python100.com/2018/07/24/%E5%85%B3%E4%BA%8Evirsh%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.python100.com/2018/07/24/关于virsh相关命令/</id>
    <published>2018-07-24T10:06:00.000Z</published>
    <updated>2018-07-24T10:16:15.780Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h2 id="关于virsh相关命令"><a href="#关于virsh相关命令" class="headerlink" title="关于virsh相关命令"></a>关于virsh相关命令</h2><p>常用文件路径</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">虚拟机配置文件默认路径：</span><br><span class="line">[root@bainuo qemu]<span class="comment"># pwd</span></span><br><span class="line">/etc/libvirt/qemu</span><br><span class="line">[root@bainuo qemu]<span class="comment"># ls</span></span><br><span class="line">networks  vm01.xml</span><br><span class="line"></span><br><span class="line">磁盘文件默认路径：</span><br><span class="line">[root@bainuo images]<span class="comment"># pwd</span></span><br><span class="line">/var/lib/libvirt/images</span><br><span class="line">[root@bainuo images]<span class="comment"># ls</span></span><br><span class="line">vm01.img</span><br></pre></td></tr></table></figure><h3 id="虚机"><a href="#虚机" class="headerlink" title="虚机"></a>虚机</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">virsh命令参数 功能 用法举例</span><br><span class="line"></span><br><span class="line">list 查看已经存在的domain信息(可以带参数) virsh list --all (查看所有的虚拟机)</span><br><span class="line">start 开始一个不活跃的domain(前提是存在)   virsh start test2</span><br><span class="line">autostart 配置domain随boot启动 virsh autostart test2</span><br><span class="line">shutdown 优雅的关闭domain virsh shutdown test2</span><br><span class="line">destroy 立刻终止一个domain(强制关闭) virsh destroy test2</span><br><span class="line">reboot 重启一个domain(仅仅发送reboot命令)    virsh reboot test2</span><br><span class="line">suspend  挂起服务器   virsh suspend  test2</span><br><span class="line">resume   恢复服务器virsh resume test2</span><br><span class="line"></span><br><span class="line">console 连接domain的虚拟的控制台(只能有<span class="number">1</span>个)  virsh console test2</span><br><span class="line">ttyconsole 输出设备使用的domain的tty console virsh ttyconsole test2</span><br><span class="line">dominfo 返回关于domain的基本信息 virsh dominfo test2</span><br><span class="line">migrate 迁移一个domain到另一台主机  </span><br><span class="line"> </span><br><span class="line">KVM虚拟网络管理命令(virtual network)：</span><br><span class="line">virsh命令参数 功能 用法举例</span><br><span class="line">net-autostart 配置一个虚拟网络开机自启(--disable可以关闭) virsh net-autostart br0</span><br><span class="line">net-create 通过一个xml文件创建一个虚拟网络 virsh net-create ./virbr1.xml</span><br><span class="line">net-define 通过xml文件定义一个虚拟网络，仅定义不实例化 virsh net-define ./virbr1.xml</span><br><span class="line">net-destory 停止由其名称(uuid)指定的虚拟网络，立即生效 virsh net-destroy br0</span><br><span class="line">net-dumpxml 以xml文件的形式输出一个虚拟网络的配置信息 virsh net-dumpxml br0</span><br><span class="line">net-edit 编辑一个虚拟网络的配置文件(修改虚拟网络配置) virsh net-edit br0</span><br><span class="line">net-info 返回要查看的虚拟网络的基本信息 virsh net-info default</span><br><span class="line">net-list 查看当前的虚拟网络信息(可以带参数) virsh net-list --all</span><br><span class="line">net-name  </span><br><span class="line">net-start 开始一个不活跃的虚拟网络 virsh net-start br0</span><br><span class="line">net-undefine 将一个不活跃的虚拟网络取消定义 virsh net-undefine br0</span><br><span class="line">net-uuid  </span><br><span class="line">net-update  </span><br><span class="line"></span><br><span class="line">创建并启用一个网络：net-define -&gt; net-start</span><br><span class="line">virsh net-define br0.xml</span><br><span class="line">virsh net-list --all (有br0网络,但处于不活跃状态)</span><br><span class="line">virsh net-start br0</span><br><span class="line">virsh net-list --all (br0网络已处于活跃状态)</span><br><span class="line"> </span><br><span class="line">停用并删除一个网络(以br0为例)：net-destroy -&gt; net-undefine</span><br><span class="line">virsh net-destroy br0</span><br><span class="line">virsh net-list --all (br0网络变为不活跃状态)</span><br><span class="line">virsh </span><br><span class="line">net-undefine br0</span><br><span class="line">virsh net-list --all (br0网络已被删除)</span><br></pre></td></tr></table></figure><h3 id="存储池"><a href="#存储池" class="headerlink" title="存储池"></a>存储池</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创建基于文件夹的存储池</span><br><span class="line"><span class="number">1</span>) 定义一个存储池</span><br><span class="line">virsh pool-define-as kvm_images dir - - - - “/kvm/images”</span><br><span class="line"><span class="number">2</span>) 查看创建的存储池信息</span><br><span class="line">virsh pool-list –all</span><br><span class="line"><span class="number">3</span>) 建立基于文件夹的存储池</span><br><span class="line">virsh pool-build kvm_images</span><br><span class="line"><span class="number">4</span>) 使存储池生效</span><br><span class="line">virsh pool-start kvm_images</span><br><span class="line"><span class="number">5</span>) 这时候，存储池还不是自动运行，使用virsh pool-autostart</span><br><span class="line">virsh pool-autostart kvm_images</span><br><span class="line"><span class="number">6</span>) 验证存储池</span><br><span class="line">virsh pool-info kvm_images</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">　　virsh回车进入交互式界面：</span><br><span class="line"></span><br><span class="line">version</span><br><span class="line">pwd</span><br><span class="line">hostname　　显示本节点主机名</span><br><span class="line">nodeinfo　　  显示节点信息</span><br><span class="line">list --all　　　显示所有云主机</span><br><span class="line"><span class="number">7</span>种状态：</span><br><span class="line"></span><br><span class="line">  running 　　运行中</span><br><span class="line">  idel　　　　 空闲，未运行</span><br><span class="line">  paused　　 暂停状态</span><br><span class="line">  shutdown　关闭</span><br><span class="line">  crashed　　虚拟机崩溃</span><br><span class="line">  dying　　　垂死状态，但是又没有完全关闭或崩溃</span><br><span class="line">  shutdown &lt;domain&gt;　　</span><br><span class="line">  destroy    &lt;domain&gt;　　强制关闭虚拟机（相当于直接拨电源）</span><br><span class="line">  start　　　&lt;domain&gt;　　启动虚拟机</span><br><span class="line">  edit　 &lt;domain&gt;　　　　 编辑该虚拟机的xml文件</span><br><span class="line">  dommemstat &lt;domain&gt;　获取domain的内存状态</span><br><span class="line">  suspend  &lt;domain&gt;　　    挂起一个正在运行的虚拟机，该虚拟机仍占资源；</span><br><span class="line">  resume  &lt;domain&gt;　　　　从挂起状态恢复一下虚拟机</span><br><span class="line">  vcpuinfo &lt;domain&gt;　　　　显示一些虚拟机的vcpu的信息</span><br><span class="line">  vncdisplay  &lt;domain&gt;　　  显示vnc监听地址和端口</span><br></pre></td></tr></table></figure><h3 id="快照相关命令"><a href="#快照相关命令" class="headerlink" title="快照相关命令"></a>快照相关命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">snapshot-create &lt;domain&gt; xmlfile 　　给domain创建一个snapshot，详细内容保存在xmlfile中</span><br><span class="line">snapshot-current &lt;domain&gt; 　　　　　显示一个domain的当前的snapshot</span><br><span class="line">snapshot-list &lt;domain&gt;　　　　　　　　 显示一个domain的所有的snapshot</span><br><span class="line">snapshot-revert &lt;domain&gt; snapshot 　　    恢复一个domian到以前的snapshot</span><br><span class="line">snapshot-delete &lt;domain&gt; snapshot --children   删除一个domain的snapshot</span><br></pre></td></tr></table></figure><p>如何用<strong>libvirt</strong>远程管理虚拟机？</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">要用libvirt连接到超级管理程序，我们需要一个URI，这个URI配合virsh和virt-viewer命令使用，后面可以跟一些可选项，virt-viewer可以调用一些链接参数，例如：virsh -c qemu:///system 当链接到远程机器时，可以定义几种使用的协议：ssh，tcp，tls。当链接到远程机器时，需要使用远程主机的用户和主机名进行链接，如果没有定义链接用户，则会使用本机环境的<span class="variable">$USER</span>的用户进行链接，当连接到qemu hypervisor时，接受两种链接类型：system可以有所有的访问权限，session有限制的访问。例如：</span><br><span class="line"></span><br><span class="line">使用full access链接至本机的qemu hypervisor，前面的-c 是为了执行后面的list命令(--connect)</span><br><span class="line">virsh -c  qemu:///system list</span><br><span class="line"></span><br><span class="line">使用full access链接至远程主机的qemu hypervisor，每次都要输入ssh密码，改成ssh无密码登陆就不需要输入密码了，直接显示结果。</span><br><span class="line"></span><br><span class="line">　　virsh -c qemu+ssh://tux@mercur/system   直接进入交互virsh模式</span><br><span class="line"></span><br><span class="line">　　virsh -c qemu+ssh://<span class="number">10.1</span>.<span class="number">1.8</span>/system list   直接显示list后的结果</span><br><span class="line"></span><br><span class="line">　　其余连接格式如下：</span><br><span class="line">　　qemu:///session                      (local access to per-user instance)</span><br><span class="line">　　qemu+unix:///session                 (local access to per-user instance)</span><br><span class="line">　　qemu:///system                       (local access to system instance)</span><br><span class="line">　　qemu+unix:///system                  (local access to system instance)</span><br><span class="line">　　qemu://example.com/system            (remote access, TLS/x509)　　</span><br><span class="line">　　qemu+tcp://example.com/system        (remote access, SASl/Kerberos)</span><br><span class="line">　　qemu+ssh:///system   (remote access, SSH tunnelled)</span><br></pre></td></tr></table></figure><h3 id="使用libvirt创建kvm虚拟机："><a href="#使用libvirt创建kvm虚拟机：" class="headerlink" title="使用libvirt创建kvm虚拟机："></a>使用libvirt创建kvm虚拟机：</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、制作虚拟机镜像</span><br><span class="line">qemu-img create -f qcow2 test.qcow2 <span class="number">10</span>G //格式，名字，大小</span><br><span class="line"><span class="number">2</span>、下载并复制iso镜像到指定目录（在第<span class="number">3</span>步中创建xml文件中指定）</span><br><span class="line"><span class="number">3</span>、创建安装配置文件，demo.xml如下，可以根据自己需求更改</span><br><span class="line">virsh define  demo.xml　　　　//创建虚拟机</span><br><span class="line">virsh  start    test_ubuntu 　　//启动虚拟机</span><br><span class="line">virsh  vncdisplay   test_ubuntu   ////查看虚拟机的vnc端口， 然后就可以通过vnc登录来完成虚拟机的安装</span><br></pre></td></tr></table></figure><p>demo.xml 内容如下 默认路径在/etc/libvirt/qemu</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;domain type=<span class="string">'kvm'</span>&gt;</span><br><span class="line">        &lt;name&gt;test_ubuntu&lt;/name&gt; //虚拟机名称</span><br><span class="line">        &lt;memory&gt;<span class="number">1048576</span>&lt;/memory&gt; //最大内存，单位k</span><br><span class="line">        &lt;currentMemory&gt;<span class="number">1048576</span>&lt;/currentMemory&gt; //可用内存，单位k</span><br><span class="line">        &lt;vcpu&gt;<span class="number">8</span>&lt;/vcpu&gt; //虚拟cpu个数</span><br><span class="line">        &lt;os&gt;</span><br><span class="line">          &lt;type arch=<span class="string">'x86_64'</span> machine=<span class="string">'pc'</span>&gt;hvm&lt;/type&gt;</span><br><span class="line">          &lt;boot dev=<span class="string">'cdrom'</span>/&gt; //光盘启动</span><br><span class="line">       &lt;/os&gt;</span><br><span class="line">       &lt;features&gt;</span><br><span class="line">         &lt;acpi/&gt;</span><br><span class="line">         &lt;apic/&gt;</span><br><span class="line">         &lt;pae/&gt;</span><br><span class="line">       &lt;/features&gt;</span><br><span class="line">       &lt;clock offset=<span class="string">'localtime'</span>/&gt;</span><br><span class="line">       &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;</span><br><span class="line">       &lt;on_reboot&gt;restart&lt;/on_reboot&gt;</span><br><span class="line">       &lt;on_crash&gt;destroy&lt;/on_crash&gt;</span><br><span class="line">       &lt;devices&gt;</span><br><span class="line">         &lt;emulator&gt;/usr/libexec/qemu-kvm&lt;/emulator&gt;</span><br><span class="line">         &lt;disk type=<span class="string">'file'</span> device=<span class="string">'disk'</span>&gt;</span><br><span class="line">          &lt;driver name=<span class="string">'qemu'</span> type=<span class="string">'qcow2'</span>/&gt;</span><br><span class="line">           &lt;source file=<span class="string">'/var/lib/libvirt/images/test.qcow2'</span>/&gt; //目的镜像路径</span><br><span class="line">           &lt;target dev=<span class="string">'hda'</span> bus=<span class="string">'ide'</span>/&gt;</span><br><span class="line">         &lt;/disk&gt;</span><br><span class="line">         &lt;disk type=<span class="string">'file'</span> device=<span class="string">'cdrom'</span>&gt;</span><br><span class="line">           &lt;source file=<span class="string">'/var/lib/libvirt/images/ubuntu.iso'</span>/&gt; //光盘镜像路径</span><br><span class="line">           &lt;target dev=<span class="string">'hdb'</span> bus=<span class="string">'ide'</span>/&gt;</span><br><span class="line">         &lt;/disk&gt;</span><br><span class="line">        &lt;interface type=<span class="string">'bridge'</span>&gt; //虚拟机网络连接方式</span><br><span class="line">          &lt;source bridge=<span class="string">'kvmbr0'</span>/&gt; //当前主机网桥的名称</span><br><span class="line">          &lt;mac address=<span class="string">"00:16:3e:5d:aa:a8"</span>/&gt; </span><br><span class="line">          //为虚拟机分配mac地址，务必唯一，否则dhcp获得同样ip,引起冲突</span><br><span class="line">         &lt;/interface&gt;</span><br><span class="line">         &lt;input type=<span class="string">'mouse'</span> bus=<span class="string">'ps2'</span>/&gt;</span><br><span class="line">          &lt;graphics type=<span class="string">'vnc'</span> port=<span class="string">'-1'</span> autoport=<span class="string">'yes'</span> listen = <span class="string">'0.0.0.0'</span> keymap=<span class="string">'en-us'</span>/&gt;</span><br><span class="line">          //vnc方式登录，端口号自动分配，自动加<span class="number">1</span>，可以通过virsh vncdisplay来查询</span><br><span class="line">        &lt;/devices&gt;</span><br><span class="line">      &lt;/domain&gt;</span><br></pre></td></tr></table></figure><h3 id="使用virsh-install安装虚机命令"><a href="#使用virsh-install安装虚机命令" class="headerlink" title="使用virsh-install安装虚机命令"></a>使用virsh-install安装虚机命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt-install \ --name=guest1-rhel5-<span class="number">64</span> \ --file=/var/lib/libvirt/images/guest1-rhel5-<span class="number">64</span>.dsk \ --file-size=<span class="number">8</span> \ --nonsparse --graphics spice \ --vcpus=<span class="number">2</span> --ram=<span class="number">2048</span> \ --location=http://example1.com/installation_tree/RHEL5.<span class="number">6</span>-Serverx86_64/os \ --network bridge=br0 \ --os-type=linux \ --os-variant=rhel5.<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="使用-qemu-img-和-qemu-kvm-命令行方式安装"><a href="#使用-qemu-img-和-qemu-kvm-命令行方式安装" class="headerlink" title="使用 qemu-img 和 qemu-kvm 命令行方式安装"></a>使用 qemu-img 和 qemu-kvm 命令行方式安装</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）创建一个空的qcow2格式的镜像文件</span><br><span class="line">qemu-img create -f qcow2 windows-master.qcow2 <span class="number">10</span>G</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）启动一个虚机，将系统安装盘挂到 cdrom，安装操作系统</span><br><span class="line">qemu-kvm  -hda  windows-master.qcow2  -m <span class="number">512</span> -boot d  -cdrom /home/user/isos/en_winxp_pro_with_sp2.iso</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）现在你就拥有了一个带操作系统的镜像文件。你可以以它为模板创建新的镜像文件。使用模板的好处是，它会被设置为只读所以可以免于破坏。</span><br><span class="line">qemu-img create -b windows-master.qcow2 -f  qcow2   windows-clone.qcow2</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）你可以在新的镜像文件上启动虚机了</span><br><span class="line">qemu-kvm  -hda  windows-clone.qcow2  -m <span class="number">400</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h2 id=&quot;关于virsh相关命令&quot;&gt;&lt;a href=&quot;#关于virsh相关命令&quot; class=&quot;headerlink&quot; title=&quot;关于virsh
      
    
    </summary>
    
      <category term="kvm" scheme="http://www.python100.com/categories/kvm/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodump与mongorestore</title>
    <link href="http://www.python100.com/2018/07/24/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>http://www.python100.com/2018/07/24/mongo数据库备份与恢复/</id>
    <published>2018-07-24T10:06:00.000Z</published>
    <updated>2018-07-31T15:54:03.147Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h1 id="MongoDB-备份-mongodump-与恢复-mongorestore"><a href="#MongoDB-备份-mongodump-与恢复-mongorestore" class="headerlink" title="MongoDB 备份(mongodump)与恢复(mongorestore)"></a>MongoDB 备份(mongodump)与恢复(mongorestore)</h1><ul><li>mongoexport/mongoimport导入/导出的是JSON格式，而mongodump/mongorestore导入/导出的是BSON格式。<br>JSON可读性强但体积较大，BSON则是二进制文件，体积小但对人类几乎没有可读性。<br>在一些mongodb版本之间，BSON格式可能会随版本不同而有所不同，所以不同版本之间用mongodump/mongorestore可能<br>不会成功，具体要看版本之间的兼容性。当无法使用BSON进行跨版本的数据迁移的时候，使用JSON格式即mongoexport/mongoimport是一个可选项。跨版本的mongodump/mongorestore个人并不推荐，实在要做请先检查文档看两个版本是否兼容（大部分时候是的）。<br>JSON虽然具有较好的跨版本通用性，但其只保留了数据部分，不保留索引，账户等其他基础信息。使用时应该注意。</li></ul><p>mongodump命令脚本语法如下：</p><pre><code>&gt;mongodump -h dbhost -d dbname -o dbdirectory -h：    MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017-d：    需要备份的数据库实例，例如：test-o：    备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，    系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 </code></pre><p>mongodump –host HOST_NAME –port PORT_NUMBER 该命令将备份所有MongoDB数据<br>mongodump –host runoob.com –port 27017</p><p>[root@www1 mongodb]# mongodump -h localhost -u u1 -p 123qwe -d data -o data_mongo.tar</p><p>mongodump –dbpath DB_PATH –out BACKUP_DIRECTORY<br>mongodump –dbpath /data/db/ –out /data/backup/</p><p>mongodump –collection COLLECTION –db DB_NAME 该命令将备份指定数据库的集合。<br>mongodump –collection mycol –db test</p><h1 id="mongorestore"><a href="#mongorestore" class="headerlink" title="mongorestore"></a>mongorestore</h1><p>mogorestore命令脚本语法如下：</p><pre><code>&gt;mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;--host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017--db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2--drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！path：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 &lt;path&gt; 和 --dir 选项，--dir也可以设置备份目录。--dir：指定备份的目录你不能同时指定 &lt;path&gt; 和 --dir 选项。</code></pre><h1 id="mongoexport"><a href="#mongoexport" class="headerlink" title="mongoexport"></a>mongoexport</h1><pre><code>参数    -h:指明数据库宿主机的IP    -u:指明数据库的用户名    -p:指明数据库的密码    -d:指明数据库的名字    -c:指明collection的名字    -f:指明要导出那些列    -o:指明到要导出的文件名    -q:指明导出数据的过滤条件    root@mongo:~/cas.mongo# mongorestore -h mongo:27017 -uadmin -pPassw0rd  -d admin admin    root@mongo:~/cas.mongo# mongorestore -h mongo:27017 -ucas -pPassw0rd  -d cas cas[root@localhost mongodb]# ./bin/mongoexport -d test -c students -o students.dat      -d:指明使用的库，本例中为test    -c:指明要导出的集合，本例中为students    -o:指明要导出的文件名，本例中为students.dat./bin/mongoexport -d test -c students --csv -f classid,name,age -o students_csv.dat     -csv：指明要导出为csv格式    -f：指明需要导出classid、name、age这3列的数据 </code></pre><h1 id="mongoimport"><a href="#mongoimport" class="headerlink" title="mongoimport"></a>mongoimport</h1><pre><code>参数    -h:指明数据库宿主机的IP    -u:指明数据库的用户名    -p:指明数据库的密码    -d:指明数据库的名字    -c:指明collection的名字    -f:指明要导入那些列./bin/mongoimport -d test -c students students.dat     参数说明：    -d:指明数据库名，本例中为test    -c:指明collection名，本例中为students    students.dat：导入的文件名./bin/mongoimport -d test -c students --type csv --headerline --file students_csv.dat       -type:指明要导入的文件格式    -headerline:指明第一行是列名，不需要导入    -file：指明要导入的文件</code></pre><p>–备份单个表</p><pre><code>mongodump -u  superuser -p 123456  --port 27017 --authenticationDatabase admin -d myTest -c d -o /backup/mongodb/myTest_d_bak_201507021701.bak</code></pre><p>–备份单个库</p><pre><code>mongodump  -u  superuser -p 123456 --port 27017  --authenticationDatabase admin -d myTest -o  /backup/mongodb/</code></pre><p>–备份所有库</p><pre><code>mongodump  -u  superuser -p 123456 --authenticationDatabase admin  --port 27017 -o /root/bak </code></pre><p>–备份所有库推荐使用添加–oplog参数的命令，这样的备份是基于某一时间点的快照，只能用于备份全部库时才可用，单库和单表不适用：</p><pre><code>mongodump -h 127.0.0.1 --port 27017   --oplog -o  /root/bak </code></pre><p>–同时，恢复时也要加上–oplogReplay参数，具体命令如下(下面是恢复单库的命令)：</p><pre><code>mongorestore  -d swrd --oplogReplay  /home/mongo/swrdbak/swrd/</code></pre><p>–恢复单个库：</p><pre><code>mongorestore  -u  superuser -p 123456 --port 27017  --authenticationDatabase admin -d myTest   /backup/mongodb/</code></pre><p>–恢复所有库：</p><pre><code>mongorestore   -u  superuser -p 123456 --port 27017  --authenticationDatabase admin  /root/bak</code></pre><p>–恢复单表</p><pre><code>mongorestore -u  superuser -p 123456  --authenticationDatabase admin -d myTest -c d /backup/mongodb/myTest_d_bak_201507021701.bak/myTest/d.bson</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h1 id=&quot;MongoDB-备份-mongodump-与恢复-mongorestore&quot;&gt;&lt;a href=&quot;#MongoDB-备份-mongodump
      
    
    </summary>
    
      <category term="mongo" scheme="http://www.python100.com/categories/mongo/"/>
    
    
  </entry>
  
  <entry>
    <title>docker设置本地仓库</title>
    <link href="http://www.python100.com/2018/07/24/docker_registry/"/>
    <id>http://www.python100.com/2018/07/24/docker_registry/</id>
    <published>2018-07-24T10:06:00.000Z</published>
    <updated>2018-07-24T10:20:14.325Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --><hr><h3 id="account-chenqmc"><a href="#account-chenqmc" class="headerlink" title="account:chenqmc"></a>account:chenqmc</h3><pre><code>openssl req -newkey rsa:4096 -nodes -sha256 -keyout ${HOSTNAME}.key -x509 -days 365 -out ${HOSTNAME}.crt</code></pre><h3 id="vim-etc-docker-daemon-json"><a href="#vim-etc-docker-daemon-json" class="headerlink" title="vim /etc/docker/daemon.json"></a>vim /etc/docker/daemon.json</h3><pre><code>{&quot;registry-mirrors&quot;: [&quot;http://187193f5.m.daocloud.io&quot;]}</code></pre><h3 id="拉取registry"><a href="#拉取registry" class="headerlink" title="拉取registry"></a>拉取registry</h3><pre><code>docker pull registry</code></pre><h3 id="启动registry"><a href="#启动registry" class="headerlink" title="启动registry"></a>启动registry</h3><pre><code>docker run -d -p 5000:5000 -v  /opt/data/registry:/tmp/registry  registry</code></pre><h3 id="将镜像进行tag打包，传入本地镜像"><a href="#将镜像进行tag打包，传入本地镜像" class="headerlink" title="将镜像进行tag打包，传入本地镜像"></a>将镜像进行tag打包，传入本地镜像</h3><pre><code>[root@www1 ~]# docker tag 471e783ffeca 127.0.0.1:5000/mdc-cas[root@www1 ~]# docker push 127.0.0.1:5000/mdc-cas</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jul 31 2018 23:58:42 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;account-chenqmc&quot;&gt;&lt;a href=&quot;#account-chenqmc&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="docker" scheme="http://www.python100.com/categories/docker/"/>
    
    
  </entry>
  
</feed>
