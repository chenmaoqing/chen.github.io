<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>乘风破浪</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.python100.com/"/>
  <updated>2018-08-21T06:29:47.666Z</updated>
  <id>http://www.python100.com/</id>
  
  <author>
    <name>chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lamp使用https</title>
    <link href="http://www.python100.com/2018/08/08/lamp%E4%BD%BF%E7%94%A8https/"/>
    <id>http://www.python100.com/2018/08/08/lamp使用https/</id>
    <published>2018-08-08T01:54:00.000Z</published>
    <updated>2018-08-21T06:29:47.666Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><h2>直接使用yum安装lamp环境</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装lamp</span></span><br><span class="line">[root@www2 ~] yum -y install mariadb-server httpd php php-mysql php-fpm  openssl-devel</span><br><span class="line"><span class="comment">#安装http支持ssl的模板，安装成功后，会有/etc/httpd/conf.d/ssl.conf 文件</span></span><br><span class="line">[root@www2 ~] yum install mod_ssl -y</span><br><span class="line"><span class="comment">#启动lamp环境相关服务</span></span><br><span class="line">[root@www2 httpd]<span class="comment"># systemctl restart httpd</span></span><br><span class="line">[root@www2 httpd]<span class="comment"># systemctl restart mariadb</span></span><br><span class="line">[root@www2 httpd]<span class="comment"># systemctl restart php-fpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置mysql数据库密码，创建安装discuz和WordPress的数据库</span></span><br><span class="line">[root@www2 httpd]<span class="comment">#mysql</span></span><br><span class="line">MariaDB [(none)]&gt; set password=password(<span class="string">'123qwe'</span>);  <span class="comment">#设置数据库密码</span></span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line"><span class="number">4</span> rows <span class="keyword">in</span> set (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; create database discuz;  <span class="comment">#创建数据库</span></span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">#授权www可以本地登陆</span></span><br><span class="line">MariaDB [(none)]&gt; grant all on discuz.* to www@<span class="string">'localhost'</span> identified by <span class="string">'123qwe'</span>; </span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">#设置www可以远程登陆数据库</span></span><br><span class="line">MariaDB [(none)]&gt; grant all on discuz.* to www@<span class="string">'%'</span> identified by <span class="string">'123qwe'</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将生成的签名放入到/etc/httpd/conf.d/下</span></span><br><span class="line">[root@www2 httpd]<span class="comment"># ls conf.d/</span></span><br><span class="line">autoindex.conf  README      server.csr  ssl.conf      welcome.conf</span><br><span class="line">php.conf        server.crt  server.key  userdir.conf server.key.unsecure</span><br><span class="line"><span class="comment">#将保护私钥的密码从认证文件里抽离出来，生成server.key.unsecure</span></span><br><span class="line">[root@www2 ~]<span class="comment"># openssl rsa  -in server.key -out server.key.unsecure</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改ssl的配置文件，指明认证文件位置</span></span><br><span class="line">[root@www2 ~]<span class="comment"># vim /etc/httpd/conf.d/ssl.conf</span></span><br><span class="line"><span class="number">100</span> SSLCertificateFile /etc/httpd/conf.d/server.crt </span><br><span class="line"><span class="number">101</span> </span><br><span class="line"><span class="number">102</span> <span class="comment">#   Server Private Key:</span></span><br><span class="line"><span class="number">103</span> <span class="comment">#   If the key is not combined with the certificate, use this</span></span><br><span class="line"><span class="number">104</span> <span class="comment">#   directive to point at the key file.  Keep in mind that if</span></span><br><span class="line"><span class="number">105</span> <span class="comment">#   you've both a RSA and a DSA private key you can configure</span></span><br><span class="line"><span class="number">106</span> <span class="comment">#   both in parallel (to also allow the use of DSA ciphers, etc.)</span></span><br><span class="line"><span class="number">107</span> SSLCertificateKeyFile /etc/httpd/conf.d/server.key.unsecure  </span><br><span class="line"></span><br><span class="line">[root@www2 ~]<span class="comment"># vim /etc/php.ini  #修改php配置文件，让httpd支持php</span></span><br><span class="line">short_open_tag = On  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启lamp环境的服务，让修改的配置生效</span></span><br></pre></td></tr></table></figure><h3 id="设置httpd虚拟机主机-在相应的地方创建相应的目录及文件"><a href="#设置httpd虚拟机主机-在相应的地方创建相应的目录及文件" class="headerlink" title="设置httpd虚拟机主机,在相应的地方创建相应的目录及文件"></a>设置httpd虚拟机主机,在相应的地方创建相应的目录及文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改httpd配置文件，加载相应的模块</span></span><br><span class="line">[root@www2 ~]<span class="comment"># vim /etc/httpd/conf/httpd.conf </span></span><br><span class="line">ServerName <span class="number">192.168</span>.<span class="number">100.20</span>:<span class="number">80</span>  </span><br><span class="line">LoadModule socache_dbm_module modules/mod_socache_dbm.so</span><br><span class="line">LoadModule socache_shmcb_module modules/mod_socache_shmcb.so</span><br><span class="line">LoadModule ssl_module modules/mod_ssl.so     <span class="comment">#开启ssl模块</span></span><br><span class="line">LoadModule rewrite_module modules/mod_rewrite.so   <span class="comment">#开启重定向</span></span><br><span class="line"></span><br><span class="line">[root@www2 ~]<span class="comment"># vim /etc/httpd/conf.d/vhost.conf </span></span><br><span class="line">&lt;Directory <span class="string">"/var/www/html/www1"</span>&gt;   <span class="comment">#设置虚机目录权限</span></span><br><span class="line">Options FollowSymLinks  </span><br><span class="line"><span class="comment">#Options通常有Indexes选项，它的作用就是当该目录下没有 index.html 文件时，就显示目录结构，去掉 Indexes，Apache 就不会显示该目录的列表了。</span></span><br><span class="line">AllowOverride All       <span class="comment">#是否允许覆盖，All是允许，可让.htaccess文件可以生效，None是不允许，由于要http强制跳转到https，所以需要开启这一选项</span></span><br><span class="line">Require all granted <span class="comment">#响应所有请求</span></span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost <span class="number">192.168</span>.<span class="number">100.20</span>:<span class="number">8081</span>&gt;   </span><br><span class="line"><span class="comment">#虚机ip及端口，这个端口是通过443转发访问的，httpd的主配置文件不需要添加Listen这个端口的配置</span></span><br><span class="line">DocumentRoot <span class="string">"/var/www/html/www1"</span>   <span class="comment">#虚机目录</span></span><br><span class="line">ServerName <span class="number">192.168</span>.<span class="number">100.10</span>   <span class="comment">#虚机域名</span></span><br><span class="line">ErrorLog <span class="string">"logs/www1-error_log"</span></span><br><span class="line">CustomLog <span class="string">"logs/www1-access_log"</span> common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory <span class="string">"/var/www/html/www2"</span>&gt;</span><br><span class="line">Options FollowSymLinks</span><br><span class="line">AllowOverride All</span><br><span class="line">Require all granted </span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost <span class="number">192.168</span>.<span class="number">100.20</span>:<span class="number">8088</span>&gt;</span><br><span class="line">DocumentRoot <span class="string">"/var/www/html/www2"</span></span><br><span class="line">ServerName <span class="number">192.168</span>.<span class="number">100.10</span></span><br><span class="line">ErrorLog <span class="string">"logs/www2-error_log"</span></span><br><span class="line">CustomLog <span class="string">"logs/www2-access_log"</span> common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;Directory <span class="string">"/var/www/html/discuz/upload"</span>&gt;</span><br><span class="line">Options FollowSymLinks</span><br><span class="line">AllowOverride All</span><br><span class="line">Require all granted </span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost <span class="number">192.168</span>.<span class="number">100.20</span>:<span class="number">8888</span>&gt;</span><br><span class="line">DocumentRoot <span class="string">"/var/www/html/discuz/upload"</span></span><br><span class="line">ServerName <span class="number">192.168</span>.<span class="number">100.10</span></span><br><span class="line">ErrorLog <span class="string">"logs/discuz-error_log"</span></span><br><span class="line">CustomLog <span class="string">"logs/discuz-access_log"</span> common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory <span class="string">"/var/www/html/wordpress"</span>&gt;</span><br><span class="line">Options FollowSymLinks</span><br><span class="line">AllowOverride All</span><br><span class="line">Require all granted </span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost <span class="number">192.168</span>.<span class="number">100.20</span>:<span class="number">8000</span>&gt;</span><br><span class="line">DocumentRoot <span class="string">"/var/www/html/wordpress"</span></span><br><span class="line">ServerName <span class="number">192.168</span>.<span class="number">100.10</span></span><br><span class="line">ErrorLog <span class="string">"logs/wordpress-error_log"</span></span><br><span class="line">CustomLog <span class="string">"logs/wordpress-access_log"</span> common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><h3 id="设置Apache的rewrite功能"><a href="#设置Apache的rewrite功能" class="headerlink" title="设置Apache的rewrite功能"></a>设置Apache的rewrite功能</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www2 ~]<span class="comment"># vim /var/www/html/www1/.htaccess </span></span><br><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond %&#123;SERVER_PORT&#125; !^<span class="number">443</span>$</span><br><span class="line">RewriteRule ^(.*)?$ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R]</span><br><span class="line"></span><br><span class="line"><span class="comment">#在其他三个虚机的根目录下也穿件相同的.htaccess文件</span></span><br></pre></td></tr></table></figure><h3 id="在火狐浏览器上访问，导入ca证书，存入本地"><a href="#在火狐浏览器上访问，导入ca证书，存入本地" class="headerlink" title="在火狐浏览器上访问，导入ca证书，存入本地"></a>在火狐浏览器上访问，导入ca证书，存入本地</h3><h3 id="导入成功，就会http自动跳转到https，之后安装网页模板验证："><a href="#导入成功，就会http自动跳转到https，之后安装网页模板验证：" class="headerlink" title="导入成功，就会http自动跳转到https，之后安装网页模板验证："></a>导入成功，就会http自动跳转到https，之后安装网页模板验证：</h3><p>输入<a href="https://192.168.100.20/discuz/upload/install进行安装，安装成功后如下" target="_blank" rel="noopener">https://192.168.100.20/discuz/upload/install进行安装，安装成功后如下</a></p><p><img src="/images/lamp使用https.assets/1.png" alt="1533637364111"><br><img src="/images/lamp使用https.assets/2.png" alt="1533637424137"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;h2&gt;直接使用yum安装lamp环境&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="CA" scheme="http://www.python100.com/categories/CA/"/>
    
    
      <category term="CA" scheme="http://www.python100.com/tags/CA/"/>
    
  </entry>
  
  <entry>
    <title>系统开机过程</title>
    <link href="http://www.python100.com/2018/07/31/%E7%B3%BB%E7%BB%9F%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.python100.com/2018/07/31/系统开机过程/</id>
    <published>2018-07-31T15:29:00.000Z</published>
    <updated>2018-07-31T15:48:41.124Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><p><img src="/images/系统开机过程.assets/1533042168708.png" alt="1533042168708"></p><p><strong>步骤1：</strong>上电自检POST(Power-on self test)，主要负责检测系统外围关键设备（如：CPU、内存、显卡、I/O、键盘鼠标等）是否正常。例如，最常见的是内存松动的情况，BIOS自检阶段会报错，系统就无法启动起来；</p><p><strong>步骤2：</strong>步骤1成功后，便会执行一段小程序用来枚举本地设备并对其初始化。这一步主要是根据我们在BIOS中设置的系统启动顺序来搜索用于启动系统的驱动器，如硬盘、光盘、U盘、软盘和网络等。我们以硬盘启动为例，BIOS此时去读取硬盘驱动器的第一个扇区(MBR，512字节)，然后执行里面的代码。实际上这里BIOS并不关心启动设备第一个扇区中是什么内容，它只是负责读取该扇区内容、并执行。至此，BIOS的任务就完成了，此后将系统启动的控制权移交到MBR部分的代码。</p><p><strong>步骤3</strong>：系统引导</p><p>grub引导也分为两个阶段stage1阶段和stage2阶段</p><p>1)、stage1：stage1是直接被写入到MBR中去的，这样机器一启动检测完硬件后，就将控制权交给了GRUB的代码。 BIOS将stage1载入内存中0x7c00处并跳转执行。stage1（/stage1/start.S）的任务非常单纯，仅仅是将硬盘0头0道2扇区读入内存。而0头0道2扇区内容是源代码中的/stage2/start.S，编译后512字节，它是stage2或者stage1_5的入口。而此时，stage1是没有识别文件系统的能力的。</p><p>2)、stage2： 它的主要作用就是负责将stage2或stage1.5从硬盘读到内存中。如果是stage2，它将被载入到0x820处；如果是stage1.5，它将被载入到0x2200处。这里的stage2或者stage1_5不是/boot分区/boot/grub目录下的文件，因为这个时候grub还没有能力识别任何文件系统。</p><p><strong>步骤4</strong>：启动内核</p><p>当stage2被载入内存执行时，它首先会去解析grub的配置文件/boot/grub/grub.conf，然后加载内核镜像到内存中，并将控制权转交给内核。而内核会立即初始化系统中各设备并做相关的配置工作，其中包括CPU、I/O、存储设备等。</p><p>Linux的内核镜像仅是包含了基本的硬件驱动，在系统安装过程中会检测系统硬件信息，根据安装信息和系统硬件信息将一部分设备驱动写入 initrd 。这样在以后启动系统时，一部分设备驱动就放在initrd中来加载。</p><p>grub的stage2将initrd加载到内存里，让后将其中的内容释放到内容中，内核便去执行initrd中的init脚本，这时内核将控制权交给了init文件处理。我们简单浏览一下init脚本的内容，发现它也主要是加载各种存储介质相关的设备驱动程序。当所需的驱动程序加载完后，会创建一个根设备，然后将根文件系统rootfs以只读的方式挂载。这一步结束后，释放未使用的内存，转换到真正的根文件系统上面去，同时运行/sbin/init程序，执行系统的1号进程。此后系统的控制权就全权交给/sbin/init进程了。</p><p><strong>步骤5</strong>：初始化系统</p><p>1)、执行系统初始化脚本(/etc/rc.d/rc.sysinit)，对系统进行基本的配置，以读写方式挂载根文件系统及其它文件系统，到此系统算是基本运行起来了，后面需要进行运行级别的确定及相应服务的启动。</p><p>2)、执行/etc/rc.d/rc脚本。该文件定义了服务启动的顺序是先K后S，而具体的每个运行级别的服务状态是放在/etc/rc.d/rc<em>.d（</em>=0~6）目录下，所有的文件均是指向/etc/init.d下相应文件的符号链接。rc.sysinit通过分析/etc/inittab文件来确定系统的启动级别，然后才去执行/etc/rc.d/rc*.d下的文件。</p><p>3)、执行用户自定义引导程序/etc/rc.d/rc.local。其实当执行/etc/rc.d/rc3.d/S99local时，它就是在执行/etc/rc.d/rc.local。S99local是指向rc.local的符号链接。</p><p>4)、完成了系统所有的启动任务后，linux会启动终端或X-Window来等待用户登录。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&quot;/images/系统开机过程.assets/1533042168708.png&quot; alt=&quot;1533042168708&quot;&gt;&lt;/p
      
    
    </summary>
    
      <category term="linux" scheme="http://www.python100.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql数据库优化建议</title>
    <link href="http://www.python100.com/2018/07/31/%E4%BC%98%E5%8C%96_MySQL_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9A%84%E5%BB%BA%E8%AE%AE/"/>
    <id>http://www.python100.com/2018/07/31/优化_MySQL_数据库性能的建议/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:48:00.925Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><p>应用程序、网站和数据库之间的交互会直接影响到应用服务水平的确立。</p><p>这种交互的一个核心组成部分是：各种应用程序如何去查询数据库，以及数据库是如何响应各种请求的。</p><h3 id="MySQL-数据库性能的-7-点必备技巧："><a href="#MySQL-数据库性能的-7-点必备技巧：" class="headerlink" title="MySQL 数据库性能的 7 点必备技巧："></a>MySQL 数据库性能的 7 点必备技巧：</h3><ul><li><p><strong>学习如何使用EXPLAIN</strong></p></li><li><p><strong>创建正确的索引</strong></p></li><li><p><strong>拒绝默认设置</strong></p></li><li><p><strong>将数据库载入内存中</strong></p></li><li><p><strong>使用SSD存储</strong></p></li><li><p><strong>横向扩展</strong></p></li><li><p><strong>追求可视性</strong></p></li></ul><h3 id="一、EXPLAIN-命令"><a href="#一、EXPLAIN-命令" class="headerlink" title="一、EXPLAIN 命令"></a>一、EXPLAIN 命令</h3><p>输出有两种不同的格式：老式的表格形式和较新的、能够提供更为细节化的、结构化的 JSON 文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain format=json select avg(k) from sbtest1 where id between 1000 and 2000 \G</span><br></pre></td></tr></table></figure><h3 id="二、创建正确的索引"><a href="#二、创建正确的索引" class="headerlink" title="二、创建正确的索引"></a>二、创建正确的索引</h3><p>索引是通过减少在数据库里查询时，必须扫描的数据量来提高查询的自身效率。</p><p>在 MySQL 中，索引被用于加快对数据库的访问，并有助于遵循数据库的各种约束（例如 UNIQUE 和 FOREIGN KEY）。</p><p>数据库索引就像书的索引一样，它们的位置信息被保存，并且包含有数据库的主要信息。</p><p>它们是数据位置的一种参考方法或映射，因此索引并不会更改数据库中的任何数据。它们只是指向数据存放的位置而已。</p><p>不过，索引并不总能匹配上任何的负载请求。在系统运行中，您应当不断为查询的上下文环境创建各种索引。</p><p>虽然有着良好索引的数据库会运行更快速，但是如果出现单个索引的缺失，则会拖慢整个数据库的效率。</p><p>因此，我们需要使用 EXPLAIN 来查找缺失的索引，并将其添加上去。</p><p>需要注意的是：不要添加您所不需要的索引，因为不必要的索引会反过来拖慢数据库。</p><h3 id="三、拒绝默认设置"><a href="#三、拒绝默认设置" class="headerlink" title="三、拒绝默认设置"></a>三、拒绝默认设置</h3><p>就像其他任何软件那样，MySQL 也能通过各种可配置的设置，来修改其行为并最终优化其性能。</p><p>同时这些配置的设置经常会被管理员所忽略，并一直保持着默认值的状态。</p><p>为了让 MySQL 获得最佳的性能，了解如何配置 MySQL，以及将它们设置为最适合您的数据库环境的状态是非常重要的。</p><p>在默认情况下，MySQL 是针对小规模的发布、安装进行调优的，而并非真正的生产环境规模。</p><p>因此，通常您需要将 MySQL 配置为使用所有可用的内存资源，并且能允许您的应用程序所需的最大连接数。</p><p>这里有三个有关 MySQL 性能优化的设置，值得您去仔细地配置：</p><h3 id="innodb-buffer-pool-size"><a href="#innodb-buffer-pool-size" class="headerlink" title="innodb_buffer_pool_size"></a><strong>innodb_buffer_pool_size</strong></h3><p>数据和索引被用作缓存的缓冲池。当您的数据库服务器有着大量的系统内存时，可以用到该设置。</p><p>如果您只运行 InnoDB 存储引擎，那么您通常可以分配 80％ 左右的内存给该缓冲池。</p><p>而如果您要运行非常复杂的查询或者您有大量的并发数据库连接，亦或您有非常大的数据表的情况，那么就可能需要将此值下调一个等级，以便为其他的调用分配更多的内存。</p><p>您在设置 InnoDB 缓冲池大小的时候，要确保其设置既不要过大，也不要频繁引起交换（swapping），因为这些绝对会降低您的数据库性能。有一个简单的检查方法就是在“Percona 监控和管理”。</p><p>如果您一开始并没有将 innodb_buffer_pool_size 的值设置正确，也不必担心。</p><p>从 MySQL 5.7 开始，您可以动态地改变 InnoDB 缓冲池的大小，而不需要重新启动数据库服务器了。</p><h3 id="innodb-log-file-size"><a href="#innodb-log-file-size" class="headerlink" title="innodb_log_file_size"></a><strong>innodb_log_file_size</strong></h3><p>这是指单个 InnoDB 日志文件的大小。默认情况下，InnoDB 使用两个值，这样您就可以通过将其增加一倍，来让 InnoDB 获得循环的重做日志空间，以确保交易的持久性。这同时也优化了对数据库的写入性能。</p><p>设置 innodb_log_file_size 的值是很值得推敲的：如果分配了较大的重做空间，那么对于写入密集型的工作负载来说性能会越好。</p><p>但是如果您的系统遭受到断电或其他问题导致崩溃的时候，那么其恢复时间则会越长。</p><p>您可能会问：怎么才能知道自己的 MySQL 性能是否受限于当前的 InnoDB 日志文件大小呢？</p><p>您可以通过查看未实际使用的重做日志空间大小来判定。最简单的方法就是查看“Percona 监控和管理”的 InnoDB 指标仪表板。因此，您的日志文件应该至少比使用量大 20％，从而保持系统处于最佳的性能状态。</p><h3 id="max-connections"><a href="#max-connections" class="headerlink" title="max_connections"></a><strong>max_connections</strong></h3><p>大型应用程序通常需要比默认数量多得多的连接。不同于其他的变量，如果您没能将该值设置正确，您就会碰到性能方面的问题。</p><p>也就是说，如果连接的数量不足以满足您的应用需求，那么应用程序将根本无法连接到数据库，在用户看来就像宕机了一样。由此可见，将它设置正确是非常重要的。</p><p>对于在多台服务器上运行着具有多个组件的复杂应用来说，您想获知到底需要多少个连接是非常困难的。</p><p>幸运的是，MySQL 能够在峰值操作时轻易地获悉所用到的连接数量。通常，您需要确保在应用程序所使用到的最大连接数和可用的最大连接数之间至少有 30％ 的差额。</p><p>查看这些数字的一个简单方法是：在“Percona 监控和管理”的系统概述界面中查看使用 MySQL 连接图。</p><p>还有一点需要记住：如果您的应用程序所创建的连接数量过多，通常会导致数据库运行缓慢。</p><p>在这种情况下，您应该在数据库性能上做文章，而不是简单地允许建立更多的连接。更多的连接会使得潜在的性能问题更加恶化。</p><h3 id="四、将数据库载入内存中"><a href="#四、将数据库载入内存中" class="headerlink" title="四、将数据库载入内存中"></a>四、将数据库载入内存中</h3><p>年来，出现了固态硬盘（SSD）方向上的转变。尽管固态硬盘比传统机械旋臂硬盘快得多，但是它们仍然敌不过将数据存在内存里。</p><p>这种差别不仅来自于存储性能本身，还来自于数据库从磁盘或 SSD 里存取数据时所产生的额外工作。</p><p>随着近年来硬件技术的改进，不管您是运行在云端，还是管理着自己的硬件，将数据库载入内存已经变得可行</p><h3 id="五、使用-SSD-存储"><a href="#五、使用-SSD-存储" class="headerlink" title="五、使用 SSD 存储"></a>五、使用 SSD 存储</h3><p>无论您的数据库是否已被载入内存，您都需要使用快速存储来处理写入操作，并且避免在数据库启动后（重启之后）出现性能问题。这里的快速存储就是指固态硬盘。</p><p>一些所谓的“专家”仍在基于成本和可靠性的基础上，主张使用机械旋臂硬盘。坦率地说，当涉及到数据库操作时，这些建议往往是过时的或是完全错误的。现如今，固态硬盘的性能已经非常卓越、可靠且价格低廉了。</p><p>并非所有的固态硬盘都是同等生产的。对于数据库服务器来说，您应该选用那些专供服务器工作负载、且能精心呵护数据的 SSD。</p><p>例如：防止断电损坏的，而避免使用那些专为台式和笔记本电脑设计的商用固态硬盘。</p><p>通过 NVMe 或英特尔 Optane 技术来直接连接的 SSD 往往能够提供最佳的性能。</p><p>即使远程连接到 SAN、NAS 或云端的块设备上，固态硬盘也能比机械旋臂硬盘提供更为优越的性能。</p><h3 id="六、横向扩展"><a href="#六、横向扩展" class="headerlink" title="六、横向扩展"></a>六、横向扩展</h3><p>即使是性能最高的服务器也有局限性。业界一般用两种方法来进行扩展：纵向和横向。</p><p>纵向扩展意味着购买更多的硬件。这样做不但成本昂贵，而且硬件折旧速度快。</p><p>而横向扩展，则在处理负载方面有如下几点优势：</p><ul><li>您可以从更小型、成本更低的系统中获益。</li><li>横向扩展使得系统的线性扩展更方便、更快捷。</li><li>由于数据库会横跨增长到多个物理机上，横向扩展在保护数据库的同时，消除了硬件单点故障。</li></ul><p>尽管横向扩展有着诸多优势，不过它还是具有一定的局限性。横向扩展需要数据复制，例如基本的 MySQL Replication 或是用于数据同步的 Percona XtraDB 群集。</p><p>但是作为回报，您也会获得更高的性能和可用性。如果您需要更高级的扩展性，那么请考虑使用 MySQL 分片（sharding）。</p><p>另外，您还需要确保连接到群集架构的应用程序可以找到它们所需的数据。这通常是通过诸如 ProxySQL 或 HAProxy 的一些代理服务器和负载平衡器来实现的。</p><p>当然，过早地规划横向扩展，会增加分布式数据库的复杂性。最近发布的 MySQL 8 候选版本已声称自己能够在单一的系统上处理超过 200 万个简单查询。</p><h3 id="七、追求可视性"><a href="#七、追求可视性" class="headerlink" title="七、追求可视性"></a>七、追求可视性</h3><p>可视性是系统设计的最佳境界，MySQL 也不例外。</p><p>一旦完成了 MySQL 环境的搭建、运行并调优，您千万不要认为已经万事大吉了。</p><p>数据库环境既会受到来自系统更改或流量负荷的影响，也会遇到例如流量高峰、应用程序错误以及 MySQL 自身的各种问题。</p><p>为了快速、有效地解决各种问题，您需要建立和实施一些监控机制，从而能获悉数据库环境的状态，并在出现错误时及时分析服务器上的数据。</p><p>因此理想情况就是在系统出现问题或是被用户所察觉之前就做到防范于未然。</p><p>常用的监测工具有：</p><ul><li><strong>MySQL企业监控器（Enterprise Monitor）。</strong></li><li><strong>Monyog。</strong></li><li><strong>具有免费与开源版本的 Percona 监控和管理（PMM）。</strong></li></ul><p>这些工具在监控和故障排除方面提供了很好的操作可视性。</p><p>随着越来越多的公司在大规模生产环境中使用开源的数据库（特别是MySQL）来管理和服务他们的业务数据，他们需要把工作重心放在保持数据库的调优和运行效率上。</p><p>MySQL 的确是一款能够提升您的应用程序和网站性能的优秀数据库，当然您需要通过对它进行调整，以满足业务需求，监测、发现并防止任何瓶颈和性能方面的问题。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;应用程序、网站和数据库之间的交互会直接影响到应用服务水平的确立。&lt;/p&gt;&lt;p&gt;这种交互的一个核心组成部分是：各种应用程序如何去查询数据库，以及数据库
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.python100.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.python100.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql多表查询</title>
    <link href="http://www.python100.com/2018/07/31/MySQL%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>http://www.python100.com/2018/07/31/MySQL多表查询/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:50:35.224Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:35 GMT+0800 (CST) --><hr><h3 id="一使用SELECT子句进行多表查询"><a href="#一使用SELECT子句进行多表查询" class="headerlink" title="一使用SELECT子句进行多表查询"></a>一使用SELECT子句进行多表查询</h3><p><strong>SELECT 字段名 FROM 表1，表2 … WHERE 表1.字段 = 表2.字段 AND 其它查询条件</strong><br>SELECT a.id,a.name,a.address,a.date,b.math,b.english,b.chinese FROM tb_demo065_tel AS b,tb_demo065 AS a WHERE a.id=b.id<br>注:在上面的的代码中，以两张表的id字段信息相同作为条件建立两表关联，但在实际开发中不应该这样使用，最好用主外键约束来实现</p><h3 id="二使用表的别名进行多表查询"><a href="#二使用表的别名进行多表查询" class="headerlink" title="二使用表的别名进行多表查询"></a>二使用表的别名进行多表查询</h3><p>如:SELECT a.id,a.name,a.address,b.math,b.english,b.chinese FROM tb_demo065 a,tb_demo065_tel b WHERE a.id=b.id AND b.id=’$_POST[textid]’<br>SQL语言中，可以通过两种方式为表指定别名<br>第一种是通过关键字AS指定,如<br>SELECT a.id,a.name,a.address,b.math,b.english,b.chinese FROM tb_demo065 AS a,tb_demo065_tel AS b WHERE a.id=b.id<br>第二种是在表名后直接加表的别名实现<br>SELECT a.id,a.name,a.address,b.math,b.english,b.chinese FROM tb_demo065 a,tb_demo065_tel b WHERE a.id=b.id<br>使用表的别名应注意几下几点<br>(1)别名通常是一个缩短了的表名，用于在连接中引用表中的特定列，如果连接中的多个表中有相同的名称列存在，必须用表名或表的别名限定列名<br>(2)如果定义了表的别名就不能再使用表名</p><h3 id="三合并多个结果集"><a href="#三合并多个结果集" class="headerlink" title="三合并多个结果集"></a>三合并多个结果集</h3><p>SQL语言中，可以通过UNION 或 ALL将多个SELECT语句的查询结果合并输出，这两个关键字的使用说明如下：<br>UNION:利用该关键字可以将多个SELECT 语句的查询结果合并输出，并删除重复行<br>ALL:利用该关键字可以将多个SELECT 语句的查询结果合并输出，但不会删除重复行<br>在使用UNION或ALL关键字将多个表合并输出时，查询结果必须具有相同的结构并且数据类型必须兼容,另外使用UNION时两张表的字段数量也必须相同，否则会提示SQL语句有错误。<br>e.x:SELECT id,name,pwd FROM tb_demo067 UNION SELECT uid,price,date FROM tb_demo067_tel</p><h3 id="四简单嵌套查询"><a href="#四简单嵌套查询" class="headerlink" title="四简单嵌套查询"></a>四简单嵌套查询</h3><p>子查询:子查询是一个SELECT查询，返回单个值且嵌套在SELECT、INSERT、UPDATE和DELETE语句或其它查询语句中，任何可以使用表达式的地方都可以使用子查询.<br>SELECT id,name,sex,date FROM tb_demo068 WHERE id in(SELECT id FROM tb_demo068 WHERE id=’$_POST[test]’)<br>内连接：把查询结果作为WHERE子句的查询条件即称为内连接</p><h3 id="五复杂的嵌套查询"><a href="#五复杂的嵌套查询" class="headerlink" title="五复杂的嵌套查询"></a>五复杂的嵌套查询</h3><p>多表之间的嵌套查询可以通过谓词IN实现，语法格式如下:<br>test_expression[NOT] IN{<br>subquery<br>}<br>参数说明：test_expression指SQL表达式，subquery包含某结果集的子查询<br>多表嵌套查询的原理:无论是多少张表进行嵌套，表与表之间一定存在某种关联，通过WHERE子句建立此种关联实现查询</p><h3 id="六嵌套查询在查询统计中的应用"><a href="#六嵌套查询在查询统计中的应用" class="headerlink" title="六嵌套查询在查询统计中的应用"></a>六嵌套查询在查询统计中的应用</h3><p>实现多表查询时，可以同时使用谓词ANY、SOME、ALL,这些谓词被称为定量比较谓词，可以和比较运算符联合使用，判断是否全部返回值都满足搜索条件.SOME和ANY谓词是存在量的，只注重是否有返回值满足搜索条件，这两个谓词的含义相同，可以替换使用;ALL谓词称为通用谓词，它只关心是否有谓词满足搜索要求.<br>SELECT * FROM tb_demo069_people WHERE uid IN(SELECT deptID FROM tb_demo069_dept WHERE deptName=’$_POST[select]’)<br>SELECT a.id,a.name FROM tb_demo067 AS a WHERE id&lt;3)</p><blockquote><p>ANY 大于子查询中的某个值</p></blockquote><blockquote><p>=ANY 大于等于子查询中的某个值<br>&lt;=ANY 小于等于子查询中的某个值<br>=ANY 等于子查询中的某个值<br>!=ANY或&lt;&gt;ANY 不等于子查询中的某个值<br>ALL 大于子查询中的所有值</p></blockquote><blockquote><p>=ALL 大于等于子查询中的所有值<br>&lt;=ALL 小于等于子查询中的所有值<br>=ALL 等于子查询中的所有值<br>!=ALL或&lt;&gt;ALL 不等于子查询中的所有值</p></blockquote><h3 id="七-使用子查询作派生的表"><a href="#七-使用子查询作派生的表" class="headerlink" title="七.使用子查询作派生的表"></a>七.使用子查询作派生的表</h3><p>在实际项目开发过程中经常用到从一个信息较为完善的表中派生出一个只含有几个关键字段的信息表，通过子查询就可以来实现这一目标,如<br>SELECT people.name,people.chinese,people.math,people.english FROM (SELECT name,chinese,math,english FROM tb_demo071) AS people<br>注:子查询应遵循以下规则:<br>(1)由比较运算符引入的内层子查询只包含一个表达式或列名，在外层语句中的WHERE子句内命名的列必须与内层子查询命名的列兼容<br>(2)由不可更改的比较运算符引入的子查询(比较运算符后面不跟关键字ANY或ALL)不包括GROUP BY 或 HAVING子句，除非预先确定了成组或单个的值<br>(3)用EXISTS引入的SELECT列表一般都由*组成，不必指定列名<br>(4)子查询不能在内部处理其结果</p><h3 id="八使用子查询作表达式"><a href="#八使用子查询作表达式" class="headerlink" title="八使用子查询作表达式"></a>八使用子查询作表达式</h3><p>SELECT (SELECT AVG(chinese)FROM tb_demo071),(SELECT AVG(english)FROM tb_demo071),(SELECT AVG(math)FROM tb_demo071) FROM tb_demo071<br>注：在使用子查询时最好为列表项取个别名，这样可以方便用户在使用mysql_fetch_array()函数时为表项赋值,如<br>SELECT (SELECT AVG(chinese) FROM tb_demo071) AS yuwen ,(SELECT AVG(english) FROM tb_demo071) AS yingyu,(SELECT AVG(math) FROM tb_demo071) AS shuxue FROM tb_demo071</p><h3 id="九使用子查询关联数据"><a href="#九使用子查询关联数据" class="headerlink" title="九使用子查询关联数据"></a>九使用子查询关联数据</h3><p>SELECT * FROM tb_demo072_student WHERE id=(SELECT id FROM tb_demo072_class WHERE className = ‘$_POST[text]’)</p><h3 id="十多表联合查询"><a href="#十多表联合查询" class="headerlink" title="十多表联合查询"></a>十多表联合查询</h3><p>利用SQL语句中的UNION，可以将不同表中符合条件的数据信息显示在同一列中。<br>e.x:SELECT <em>FROM tb_demo074_student UNION SELECT </em>FROM tb_demo074_fasten<br>注:使用UNION时应注意以下两点：<br>(1)在使用UNION运算符组合的语句中，所有选择列表的表达式数目必须相同，如列名、算术表达式及聚合函数等<br>(2)在每个查询表中，对应列的数据结构必须一样。</p><h3 id="十一对联合后的结果进行排序"><a href="#十一对联合后的结果进行排序" class="headerlink" title="十一对联合后的结果进行排序"></a>十一对联合后的结果进行排序</h3><p>为了UNION的运算兼容，要求所有SELECT语句都不能有ORDER BY语句，但有一种情况例外，那就是在最后一个SELECT语句中放置ORDER BY 子句实现结果的最终排序输出。<br>e.x:SELECT <em>FROM tb_demo074_student UNION SELECT </em>FROM tb_demo074_fasten ORDER BY id<br>使用UNION条件上相对比较苛刻，所以使用此语句时一定要注意两个表项数目和字段类型是否相同</p><h3 id="十二条件联合语句"><a href="#十二条件联合语句" class="headerlink" title="十二条件联合语句"></a>十二条件联合语句</h3><p>SELECT <em>FROM tb_demo076_BEIJING GROUP BY name HAVING name=’人民邮电出版社’ OR name=’机械工业出版社’ UNION SELECT </em>FROM tb_demo076_BEIJING GROUP BY name HAVING name &lt;&gt;’人民邮电出版社’ AND name &lt;&gt;’机械工业再版社’ ORDER BY id<br>上面语句应用了GROUP BY分组语句和HAVING语句实现条件联合查询。其实现目的是先保证将’人民邮电出版社’和’机械工业出版社’始终位于名单最前列，然后再输出其它的出版社</p><h3 id="十三简单内连接查询"><a href="#十三简单内连接查询" class="headerlink" title="十三简单内连接查询"></a>十三简单内连接查询</h3><p>SELECT filedlist FROM table1 [INNER] JOIN table2 ON table1.column1 = table2.column1<br>其中，filedlist是要显示的字段,INNER表示表之间的连接方式为内连接，table1.column1=table2.column1用于指明两表间的连接条件，如:<br>SELECT a.name,a.address,a.date,b.chinese,b.math,b.english FROM tb_demo065 AS a INNER JOIN tb_demo065_tel AS b on a.id=b.id</p><h3 id="十四复杂内连接查询"><a href="#十四复杂内连接查询" class="headerlink" title="十四复杂内连接查询"></a>十四复杂内连接查询</h3><p>复杂的内连接查询是在基本的内连接查询的基础上再附加一些查询条件，如:<br>SELECT a.name,a.address,a.date,b.chinese,b.math,b.english FROM tb_demo065 AS a INNER JOIN tb_demo065_tel AS b on a.id=b.id WHERE b.id=(SELECT id FROM tb_demo065 WHERE tb_demo065.name=’$_POST[text]’)<br>总之，实现表与表之间的关联的本质是两表之间存在共同的数据项或者相同的数据项，通过WHERE 子句或内连接INNER JOIN … ON 语句将两表连接起来，实现查询</p><h3 id="十五使用外连接实现多表联合查询"><a href="#十五使用外连接实现多表联合查询" class="headerlink" title="十五使用外连接实现多表联合查询"></a>十五使用外连接实现多表联合查询</h3><p>(1)LEFT OUTER JOIN表示表之间通过左连接方式相互连接，也可简写成LEFT JOIN,它是以左侧的表为基准故称左连接，左侧表中所有信息将被全部输出，而右侧表信息则只会输出符合条件的信息，对不符合条件的信息则返回NULL<br>e.x:SELECT a.name,a.address,b.math,b.english FROM tb_demo065 AS A LEFT OUTER JOIN tb_demo065_tel AS b ON a.id=b.id<br>(2)RIGHT OUTER JOIN表示表之间通过右连接方式相互连接，也可简写成RIGHT JOIN,它是以右侧的表为基准故称右连接，右侧表中所有信息将被全部输出，而左侧表信息则只会输出符合条件的信息，对不符合条件的信息则返回NULL<br>E.X:SELECT a.name,a.address,b.math,b.english FROM tb_demo065 AS A RIGHT OUTER JOIN tb_demo065_tel AS b ON a.id=b.id</p><h3 id="十六利用IN或NOTIN关键字限定范围"><a href="#十六利用IN或NOTIN关键字限定范围" class="headerlink" title="十六利用IN或NOTIN关键字限定范围"></a>十六利用IN或NOTIN关键字限定范围</h3><p>e.x:SELECT * FROM tb_demo083 WHERE code IN(SELECT code FROM tb_demo083 WHERE code BETWEEN ‘$_POST[text1]’ AND ‘$_POST[text2]’)<br>利用IN可指定在范围内查询，若要求在某范围外查询可以用NOT IN代替它</p><h3 id="十七由IN引入的关联子查询"><a href="#十七由IN引入的关联子查询" class="headerlink" title="十七由IN引入的关联子查询"></a>十七由IN引入的关联子查询</h3><p>e.x:SELECT * FROM tb_demo083 WHERE code IN(SELECT code FROM tb_demo083 WHERE code = ‘$_POST[text]’)</p><h3 id="十八利用HAVING语句过滤分组数据"><a href="#十八利用HAVING语句过滤分组数据" class="headerlink" title="十八利用HAVING语句过滤分组数据"></a>十八利用HAVING语句过滤分组数据</h3><p>HAVING子句用于指定组或聚合的搜索条件，HAVING通常与GROUP BY 语句一起使用，如果SQL语句中不含GROUP BY子句，则HAVING的行为与WHERE子句一样.<br>e.x:SELECT name,math FROM tb_demo083 GROUP BY id HAVING math &gt; ‘95’</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:35 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;一使用SELECT子句进行多表查询&quot;&gt;&lt;a href=&quot;#一使用SELECT子句进行多表查询&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.python100.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.python100.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>DevOps是什么</title>
    <link href="http://www.python100.com/2018/07/31/DevOps%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://www.python100.com/2018/07/31/DevOps是什么/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:58:10.278Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><p><strong>DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称</strong>，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。</p><p>它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p><p>它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作。</p><p><strong>DevOps 是一种工程模式，本质上是一种分工，通过对开发、运维、测试，配管等角色职责的分工，实现工程效率最大化，进而满足业务的需求。</strong></p><p><strong>DevOps的核心是角色的分工</strong>，而不是组织架构变化，垂直化的组织架构不代表可以实现DevOps所需要的分工模式，横向的组织架构也不代表传统的分工模式。</p><p><strong>DevOps的目标是工程效率最大化</strong>，它本身也只是一种方法论，是为了实现工程效率最大化的目标而存在的。</p><p><strong>DevOps与传统模式的区别</strong></p><p>传统分工模式下，PD将需求提出来，开发者根据需求写代码，然后告诉SCM，SCM拿着代码去打包，打包后告诉QA，QA测试完成后通知运维OPS上线，OPS进行上线部署，最后整个需求得到release。</p><p><strong>它的优势在于</strong>：分工与责任清晰，质量有保障，层层制约，容易把控。</p><p>它的劣势也很明显：沟通成本与等待成本高，每一个环节都有成为瓶颈的风险，比如DEV知道怎样写代码，但QA也需要了解需求才能知道怎么做测试，OPS也需要了解需求维持线上稳定性，OPS负责交付，容易演变成擦屁股的角色，包括日常出现的bug。</p><p>在DevOps分工模式下，一切都改变了，不再是每个人做完自己的事情然后交给下一个人。这个分工模式下，开发通过工具驱动所有流程运转向前走，比如开发写完代码通过工具驱动自动化打包，自动化测试，自动化部署或升级，还会配备监控；SCM、OPS和QA等在工具的外围，确保在工具中的每一个环节可以正常运转，它们支撑工具的目的是确保DEV可以使用工具完成人肉完成的事情，这是决策的变化，还要保证工具中的几个模块可以支撑最新的业务变化，当业务有了更新的变化时，须保证工具可以支撑开发。</p><p>DevOps分工模式的好处很明显：可以减少沟通成本与等待风险，降低正常需求交付所需时间，DEV负责交付，避免交付扯皮。</p><p>DevOps分工模式的劣势也很突出：每个环节参与角色较多，风险较高，对于业务形态比较多的企业较明显，工具支撑多种业务形态的成本是非常高的，当工具搞不定时，需要人肉补位保证业务发布，如果补位较多，那么DevOps分工就失败了；专业度会有降低，工具只能支持在精确输入的情况下以非常精确的方式完成一件固定的事情，一旦输入有变化而超出规则，该环节就比较麻烦了，工具的专业提升比人要慢的多；DEV权利过大，容易军阀化。</p><p>DevOps的难点和需要解决的问题</p><p>寻找平衡点</p><p>DevOps是为了追求工程效率最大化而存在的，但是工程效率和稳定性的目标在大部分场景下都是相悖的，如何能够在工程效率提升的前提下，保证稳定性不出问题？</p><p>传统分工模式是OPS团队负责，在DevOps分工模式中已经没有OPS团队了，只能开发团队负责，当一个团队同时负责两个相互有冲突的case时，该怎么办呢？如果分成两部分人分别负责业务KPI和稳定性KPI，就回到了传统的分工模式。</p><p>责权划分</p><p>对于开发者而言，主业是coding，其它包括打包、测试、发布都是辅业，它是工具的使用者，并不能完全将所有事情做得完美，在除coding以外的所有环节中，责任和分工要怎么来分，除了开发以外的事情要占用开发人员多少精力，才能保证DEV使用顺畅，跟上公司业务发展？</p><p>其中核心是工具，工具是将二者粘合在一起的，工具起到了赋能和粘合的作用，工具还须可介入，需要人肉补位；另外，工具的进化要运维团队、测试团队和SCM团队来负责，工具自己要足够开放，才能让其它团队可以不断优化某一环节；工具也要保证可持续成长，跟上时代的发展。</p><p>制约与考核</p><p>打破原先的平衡以后，新的平衡如何建立？重新建立平衡是需要时间的，DEV在工程中话语权加大，权利是一定会被制约的，不是内部，就是外部市场。</p><p>每一个问题都要根据公司的实际情况寻找一个平衡点，找到责权划分，怎样去考核和制约，只有将这三个点解完，才可能活下来将分工模式持续跑下去。</p><p>DevOps怎么衡量？</p><p>DevOps可以由四个角度做衡量：</p><p>工程效率：从某一个开发的团队接到需求，到需求交付上线的时间有多长。工程效率能够提升多少代表DevOps发挥作用的大小；</p><p>稳定性：当稳定性没有保证时，效率越高死的越快；<br>非研发工作占比：当占比非常大时，离失败就不远了；</p><p>业务规模与运维人员比例：谷歌的每一个SRE也要管理2000台机器的业务。<br>总结</p><ol><li>实现自动化运维后，很多运维人员就会面临失业，但这是时代发展的必然结果，我们只需欣然接受；</li><li>DevOps没有最佳实践，我们该更关注一些案例的环境和业务背景，DevOps本身不是目标，是一个方法，一个理论；</li><li>DevOps和传统模式没有好坏之分，只有适不适合。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称&lt;/strong&gt;，用于促进开发（应
      
    
    </summary>
    
      <category term="linux" scheme="http://www.python100.com/categories/linux/"/>
    
    
      <category term="DevOps" scheme="http://www.python100.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>mysql日志查询</title>
    <link href="http://www.python100.com/2018/07/31/mysql%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E9%9B%86/"/>
    <id>http://www.python100.com/2018/07/31/mysql日志查询集/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:49:29.453Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><h2 id="mysql日志查询"><a href="#mysql日志查询" class="headerlink" title="mysql日志查询"></a>mysql日志查询</h2><h3 id="binlog介绍"><a href="#binlog介绍" class="headerlink" title="binlog介绍"></a>binlog介绍</h3><ol><li>binlog,即二进制日志,它记录了数据库上的所有改变.</li><li>改变数据库的SQL语句执行结束时,将在binlog的末尾写入一条记录,同时通知语句解析器,语句执行完毕.</li><li>binlog格式</li></ol><h3 id="登录到mysql查看binlog"><a href="#登录到mysql查看binlog" class="headerlink" title="登录到mysql查看binlog"></a>登录到mysql查看binlog</h3><p>只查看第一个binlog文件的内容 show binlog events;</p><p>查看指定binlog文件的内容 show binlog events in ‘mysql-bin.000002’;</p><p>查看当前正在写入的binlog文件 show master status\G</p><p>获取binlog文件列表 show binary logs;</p><h3 id="用mysqlbinlog工具查看"><a href="#用mysqlbinlog工具查看" class="headerlink" title="用mysqlbinlog工具查看"></a>用mysqlbinlog工具查看</h3><p>本地查看</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 基于开始/结束时间 </span><br><span class="line">mysqlbinlog --start-datetime=<span class="string">'2013-09-10 00:00:00'</span> --stop-datetime=<span class="string">'2013-09-10 01:01:01'</span> -d 库名 二进制文件</span><br><span class="line">&gt; 基于pos值</span><br><span class="line">mysqlbinlog --start-postion=<span class="number">107</span> --stop-position=<span class="number">1000</span> -d 库名 二进制文件</span><br><span class="line">&gt; 转换为可读文本</span><br><span class="line">mysqlbinlog –base64-output=DECODE-ROWS -v -d 库名 二进制文件</span><br></pre></td></tr></table></figure><p>远程查看</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 指定开始/结束时间,并把结果重定向到本地t.binlog文件中.</span><br><span class="line">mysqlbinlog -u username -p password -hl-db1.dba.beta.cn6.qunar.com -P3306 \</span><br><span class="line">--read-from-remote-server --start-datetime=<span class="string">'2013-09-10 23:00:00'</span> --stop-datetime=<span class="string">'2013-09-10 23:30:00'</span> mysql-bin.<span class="number">000001</span> &gt; t.binlog</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h2 id=&quot;mysql日志查询&quot;&gt;&lt;a href=&quot;#mysql日志查询&quot; class=&quot;headerlink&quot; title=&quot;mysql日志查询&quot;&gt;
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.python100.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.python100.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>常用的nginx规则总结</title>
    <link href="http://www.python100.com/2018/07/31/%E5%AE%9E%E7%94%A8%E7%9A%84Nginx%E8%A7%84%E5%88%99/"/>
    <id>http://www.python100.com/2018/07/31/实用的Nginx规则/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:48:29.380Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>大家都知道Nginx有很多功能模块，比如反向代理、缓存等，这篇文章总结下我们这些年实际环境中那些有用的Nginx规则和模块，大部分是用法的概括及介绍，具体细节在实际配置时再自行google。</p><h2 id="2-内置语法"><a href="#2-内置语法" class="headerlink" title="2. 内置语法"></a>2. 内置语法</h2><p>先介绍Nginx默认已支持的内置功能，靠这些基本就满足大部分的web服务需求。</p><h3 id="2-1-proxy代理"><a href="#2-1-proxy代理" class="headerlink" title="2.1 proxy代理"></a>2.1 proxy代理</h3><p>proxy常用于两类应用场景，一类是中转，如异地科学的上网方式，另外一类是到后端服务的负载均衡方案。</p><p>用反向代理时候，需要特别注意里面的域名默认是在nginx启动时候就解析了，除非reload否则一直用的是当初解析的域名，也就是说不能动态解析。</p><p>但这个问题是可以通过别的模块或者用内置字典变量方式来解决。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; resolver 114.114.114.114;</span><br><span class="line">&gt; server &#123;</span><br><span class="line">&gt;     location / &#123;</span><br><span class="line">&gt;         set $servers github.com;</span><br><span class="line">&gt;         proxy_pass http://$servers;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-1-1-中转"><a href="#2-1-1-中转" class="headerlink" title="2.1.1 中转"></a>2.1.1 中转</h4><p>针对某个域名进行中转：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; server &#123;</span><br><span class="line">&gt; listen 172.16.10.1:80;</span><br><span class="line">&gt;     server_name pypi.python.org;</span><br><span class="line">&gt;     location ~ /simple &#123;</span><br><span class="line">&gt;         proxy_set_header Host $http_host;</span><br><span class="line">&gt;         proxy_redirect off;</span><br><span class="line">&gt;         proxy_pass http://pypi.python.org;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>注意如果是前后端域名不一样的话需要处理proxy_redirect的301跳转之类的显示，否则在跳转时候会跳转到proxy_pass的域名。</p><p>另外可以直接代理所有80端口的http流量：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; server &#123;</span><br><span class="line">&gt;     listen 80;</span><br><span class="line">&gt;     server_name _;</span><br><span class="line">&gt;     resolver 114.114.114.114;</span><br><span class="line">&gt;     set $URL $host;</span><br><span class="line">&gt;     location / &#123;</span><br><span class="line">&gt;         proxy_pass http://$URL;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果是想代理https的站点也不是不可能，只是需要自行处理CA证书导入即可，而且经过https中转的流量对nginx是透明的，也就是有证书的时候做窃听和劫持的情况。</p><h4 id="2-1-2-负载均衡"><a href="#2-1-2-负载均衡" class="headerlink" title="2.1.2 负载均衡"></a>2.1.2 负载均衡</h4><p>这是代理的另外一个常见用法，通过upstream到多个后端，可以通过weight来调节权重或者backup关键词来指定备份用的后端，通常默认就可以 了，或者可以指定类似ip_hash这样的方式来均衡，配置很简单，先在http区域添加upstream定义：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; upstream backend &#123;</span><br><span class="line">&gt;     ip_hash;</span><br><span class="line">&gt;     server backend1.example.com weight=5;</span><br><span class="line">&gt;     server backend2.example.com weight=5;;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>然后在server里面添加proxy_pass：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; location / &#123;</span><br><span class="line">&gt;     proxy_pass http://backend;</span><br><span class="line">&gt;     proxy_http_version 1.1;</span><br><span class="line">&gt;     proxy_set_header Connection &quot;&quot;;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>做负载均衡的时候可以智能识别后端服务器状态，虽然可以智能地proxy_next_upstream到另外的后端，但还是会定期损失一些正常的“尝试性”的连接，比如过了max_fails 次尝试之后，休息fail_timeout时间，过了这个时间之后又会去尝试，这个时候可以使用第三方的upstream_check模块来在后台定期地自动探索，类似这样：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; check interval=3000 rise=2 fall=5 timeout=2000 type=http;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这样替代用户正常的连接来进行尝试的方式进一步保障了高可用的特性。</p><p>还有就是在做前端代理的时候也是这样的方式，直接proxy_pass到后端即可，比如CDN的场景。</p><h3 id="2-2-防盗链"><a href="#2-2-防盗链" class="headerlink" title="2.2 防盗链"></a>2.2 防盗链</h3><p>普通的防盗链是通过referer来做，比如：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; location ~* \.(gif|jpg|png|bmp)$ &#123;</span><br><span class="line">&gt;     valid_referers none blocked *.example.com server_names ~\.google\. ~\.baidu\.;</span><br><span class="line">&gt;     if ($invalid_referer) &#123;</span><br><span class="line">&gt;         return 403;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>再精细一点的就是URL加密，针对一些用户IP之类的变量生成一个加密URL通常是针对文件下载时候用到，可以通过openresty来写lua脚本或者是accesskey之类的模块来实现。</p><h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><p>nginx里面支持正则匹配和变量配置，默认的变量比如remote_addr、request_filename、query_string、server_name之类的，这些组合在一起可以做很多规则，或者还有日志里面status、http_cookie等。</p><p>还有在进行多域名配置时候可以用通配符，比如：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; server_name ~^(www\.)?(.+)$;</span><br><span class="line">&gt; root /data/web/$2;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这样就实现了自动进行域名的目录指派。</p><p>变量方面，比如配置变量a=1：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; set $a 1;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>下面这个案例配合if判断来做有更大的用处。</p><h3 id="2-4-if判断"><a href="#2-4-if判断" class="headerlink" title="2.4 if判断"></a>2.4 if判断</h3><p>nginx里面支持一些简单的if判断，但是没有多重逻辑的语法，多个判断条件用起来需要结合变量的方式来实现，比如允许ip地址为10.10.61段和和192.168.100段的用户访问，其余的拒绝，返回405状态码：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; set $err 0;</span><br><span class="line">&gt;     if ( $remote_addr ~ 10.10.61.)&#123;</span><br><span class="line">&gt;         set $err 0;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     if ( $remote_addr ~ 192.168.100.)&#123;</span><br><span class="line">&gt;         set $err 0;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     if ( $err = 1)&#123;</span><br><span class="line">&gt;         return 405;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这样通过一个err变量比较巧妙实现了需求。</p><h3 id="2-5-error-page"><a href="#2-5-error-page" class="headerlink" title="2.5 error_page"></a>2.5 error_page</h3><p>有用到后端proxy的地方需要加上这句话才可以传到状态码到nginx：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; fastcgi_intercept_errors on;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>具体配置一般是配置到具体的错误URL页面，比如：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; #返回具体状态码</span><br><span class="line">&gt; error_page 404 403 /4xx.html</span><br><span class="line">&gt; #返回200状态码</span><br><span class="line">&gt; error_page 404 403 =200  /error.html</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>或者采用callback的方式统一做处理：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; error_page 404 403 = @fallback; </span><br><span class="line">&gt; location @fallback &#123;</span><br><span class="line">&gt;     proxy_pass http://backend;</span><br><span class="line">&gt;     access_log /data/logs/404_error.log access;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这样在重定向时不会改变URL，然后把404页面直接返回。</p><h3 id="2-6-rewrite"><a href="#2-6-rewrite" class="headerlink" title="2.6 rewrite"></a>2.6 rewrite</h3><p>rewrite做一些301、302之类的跳转，同时也可以在CDN前端做“去问号”缓存的效果。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; location /db.txt &#123;</span><br><span class="line">&gt;     rewrite (.*) $1? break;</span><br><span class="line">&gt;     include proxy.conf;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>另外最常见的跳转写法：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rewrite ^/game/(.*) /$1;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>把/game/test跳转为/test的效果，注意这样是没有状态码的，如果访问正常就直接返回200状态码。</p><p>可以在后面加个permanent参数，就变为了301 Moved Permanently，或者添加redirect改为302跳转。</p><p>同理，还可以进行多个正则匹配进行URL重组，比如：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rewrite ^/download/(.*)/lastest/(.*)$ /file/$1?ver=$2 break;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-7-日志字段"><a href="#2-7-日志字段" class="headerlink" title="2.7 日志字段"></a>2.7 日志字段</h3><p>想针对每个连接进行日志留档，可以在nginx日志那里配置好字段，比如记录cookie之类的数据。</p><p>在log_format字段里面加入$http_cookie变量即可。</p><p>另外post的数据可以永久保留在文件里面，比如用来做http的日志备份，包括get和post的原始数据，把这个值开启即可：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; client_body_in_file_only  on;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>然后post的数据就会保存在nginx/client_body_temp文件夹里面。</p><h3 id="2-8-internal关键词"><a href="#2-8-internal关键词" class="headerlink" title="2.8 internal关键词"></a>2.8 internal关键词</h3><p>这个关键词很少见，但有时候是很有用的，比如在有很多规则时候，突然需要针对某个目录转为nginx内部处理。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; location ^~ /upload/down/ &#123;</span><br><span class="line">&gt; alias /data/web/dts/dtsfile/down/;</span><br><span class="line">&gt; internal;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-9-try-files"><a href="#2-9-try-files" class="headerlink" title="2.9 try_files"></a>2.9 try_files</h3><p>字面意思是尝试，后面可以接多个目录或者文件，比如kohana框架：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; try_files $uri /index.php?$query_string;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>先看是否有URL这个文件，没有的话再调用index.php来处理，或者支持状态码处理：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; try_files /foo /bar/ =404;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>没有这两个文件的话返回404状态。</p><h3 id="2-10-auth认证"><a href="#2-10-auth认证" class="headerlink" title="2.10 auth认证"></a>2.10 auth认证</h3><p>可以做简单的用户登录认证方式，其中的passwd_file得通过apache的htpasswd命令来生成。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; auth_basic &quot;Restricted&quot;;</span><br><span class="line">&gt; auth_basic_user_file passwd_file;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>认证通过之后每次访问会在头部添加Authorization字段包含用户名密码的base64加密密文给服务端。</p><h3 id="2-11-gzip"><a href="#2-11-gzip" class="headerlink" title="2.11 gzip"></a>2.11 gzip</h3><p>普通的线上web站点gzip压缩是必须要开的，压缩一些文本类型的文件再返回给用户。</p><p>注意必须手动指定全需要压缩的类型，比如css、js之类的，线上配置如下：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; gzip on;</span><br><span class="line">&gt; gzip_min_length  2048;</span><br><span class="line">&gt; gzip_buffers     4 16k;</span><br><span class="line">&gt; gzip_vary   on;</span><br><span class="line">&gt; gzip_http_version 1.1;</span><br><span class="line">&gt; gzip_types  text/plain  text/css text/xml application/xml application/javascript application/x-javascript ;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-12-mime配置"><a href="#2-12-mime配置" class="headerlink" title="2.12 mime配置"></a>2.12 mime配置</h3><p>很久以前基本是忽略这个配置，但手游流行之后就发现异常了，需要让手机浏览器知道返回的apk后缀是什么类型，否则类似IE浏览器会以zip后缀返回，需要加上：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; application/vnd.android.package-archive apk;</span><br><span class="line">&gt; application/iphone pxl ipa;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-13-限速"><a href="#2-13-限速" class="headerlink" title="2.13 限速"></a>2.13 限速</h3><p>限速包括限制请求的并发数和请求的下载速度。</p><p>简单的限制某个线程的下载速度就直接加上一句话就可以了：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; limit_rate 1024k;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>要限制某个IP的并发数之类的就需要用ngx_http_limit_req_module和ngx_http_limit_conn_module模块了，不过是默认就编译好的。</p><p>比如使用一个 10M 大小的状态缓存区，针对每个IP每秒只接受20次的请求：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; limit_req_zone $binary_remote_addr zone=NAME:10m rate=20r/s;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-14-location匹配"><a href="#2-14-location匹配" class="headerlink" title="2.14 location匹配"></a>2.14 location匹配</h3><p>location匹配有多种方式，常见的比如</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; location  = / </span><br><span class="line">&gt; location  / </span><br><span class="line">&gt; location ^~ /test&#123;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>是有优先级的，直接 ”=” 的优先级是最高的，一般就用”~”这个符号来匹配php就好了，不过是区分了大小写的：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; location ~ .*\.php$</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-15-文件缓存"><a href="#2-15-文件缓存" class="headerlink" title="2.15 文件缓存"></a>2.15 文件缓存</h3><p>返回给用户的文件一般都配置了过期时间，让浏览器缓存起来。</p><p>比如缓存14天：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; expires 14d;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>针对某些特殊的文件就需要location匹配之后进行禁止缓存配置：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; add_header Cache-Control no-cache;</span><br><span class="line">&gt; add_header Cache-Control no-store;</span><br><span class="line">&gt; expires off;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-16-缓存文件"><a href="#2-16-缓存文件" class="headerlink" title="2.16 缓存文件"></a>2.16 缓存文件</h3><p>nginx可以作为ATS这样的缓存服务器来缓存文件，配置也比较简单，不过我们很少用，除非一些特殊的场合，参考配置：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; #先在全局下面定义好缓存存放的目录</span><br><span class="line">&gt; proxy_cache_path  /data/cache/ levels=1:2 keys_zone=cache_one:10m inactive=7d max_size=10g;</span><br><span class="line">&gt; proxy_temp_path   /data/cache/proxy_temp_path;</span><br><span class="line">&gt; proxy_cache_key   $host$uri$is_args$args;</span><br><span class="line">&gt; #然后在server里面的location匹配好目的文件，加入下一段即可</span><br><span class="line">&gt; proxy_cache cache_one;</span><br><span class="line">&gt; proxy_cache_valid 200 304 24h;</span><br><span class="line">&gt; proxy_cache_valid any 10m;</span><br><span class="line">&gt; proxy_pass https://$host;</span><br><span class="line">&gt; proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">&gt; add_header  Nginx-Cache &quot;$upstream_cache_status&quot;; 3. 内置模块</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-内置模块"><a href="#3-内置模块" class="headerlink" title="3. 内置模块"></a>3. 内置模块</h2><p>nginx含有大量的模块可以支持多种复杂的需求，比如源码目录src/http/modules里面就有很多c模块的代码，或者直接通过./configure –help|grep module来查看有哪些内置模块，编译时候直接加上就可以了。</p><p>除了nginx内置的模块，网络上还有很多第三方的模块，可以通过编译时候加参数–add-module=PATH指定模块源码来编译。</p><p>下面介绍一些我们线上用过而且比较赞的内置模块。</p><h3 id="3-1-stream"><a href="#3-1-stream" class="headerlink" title="3.1 stream"></a>3.1 stream</h3><p>端口转发的模块，从nginx1.9版本才开始支持，包含tcp和udp的支持，和IPTABLES相比这个虽然是应用层，会监听端口，但是配置起来很方便，比IPTABLES灵活，在tcp模块下面添加类似vhost的server就可以了，方便自动化管理，参考配置：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; server &#123;</span><br><span class="line">&gt;     listen PORT;</span><br><span class="line">&gt;     proxy_pass IP:PORT;</span><br><span class="line">&gt;     access_log /data/logs/tcp/PORT.log;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-2-http-realip-module"><a href="#3-2-http-realip-module" class="headerlink" title="3.2 http_realip_module"></a>3.2 http_realip_module</h3><p>nginx反向代理之后，如何让后端web直接获取到的IP不是反向代理的iP，而是直接获取到用户的真实IP呢，就需要这个模块了，不需要代码那里再做类似X-Real-IP的变量特殊判断。</p><h3 id="3-3-http-slice-module"><a href="#3-3-http-slice-module" class="headerlink" title="3.3 http_slice_module"></a>3.3 http_slice_module</h3><p>在做CDN时候可以用到，让一个大文件分片，分成多个小文件通过206断点续传到后端，然后再组合起来，避免大文件直接回源导致多副本和多次回源的问题。</p><h3 id="3-4-http-secure-link-module"><a href="#3-4-http-secure-link-module" class="headerlink" title="3.4 http_secure_link_module"></a>3.4 http_secure_link_module</h3><p>前面说到的防盗链可以用这个来做，但是这个一般是针对那种文件下载时候用到的，比如从网页下载时候，服务端生成一个加密URL给用户，然后这个URL有过期时间之类的，避免此URL被多次分享出去，不过普通的素材加载还是用普通的防盗链即可。</p><h3 id="3-5-http-sub-module"><a href="#3-5-http-sub-module" class="headerlink" title="3.5 http_sub_module"></a>3.5 http_sub_module</h3><p>替换响应给用户的内容，相对于sed之后再返回，比如可以在需要临时全局修改网站背景或者title时候可以一次性处理好。</p><h2 id="4-扩展项目"><a href="#4-扩展项目" class="headerlink" title="4. 扩展项目"></a>4. 扩展项目</h2><p>简单介绍下大名鼎鼎的两个基于nginx的扩展项目，也是我们线上有很多地方用到的。</p><h3 id="4-1-openresty"><a href="#4-1-openresty" class="headerlink" title="4.1 openresty"></a>4.1 openresty</h3><p>集成lua脚本，几乎可以完成任何普通web相关的需求。</p><p>比如URL加密进行防劫持和防盗链，服务端动态生成一串aes加密的URL给CDN，CDN的openresty解密之后用普通的URL转发到后端，然后再返回给用户正确的内容。</p><h3 id="4-2-tengine"><a href="#4-2-tengine" class="headerlink" title="4.2 tengine"></a>4.2 tengine</h3><p>淘宝的nginx修改版，实现了很多nginx的收费功能或者是特殊功能，比如动态加载、concat合并请求，动态解析等。</p><p>我们python开发的后台基本都是用的这个版本，主要是利用了concat的合并素材的功能。</p><h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h2><p>Nginx是个非常实用软件，部分功能已经超越了普通的web服务定位，同时它具备开源、轻量、自动化等特性，能有效解决实际工作中很多特殊场景的需求，祝Nginx在全球的份额持续攀升~</p><p>原文地址：<a href="http://www.yunweipai.com/archives/24973.html" target="_blank" rel="noopener">http://www.yunweipai.com/archives/24973.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;
      
    
    </summary>
    
      <category term="nginx" scheme="http://www.python100.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://www.python100.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>buffer 和 cache</title>
    <link href="http://www.python100.com/2018/07/31/buffer_%E5%92%8C_cache/"/>
    <id>http://www.python100.com/2018/07/31/buffer_和_cache/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:49:57.600Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><h3 id="linux-操作系统中buffer-和-cache-的作用"><a href="#linux-操作系统中buffer-和-cache-的作用" class="headerlink" title="[linux 操作系统中buffer 和 cache 的作用]"></a>[linux 操作系统中buffer 和 cache 的作用]</h3><ul><li><strong>Buffer</strong> 和 <strong>cache</strong> （它们都是占用内存）。</li><li><strong>Buffer</strong>: 系统分配但未被使用的buffer 数量。</li><li>buffer ：作为buffer cache的内存，是块设备的读写缓冲区</li><li>cache（名词）：作为page cache的内存， 文件系统的cache</li></ul><h3 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区:  "></a><strong>Buffer 缓冲区:</strong></h3><p><strong>是块设备的读写缓冲区，buffer 是I/O 缓存，用于内存和硬盘（或其他 I/O设备）之间的数据交换的速度而设计的。</strong></p><p>分析：</p><p><strong>1**</strong>、**通常在写一个非常大的文件，文件会被分成一个个的小 block块–&gt;一直往内存上写–&gt;然后再写入磁盘,, 这个文件非常的大，但是会被分成一个个小的block块，每次都一点一点的–&gt;写入内存–&gt;再写入磁盘, 这样的效率较慢 。</p><p><strong>2**</strong>、<strong> 这种情况下，内存就会攒足一次大的block块–&gt;再写入磁盘，这样的话就不会有第一种情况里的延迟。 </strong>这就是buffer.**</p><h3 id="Cache-高速缓存-："><a href="#Cache-高速缓存-：" class="headerlink" title="Cache**高速缓存** ："></a><strong>Cache**</strong>高速缓存** ：</h3><p><strong>cache</strong>是高速缓存，用于cpu与内存之间的缓冲。主要原因是cpu与memory,由于cpu快，memory跟不上，且有些值使用次数多，所以放入cache中，主要目的是，使用内存来缓存可能被再次访问的数据。 <strong>Cache 经常被使用在I/O 请求上。为提高系统性能。</strong></p><p>从硬盘上读内容时的情况：</p><p>例如 要打开一个非常大的视频文件从硬盘–&gt;读到内存—&gt;显示出来。 第一次打开这个文件的时候需要等待一些时间（视电脑性能），然后第二次打开的时候会比第一次流畅许多。</p><p>例如：小明第一次看这个10G的视频文件，从硬盘–&gt;内存–&gt;显示，他看完以后就关机了，内存也就清空空间了，但是他回头一想，电影中的某个情节想再回顾一下，这个时候，从硬盘–&gt;读到内存 ，这个时候的内存没有再次从硬盘读取，而是之前关机有缓存，读取的时间可能比之前流畅，这就是cache.是为了提高文件读取效率的做法。</p><p><strong>如果 cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO 必会非常小。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;linux-操作系统中buffer-和-cache-的作用&quot;&gt;&lt;a href=&quot;#linux-操作系统中buffer-和-cache-的作
      
    
    </summary>
    
      <category term="linux" scheme="http://www.python100.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql常用备份操作</title>
    <link href="http://www.python100.com/2018/07/31/mysql%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"/>
    <id>http://www.python100.com/2018/07/31/mysql备份恢复/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:49:43.102Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><h2 id="mysql压缩备份"><a href="#mysql压缩备份" class="headerlink" title="mysql压缩备份"></a>mysql压缩备份</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、mysqldump 备份并压缩sql文件</span><br><span class="line">mysql&gt;mysqldump -h主机ip -u用户名 -p密码（也可不输入） 数据库名   | gzip &gt; 压缩后文件位置</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、mysql直接用压缩文件恢复</span><br><span class="line">mysql&gt;gunzip &lt; backupfile.sql.gz | mysql -u用户名 -p密码（也可不输入） 数据库名</span><br></pre></td></tr></table></figure><h4 id="一、备份常用操作基本命令"><a href="#一、备份常用操作基本命令" class="headerlink" title="一、备份常用操作基本命令"></a>一、备份常用操作基本命令</h4><p>1、备份命令mysqldump格式</p><p>格式：mysqldump -h主机名 -P端口 -u用户名 -p密码 –database 数据库名 &gt; 文件名.sql</p><p>2、备份MySQL数据库为带删除表的格式</p><p>备份MySQL数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库。</p><p>mysqldump –add-drop-table -uusername -ppassword -database databasename &gt; backupfile.sql</p><p>3、直接将MySQL数据库压缩备份</p><p>mysqldump -hhostname -uusername -ppassword -database databasename | gzip &gt; backupfile.sql.gz</p><p>4、备份MySQL数据库某个(些)表</p><p>mysqldump -hhostname -uusername -ppassword databasename specific_table1 specific_table2 &gt; backupfile.sql</p><p>5、同时备份多个MySQL数据库</p><p>mysqldump -hhostname -uusername -ppassword <strong>–databases</strong> databasename1 databasename2 databasename3 &gt; multibackupfile.sql仅仅备6、仅备份份数据库结构</p><p>mysqldump –no-data –databases databasename1 databasename2 databasename3 &gt; structurebackupfile.sql</p><p>7、备份服务器上所有数据库</p><p>mysqldump –all-databases &gt; allbackupfile.sql</p><p>mysqldump -h 192.168.27.40 –flush-logs –all-databases -p -udba &gt; /mysql_backup/backup_40.sql</p><p>忽略某个表，mysqldump不提供忽略某个库的参数</p><p>mysqldump -h 192.168.27.72 –ignore-table=huisou.tbl_product_sale_summary –flush-logs –all-databases -pjsrh1sdshj -udba &gt; //mysql_backup/dbbackup/mysqlback/hs.sql</p><p>8、还原MySQL数据库的命令</p><p>mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sql</p><p>9、还原压缩的MySQL数据库</p><p>gunzip &lt; backupfile.sql.gz | mysql -uusername -ppassword databasename</p><p>10、将数据库转移到新服务器</p><p>mysqldump -uusername -ppassword databasename | mysql –host=<em>.</em>.<em>.</em> -C databasename</p><p>11、–master-data 和–single-transaction</p><p>在mysqldump中使用–master-data=2，会记录binlog文件和position的信息 。–single-transaction会将隔离级别设置成repeatable-commited</p><p>12、导入数据库</p><p>常用source命令，用use进入到某个数据库，mysql&gt;source d:\test.sql，后面的参数为脚本文件。</p><p>13、查看binlog日志</p><p>查看binlog日志可用用命令 mysqlbinlog binlog日志名称|more</p><p>14、general_log</p><p>General_log记录数据库的任何操作，查看general_log 的状态和位置可以用命令show variables like “general_log%” ,开启general_log可以用命令set global general_log=on</p><h4 id="二、增量备份"><a href="#二、增量备份" class="headerlink" title="二、增量备份"></a>二、增量备份</h4><p>小量的数据库可以每天进行完整备份，因为这也用不了多少时间，但当数据库很大时，就不太可能每天进行一次完整备份了，这时候就可以使用增量备份。增量备份的原理就是使用了<a href="http://www.centos.bz/category/mysql/" target="_blank" rel="noopener">mysql</a>的binlog志。</p><p>1、首先做一次完整备份：</p><p>mysqldump -h10.6.208.183 -utest2 -p123 -P3310 –single-transaction –master-data=2 test&gt;test.sql这时候就会得到一个全备文件test.sql</p><p>在sql文件中我们会看到：<br>– CHANGE MASTER TO MASTER_LOG_FILE=’bin-log.000002’, MASTER_LOG_POS=107;是指备份后所有的更改将会保存到bin-log.000002二进制文件中。<br>2、在test库的t_student表中增加两条记录，然后执行flush logs命令。这时将会产生一个新的二进制日志文件bin-log.000003，bin-log.000002则保存了全备过后的所有更改，既增加记录的操作也保存在了bin-log.00002中。</p><p>3、再在test库中的a表中增加两条记录，然后误删除t_student表和a表。a中增加记录的操作和删除表a和t_student的操作都记录在bin-log.000003中。</p><h4 id="三、恢复"><a href="#三、恢复" class="headerlink" title="三、恢复"></a>三、恢复</h4><p>1、首先导入全备数据</p><p>mysql -h10.6.208.183 -utest2 -p123 -P3310 &lt; test.sql，也可以直接在mysql命令行下面用source导入</p><p>2、恢复bin-log.000002</p><p>mysqlbinlog bin-log.000002 |mysql -h10.6.208.183 -utest2 -p123 -P3310</p><p>3、恢复部分 bin-log.000003</p><p>在general_log中找到误删除的时间点，然后更加对应的时间点到bin-log.000003中找到相应的position点，需要恢复到误删除的前面一个position点。</p><p>可以用如下参数来控制binlog的区间</p><p>–start-position 开始点 –stop-position 结束点</p><p>–start-date 开始时间 –stop-date 结束时间</p><p>找到恢复点后，既可以开始恢复。</p><p>mysqlbinlog mysql-bin.000003 –stop-position=208 |mysql -h10.6.208.183 -utest2 -p123 -P3310</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h2 id=&quot;mysql压缩备份&quot;&gt;&lt;a href=&quot;#mysql压缩备份&quot; class=&quot;headerlink&quot; title=&quot;mysql压缩备份&quot;&gt;
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.python100.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.python100.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>git和svn区别</title>
    <link href="http://www.python100.com/2018/07/31/SVN%E5%92%8Cgit%E5%B7%AE%E5%88%AB/"/>
    <id>http://www.python100.com/2018/07/31/SVN和git差别/</id>
    <published>2018-07-31T15:27:00.000Z</published>
    <updated>2018-07-31T15:36:27.838Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:35 GMT+0800 (CST) --><hr><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>最核心的区别Git是分布式的，而Svn不是分布的。</li><li>Git把内容按元数据方式存储，而SVN是按文件</li><li>Git没有一个全局版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。</li><li>Git的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li><li>克隆一份全新的大目录，git要比SVN快的多。</li><li>版本库（repository):SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。或者，更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！</li><li>分支（Branch）在SVN，分支是一个完整的目录。且这个目录拥有完整的实际文件。如果工作成员想要开啟新的分支， 还得让其他人重新切分支重新下载 。而 Git，每个工作成员可以任意在自己的本地版本库开啟无限个分支 ，开一个分支，做喜欢的事。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。</li></ul><h3 id="SVN-的主要功能"><a href="#SVN-的主要功能" class="headerlink" title="SVN 的主要功能"></a>SVN 的主要功能</h3><ul><li>SVN属于集中化的版本控制系统，有个不太精确的比喻:SVN = 版本控制+ 备份服务器</li><li>SVN使用起来有点像是档案仓库的感觉，支持并行读写文件，支持代码的版本化管理，功能包括取出、导入、更新、分支、改名、还原、合并等。SVN大都采用图形界面操作，直观，上手快。</li><li>SVN对中文支持好，操作简单，使用没有难度，美工人员，产品人员，测试人员，实施人员都可轻松上手。使用界面统一，功能完善，操作方便。</li></ul><h3 id="Git的主要功能"><a href="#Git的主要功能" class="headerlink" title="Git的主要功能"></a>Git的主要功能</h3><ul><li>Git是一个分布式版本控制系统，操作命令包括：clone，pull，push,branch ,merge ,push,rebase，Git擅长的是程序代码的版本化管理。</li><li>对程序源代码进行差异化的版本管理，代码库占极少的空间。易于代码的分支化管理。不支持中文，图形界面支持差，使用难度大。不易推广。</li></ul><p>SVN更适用于项目管理， Git仅适用于代码管理。</p><h3 id="最后总结一下："><a href="#最后总结一下：" class="headerlink" title="最后总结一下："></a>最后总结一下：</h3><p>SVN的特点是简单，只是需要一个放代码的地方时用是OK的。</p><p>Git的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)，不过想各位能更好使用它，需要花点时间尝试下。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:35 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;区别：&quot;&gt;&lt;a href=&quot;#区别：&quot; class=&quot;headerlink&quot; title=&quot;区别：&quot;&gt;&lt;/a&gt;区别：&lt;/h3&gt;&lt;ul&gt;&lt;l
      
    
    </summary>
    
      <category term="git" scheme="http://www.python100.com/categories/git/"/>
    
    
      <category term="git" scheme="http://www.python100.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="http://www.python100.com/2018/07/26/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%87%BD%E6%95%B0%E8%83%8C%E8%AF%B5/"/>
    <id>http://www.python100.com/2018/07/26/第二阶段函数背诵/</id>
    <published>2018-07-26T01:44:00.000Z</published>
    <updated>2018-07-31T15:51:27.149Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:35 GMT+0800 (CST) --><hr><h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 函数  是一个容器，里面包含了代码执行语句，还有一系列的变量数据</span></span><br><span class="line">函数的参数是在定义函数时括号中的内容</span><br><span class="line">形参是一个待赋值的变量</span><br><span class="line">实参是函数实际调用时传递进去的值</span><br><span class="line">形参是被实参所赋值</span><br><span class="line">实参在传递的时候要和形参一一对应</span><br><span class="line">缺省参数：</span><br><span class="line">在函数定义时，指明一个形参的默认值，就可以不给这个具有默认值得参数传递参数了</span><br><span class="line">    给一个具有默认参数的形参传递一个实参，那么会覆盖原有的默认值</span><br><span class="line">    缺省参数的定义顺序一点是从右向左，从后向前</span><br><span class="line">    <span class="comment">#缺省参数可以让形参具有默认值</span></span><br><span class="line"><span class="comment">#缺省参数的定义一定是从右向左</span></span><br><span class="line"><span class="comment">#缺省参数后面要么是缺省，要么就没参数了</span></span><br><span class="line">不定长参数：</span><br><span class="line">元组不定长*arg</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line">            print(args)</span><br><span class="line">        func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'abc'</span>,<span class="string">'中国'</span>)</span><br><span class="line">     字典不定长：</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">            print(kwargs)   <span class="comment">#*args 用来接收不定长参数保存成元组</span></span><br><span class="line">    func(a=&#123;<span class="string">'name'</span>:<span class="string">'小明'</span>,<span class="string">'sex'</span>:<span class="string">'man'</span>&#125;,b=<span class="number">2</span>,c=<span class="number">3</span>)</span><br><span class="line">        形参：a,b,c</span><br><span class="line">        实参：就是后面的数据</span><br><span class="line">     不定长参数可以接收空值</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i,j,*args,**kwargs)</span>:</span></span><br><span class="line">            <span class="comment">#**kwargs 用来接收不定长参数保存成字典，而且在函数调用时，</span></span><br><span class="line">            <span class="comment">#一定要注意使用命名传参的方式</span></span><br><span class="line">            print(i,j,args,kwargs)</span><br><span class="line">         func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">     传递的时候首先传递单纯变量作为元组不定长，键值对不定长必须在后</span><br><span class="line">命名参数</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,c,d,e,f)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        func(b=<span class="number">1</span>,a=<span class="number">2</span>,d=<span class="number">3</span>,f=<span class="number">4</span>,e=<span class="number">3</span>,c=<span class="number">5</span>)</span><br><span class="line">        <span class="comment">#命名传参可以打乱顺序</span></span><br><span class="line">返回值</span><br><span class="line">    - 函数内部的一些操作，不能影响外界的事务</span><br><span class="line">    - <span class="keyword">return</span> 语句 在函数执行完成之后返回一个结果</span><br><span class="line">    - <span class="keyword">return</span> 会终止函数运行</span><br><span class="line">    - 函数调用完成之后会返回结果</span><br><span class="line">    - 默认的函数如果没有返回值，那么返回<span class="keyword">None</span></span><br><span class="line">    - 函数返回值可以任意多个</span><br><span class="line">    - 只要是合理的数据，**模块**，对象，函数名均可以返回</span><br></pre></td></tr></table></figure><h5 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a><strong>函数作用域</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment">#全局就是全局</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">2</span> <span class="comment">#局部就是局部</span></span><br><span class="line">        <span class="comment">#修改全局a变为2  错误</span></span><br><span class="line">        <span class="comment">#在局部空间创建一个新的同名a 正确</span></span><br><span class="line">    print(<span class="string">"内:"</span>,a)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">global</span> 把一个局部变量声明成全局的</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span> <span class="comment">#全局就是全局</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a <span class="comment">#升级局部变量成为全局的</span></span><br><span class="line">    a = <span class="number">2</span> <span class="comment">#局部就是局部</span></span><br><span class="line">        <span class="comment">#修改全局a变为2  正确</span></span><br><span class="line">        <span class="comment">#在局部空间创建一个新的同名a  错误的</span></span><br><span class="line">    print(<span class="string">"内:"</span>,a)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#局部作用域：函数内空间</span></span><br><span class="line"><span class="comment">#全局作用域：整个脚本空间</span></span><br><span class="line"></span><br><span class="line">- 形参都是局部的</span><br><span class="line">- 不可变数据对象，在函数内外的值，用到了引用计数</span><br><span class="line">- 全局变量可以被局部作用域使用</span><br><span class="line">- 但是局部变量不可以被全局作用域所使用，除非你用<span class="keyword">global</span>语句升级，声明为全局变量</span><br><span class="line">- 全局可变对象,在函数内部使用的时,其实是一个共享状态</span><br><span class="line">- 是因为列表的指针域 是一个 也会存在引用计数的情况</span><br><span class="line">- 解决办法就是在函数内部使用深浅拷贝</span><br><span class="line"><span class="comment">#内外其实现在共同使用同一个列表</span></span><br><span class="line"><span class="comment">#内外互相影响，用的就是同一个列表</span></span><br><span class="line"><span class="comment">#这样的数据可以在函数之间进行通信</span></span><br><span class="line">可变数据在传递参数时</span><br><span class="line">    - 在函数内部直接通过形参修改,也会影响原有数据</span><br><span class="line">    - 可变对象在传递参数时,只是一个引用</span><br><span class="line">不可变数据在传递参数时</span><br><span class="line">- 在函数内部直接通过形参修改,不会影响原有数据</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+= 或者 = 号赋值都会使一个不可变数据类型在函数的局部作用域下成为一个局部变量</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">a = a + <span class="number">1</span></span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个作用域下的a都是来自于同一个作用域的</span></span><br><span class="line"><span class="comment">#你不能说 第一个a是局部的、第二个a是全局的</span></span><br><span class="line">    <span class="comment">#这样的话，一个a在一个内存空间下可以表示两个值了，这就二义性了</span></span><br><span class="line"><span class="comment"># 现在的a 就是一个局部变量了</span></span><br><span class="line"><span class="comment"># 局部变量a 需要 局部变量a + 1</span></span><br><span class="line"><span class="comment"># 这个代码会报错</span></span><br><span class="line"><span class="comment"># local variable 'a' referenced before assignment</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    mylist[<span class="number">0</span>] = <span class="string">'a'</span></span><br><span class="line">    print(<span class="string">'内:'</span>,mylist)</span><br><span class="line">    <span class="comment">#内外其实现在共同使用同一个列表</span></span><br><span class="line">    <span class="comment">#内外互相影响，用的就是同一个列表</span></span><br><span class="line">    <span class="comment">#这样的数据可以在函数之间进行通信</span></span><br><span class="line">func()</span><br><span class="line">print(<span class="string">'外:'</span>,mylist)</span><br><span class="line"></span><br><span class="line"><span class="comment">#==================</span></span><br><span class="line"></span><br><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] <span class="comment">#全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    new_list = mylist.copy() <span class="comment">#浅拷贝之后，互不影响</span></span><br><span class="line">    new_list[<span class="number">0</span>] = <span class="string">'a'</span> <span class="comment">#局部变量</span></span><br><span class="line">    print(<span class="string">'内:'</span>,new_list)</span><br><span class="line">func()</span><br><span class="line">print(<span class="string">'外:'</span>,mylist)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mydict = &#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'Small White'</span>,</span><br><span class="line">    <span class="string">'money'</span>:<span class="number">500</span></span><br><span class="line">&#125; <span class="comment">#字典是一个可变的 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(key,value)</span>:</span></span><br><span class="line">    mydict[key] += value</span><br><span class="line">move_dict = &#123;</span><br><span class="line">    <span class="string">'中彩'</span>: [func,<span class="number">20</span>],</span><br><span class="line">    <span class="string">'生病'</span>: [func,<span class="number">-20</span>],</span><br><span class="line">    <span class="comment">#字典的value要给定一个实际的值</span></span><br><span class="line">&#125;</span><br><span class="line">move = <span class="string">'中彩'</span></span><br><span class="line">move_dict[move][<span class="number">0</span>](<span class="string">'money'</span>,move_dict[move][<span class="number">1</span>])</span><br><span class="line"><span class="comment">#move_dict[move][0] 取到函数</span></span><br><span class="line"><span class="comment">#move_dict[move][1] 取到应该修改的值</span></span><br><span class="line">print(mydict)</span><br></pre></td></tr></table></figure><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><strong>匿名函数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">lambda</span> 表达式</span><br><span class="line">- 除了def语句,我们还可以通过lambda语句来创建函数</span><br><span class="line">- <span class="keyword">lambda</span>创建的函数 因为默认不具有名字，他需要我们来指定一个变量名来保存</span><br><span class="line">- 表达式的结果，将作为返回值自动返回</span><br><span class="line">- 轻量级的函数 一般使用<span class="keyword">lambda</span>来实现</span><br><span class="line">a = <span class="keyword">lambda</span> x: x*<span class="number">2</span></span><br><span class="line">a(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#lamdba 参数 : 表达式</span></span><br><span class="line"></span><br><span class="line">mylist = [<span class="keyword">lambda</span> x,y:x**y,<span class="keyword">lambda</span> x,y:x**(y+<span class="number">1</span>),<span class="keyword">lambda</span> x,y:x**(y+<span class="number">2</span>)] <span class="comment">#跳转表</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">5</span>): <span class="comment">#取出来0-4的数据</span></span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> mylist:</span><br><span class="line">        res = func(var,<span class="number">2</span>)</span><br><span class="line">        print(res)</span><br><span class="line">   print(<span class="string">'-------------'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算器</span></span><br><span class="line">oper_func_dict = &#123;</span><br><span class="line">    <span class="string">'+'</span>:<span class="keyword">lambda</span> x,y : x + y <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> x - y,</span><br><span class="line">    <span class="string">'-'</span>:<span class="keyword">lambda</span> x,y : x-y,</span><br><span class="line">    <span class="string">'*'</span>:<span class="keyword">lambda</span> x,y : x*y,</span><br><span class="line">    <span class="string">'/'</span>:<span class="keyword">lambda</span> x,y : x/y,</span><br><span class="line">&#125;</span><br><span class="line">res = oper_func_dict[<span class="string">'+'</span>](x=<span class="number">0</span>,y=<span class="number">1</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h5 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a><strong>三元表达式</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x + <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> x - <span class="number">1</span></span><br><span class="line"><span class="comment">#当条件满足时(x &gt; 0) 执行表达式左边的,反之执行表达式右边的</span></span><br></pre></td></tr></table></figure><h5 id="跳转表：包含函数的字典或者列表"><a href="#跳转表：包含函数的字典或者列表" class="headerlink" title="跳转表：包含函数的字典或者列表"></a>跳转表：包含函数的字典或者列表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mylist = [<span class="keyword">lambda</span> x,y:x**y,<span class="keyword">lambda</span> x,y:x**(y+<span class="number">1</span>),<span class="keyword">lambda</span> x,y:x**(y+<span class="number">2</span>)]</span><br><span class="line"><span class="comment">#列表中的每一数据都是一个函数</span></span><br><span class="line"><span class="comment">#求出0-4数据的每一个2，3，4次方的结果</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">5</span>): <span class="comment">#取出来0-4的数据</span></span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> mylist:</span><br><span class="line">        <span class="comment">#func = lambda x:x**2</span></span><br><span class="line">        <span class="comment">#func = lambda x:x**3</span></span><br><span class="line">        <span class="comment">#func = lambda x:x**4</span></span><br><span class="line">        res = func(var,<span class="number">2</span>)</span><br><span class="line">        print(res)</span><br><span class="line">    <span class="comment">#外层for循环取出每一个值</span></span><br><span class="line">        <span class="comment">#传递到内存循环中执行三次，分别求出2，3，4的方结果</span></span><br><span class="line">    print(<span class="string">'-------------'</span>)</span><br><span class="line"><span class="comment">#跳转表：包含函数的字典或者列表</span></span><br></pre></td></tr></table></figure><h5 id="作业：模拟人生"><a href="#作业：模拟人生" class="headerlink" title="作业：模拟人生"></a><strong>作业：模拟人生</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">move_dict = &#123;</span><br><span class="line">    <span class="string">'w'</span>: <span class="keyword">lambda</span> y: y + <span class="number">1</span>,</span><br><span class="line">    <span class="string">'s'</span>: <span class="keyword">lambda</span> y: y - <span class="number">1</span>,</span><br><span class="line">    <span class="string">'a'</span>: <span class="keyword">lambda</span> x: x - <span class="number">1</span>,</span><br><span class="line">    <span class="string">'d'</span>: <span class="keyword">lambda</span> x: x + <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">y = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    move = input(<span class="string">'你要怎么移动:'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'w'</span> == move <span class="keyword">or</span> <span class="string">'s'</span> == move:</span><br><span class="line">        y = move_dict[move](y.</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'a'</span> == move <span class="keyword">or</span> <span class="string">'d'</span> == move:</span><br><span class="line">        x = move_dict[move](x)</span><br><span class="line">    print(<span class="string">'你当前的位置:%s:%s'</span> % (x,y))</span><br></pre></td></tr></table></figure><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 当函数自身包含了对自身的调用，那么就是递归</span><br><span class="line">- 递归有最大上限次数:<span class="number">1000</span>次左右</span><br><span class="line">- 递归每一次都在开启一个新的函数空间</span><br><span class="line">- 递归会非常占用内存</span><br><span class="line">- 递归一定要确定终止条件</span><br><span class="line">普通循环 <span class="keyword">for</span> <span class="keyword">while</span> 一般适用于解决线性循环</span><br><span class="line">递归的优势在与解决非线性的</span><br></pre></td></tr></table></figure><h5 id="递归求和作业练习："><a href="#递归求和作业练习：" class="headerlink" title="递归求和作业练习："></a><strong>递归求和作业练习：</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>],<span class="number">5</span>,[<span class="number">6</span>,[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],<span class="number">1</span>,<span class="number">2</span>] <span class="comment">#-&gt; 44</span></span><br><span class="line"><span class="comment">#试一下用循环求和，</span></span><br><span class="line"><span class="comment">#如果列表变化，那么代码可以兼容，可以直接复用，不能改变</span></span><br><span class="line">mysum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sum</span><span class="params">(iter)</span>:</span><span class="comment">#接收一个等待求和的多层序列</span></span><br><span class="line">    <span class="comment">#iter 中 无非两种数据类型: list int</span></span><br><span class="line">    <span class="keyword">global</span> mysum</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> iter:</span><br><span class="line">        <span class="keyword">if</span> type(var) == int: <span class="comment">#当前取出来的数据是int</span></span><br><span class="line">        <span class="comment">#if type(var) == type([])</span></span><br><span class="line">            mysum += var</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            get_sum(var) <span class="comment">#遇到的又是一个列表，那么我们继续遍历</span></span><br><span class="line">    <span class="comment">#for循环结束的时候，递归结束</span></span><br><span class="line">get_sum(mylist)</span><br><span class="line">print(mysum)</span><br></pre></td></tr></table></figure><p>递归统计每一个出现的字符出现的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="string">'asdazxc'</span>,<span class="string">'adxzc'</span>,[<span class="string">'12390145fcsdjfhzkjxcmnasd'</span>,<span class="string">'123987189asjkdsajkb'</span>],<span class="string">'asdqwewqerq'</span>,[<span class="string">'asd890q8390'</span>],<span class="string">'asdhquiweqysa'</span>,<span class="string">'asdhjkzhxjkckjasdh'</span>]</span><br><span class="line"><span class="comment">#把一样的提出来</span></span><br><span class="line"><span class="comment">#统计每一个出现的字符出现的次数</span></span><br><span class="line"><span class="comment">#for循环实现</span></span><br><span class="line">dict_num = &#123;&#125;</span><br><span class="line"><span class="comment">#key:对应的字符</span></span><br><span class="line"><span class="comment">#value:出现的次数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="comment">#字典是可变数据类型，所以直接可以在函数作用域内进行修改</span></span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> seq: <span class="comment">#遍历整个列表数据</span></span><br><span class="line">        <span class="keyword">if</span> type(var) == list:</span><br><span class="line">            <span class="comment">#如果取出来的还是一个列表，那么就继续递归</span></span><br><span class="line">            get_num(var)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#如果碰到的是一个字符串</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> var:  <span class="comment">#遍历字符串，记录次数</span></span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> dict_num:</span><br><span class="line">                    <span class="comment"># 如果获取到的字符，已经存在了字典中，那么他的次数+1</span></span><br><span class="line">                    dict_num[i] = dict_num[i] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果获取到的字符没出现过，那么就创建默认值1就行</span></span><br><span class="line">                    dict_num[i] = <span class="number">1</span></span><br><span class="line">get_num(mylist)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict_num:</span><br><span class="line">    print(key,<span class="string">':'</span>,dict_num[key])</span><br></pre></td></tr></table></figure><h5 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a><strong>回文判断</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#问题：使用递归 判断一个字符串是否是回文:</span></span><br><span class="line"></span><br><span class="line">mystr = input(<span class="string">"请输入一个你觉得是回文的字符串我来帮你判断:"</span>)</span><br><span class="line"><span class="keyword">if</span> mystr == mystr[::<span class="number">-1</span>]:</span><br><span class="line">    print(<span class="string">'这就是回文'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'这不是回文'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_h</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(obj) &lt; <span class="number">2</span>: <span class="comment">#'a'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="comment">#返回 结束</span></span><br><span class="line">    <span class="keyword">elif</span> obj[<span class="number">0</span>] != obj[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment">#如果判断对应索引位置的值不一样，那么就返回False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="comment"># 现在我判断完了0和-1位置，是不是就可以不要他们了</span></span><br><span class="line">    <span class="keyword">return</span> p_h(obj[<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">print(p_h(mystr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#奇数一定有1，偶数一定没有</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_h_2</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="comment">#7 - 1 / 2 = 3</span></span><br><span class="line">    <span class="comment">#7 / 2 - 1  /  2</span></span><br><span class="line">    <span class="comment">#结果少了小数点后的</span></span><br><span class="line">    index = len(obj) // <span class="number">2</span> <span class="comment">#取出中间索引位置</span></span><br><span class="line">    <span class="comment">#取出下一半字符串</span></span><br><span class="line">    b = obj[index:] <span class="keyword">if</span> <span class="keyword">not</span> (len(obj) &amp; <span class="number">1</span>) <span class="keyword">else</span> obj[index+<span class="number">1</span>:]</span><br><span class="line">        <span class="comment">#判断是否是奇或 偶数位</span></span><br><span class="line">        <span class="comment">#三元表达式 当 if条件成立，那么返回左边的，反之返回右边的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> obj[:index] == b[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">print(p_h_2(mystr))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#回文判断</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_h_2</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="comment">#7 - 1 / 2 = 3</span></span><br><span class="line">    <span class="comment">#7 / 2 - 1  /  2   #结果少了小数点后的</span></span><br><span class="line">    index = len(obj) // <span class="number">2</span> <span class="comment">#取出中间索引位置</span></span><br><span class="line">    <span class="comment">#取出下一半字符串</span></span><br><span class="line">    b = obj[index:] <span class="keyword">if</span> <span class="keyword">not</span> (len(obj) &amp; <span class="number">1</span>) <span class="keyword">else</span> obj[index+<span class="number">1</span>:]</span><br><span class="line">        <span class="comment">#判断是否是奇或 偶数位</span></span><br><span class="line">        <span class="comment">#三元表达式 当 if条件成立，那么返回左边的，反之返回右边的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> obj[:index] == b[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">print(p_h_2(mystr))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归回文判断</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_h</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(obj) &lt; <span class="number">2</span>: <span class="comment">#'a'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="comment">#返回 结束</span></span><br><span class="line">    <span class="keyword">elif</span> obj[<span class="number">0</span>] != obj[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment">#如果判断对应索引位置的值不一样，那么就返回False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="comment"># 现在我判断完了0和-1位置，是不是就可以不要他们了</span></span><br><span class="line">    <span class="keyword">return</span> p_h(obj[<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">print(p_h(mystr))</span><br></pre></td></tr></table></figure><h5 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a><strong>os模块</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">- os模块支持以下平台，他会根据平台来对应处理你调用的函数</span><br><span class="line">  - posix：类Unix操作 安卓 Centos ubuntu Debian</span><br><span class="line">  - nt：Win</span><br><span class="line">  - mac：MacOS</span><br><span class="line">    - <span class="number">4</span>月<span class="number">28</span>号早上<span class="number">8</span>点多的时候我的mac丢了</span><br><span class="line">  - dos：DOS</span><br><span class="line">    - dos必须关机 开机的阶段才能看到</span><br><span class="line">  - U盘安装dos操作系统</span><br><span class="line">- os.name</span><br><span class="line">  输出当前os模块在哪个平台下</span><br><span class="line">- os.getcwd() -&gt; str</span><br><span class="line">  - 获取当前的程序工作目录</span><br><span class="line">  - 工作目录：是我们程序在运行期间的时候，如果你需要和当前运行环境(操作系统)进行交互，相对路径互相参照，工作目录可以在程序运行期间修改</span><br><span class="line">  - 运行目录：维护当前程序是从哪个路径下被执行的</span><br><span class="line">- os.listdir(path=os.getcwd()) -&gt; list</span><br><span class="line">  - 返回指定path目录下的所有文件及文件夹的列表</span><br><span class="line">  - 当你不传递一个路径的时候，默认的会返回当前的工作目录下的内容</span><br><span class="line">  - 该函数返回的结果，不会明确什么是文件，什么是文件夹</span><br><span class="line">  - 返回的结果是一个字符串列表，并且每一个路径都是相对路径的</span><br><span class="line">  - 该函数也会将隐藏文件展示</span><br><span class="line">- os.remove(file_path) <span class="comment">#rm </span></span><br><span class="line">  - 删除file_path所指定的一个文件</span><br><span class="line">  - 如果成功返回<span class="keyword">None</span>，失败了直接报错</span><br><span class="line">  - 删除的时候一定要指明文件的后缀</span><br><span class="line">        IsADirectoryError: [Errno <span class="number">21</span>] Is a directory: <span class="string">'test'</span></span><br><span class="line">        删除了一个文件夹</span><br><span class="line">        FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'tesasdjklajdkt'</span></span><br><span class="line">        删除了一个不存在的文件</span><br><span class="line">- os.rmdir(dir_path) <span class="comment"># rm -rf</span></span><br><span class="line">  - 删除dir_path指定的一个文件夹(目录)</span><br><span class="line">  - 如果成功返回<span class="keyword">None</span>，失败了直接报错</span><br><span class="line">  - 无法递归删除文件夹，如果文件夹不为空，那么删除不了</span><br><span class="line">- os.makedirs(<span class="string">'a/b/c'</span>)</span><br><span class="line">  - 递归创建目录</span><br><span class="line">  - 可以嵌套创建目录</span><br><span class="line">  - 成功返回<span class="keyword">None</span>，失败则报错</span><br><span class="line">- os.mkdir(<span class="string">'a'</span>)</span><br><span class="line">  - 创建目录</span><br><span class="line">  - 不能在linux下创建一个和文件名重名的文件夹</span><br><span class="line">  - 虽然类型不同，但是名字也不能是相同的</span><br><span class="line">  - 成功返回<span class="keyword">None</span>，失败则报错</span><br><span class="line">- os.chdir() </span><br><span class="line">  - 在程序运行期间可以通过该函数来改变工作目录</span><br><span class="line">  - os.listdir() 这个函数可以不传递参数执行，返回当前工作目录下的所有文件及文件夹的列表</span><br><span class="line"></span><br><span class="line">os模块下还有一个子模块叫os.path</span><br><span class="line"></span><br><span class="line">os.path可以处理和路径及文件类型有关的问题</span><br><span class="line"></span><br><span class="line">- os.path.isfile(path)  -&gt; Bool</span><br><span class="line">  - 判断路径是否是一个真正的文件 </span><br><span class="line">- os.path.isdir(path)  -&gt; Bool</span><br><span class="line">  - 判断路径是否是一个真正的目录</span><br><span class="line">- os.path.join(<span class="string">'path'</span>,<span class="string">'sub_path'</span>)</span><br><span class="line">  - 拼接path和sub_path</span><br><span class="line">  - 可以构成绝对路径</span><br><span class="line">  - 路径中重复的部分不会被去掉</span><br><span class="line">      &gt;&gt;&gt; os.path.join(<span class="string">'home'</span>,<span class="string">'home/CODE'</span>)</span><br><span class="line">      <span class="string">'home/home/CODE'</span></span><br><span class="line">- os.path.exists(path)</span><br><span class="line">  - 判断路径是否存在</span><br><span class="line">  - 如果存在返回<span class="keyword">True</span>，反之返回<span class="keyword">False</span></span><br><span class="line">- os.path.getsize(path)</span><br><span class="line">  - 返回路径对应的文件大小</span><br><span class="line">  - 返回的文件大小单位为Byte</span><br></pre></td></tr></table></figure><h5 id="os语音控制你的电脑"><a href="#os语音控制你的电脑" class="headerlink" title="os语音控制你的电脑"></a>os<strong>语音控制你的电脑</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">pip install PyAudio 是可以控制你的音频设备 录音还有播放</span></span><br><span class="line"><span class="string">pip install pyttsx3 是可以让你的电脑播放音频</span></span><br><span class="line"><span class="string">pip install requests 可以访问百度语音接口</span></span><br><span class="line"><span class="string">然后安装好pywin32软件即可</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1.你先向电脑传输音频</span></span><br><span class="line"><span class="string">2.解析音频 转换成字符串</span></span><br><span class="line"><span class="string">requests</span></span><br><span class="line"><span class="string">百度云接口</span></span><br><span class="line"><span class="string">3.说话后的字符串再分析</span></span><br><span class="line"><span class="string">4.os.system(处理分析后的字符串)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> pyttsx3 <span class="comment">#播放</span></span><br><span class="line"><span class="keyword">import</span> pyaudio <span class="comment">#录音</span></span><br><span class="line"><span class="keyword">import</span> time <span class="comment">#获取时间</span></span><br><span class="line"><span class="keyword">import</span> json <span class="comment">#用来分析json字符串</span></span><br><span class="line"><span class="keyword">import</span> requests <span class="comment">#访问链接</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen,Request <span class="comment">#访问连接</span></span><br><span class="line"><span class="keyword">import</span> base64 <span class="comment">#b64编码</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(data)</span>:</span></span><br><span class="line">eg = pyttsx3.init()</span><br><span class="line">eg.say(data)</span><br><span class="line">eg.runAndWait()</span><br><span class="line"></span><br><span class="line"><span class="comment">#向电脑说话</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_audio</span><span class="params">()</span>:</span></span><br><span class="line">pa = pyaudio.PyAudio() <span class="comment">#初始化音频设备</span></span><br><span class="line">audio_equip = pa.open(</span><br><span class="line">format=pyaudio.paInt16,<span class="comment">#存储位深</span></span><br><span class="line">channels=<span class="number">1</span>,<span class="comment">#声道</span></span><br><span class="line">rate=<span class="number">16000</span>,<span class="comment">#采样率</span></span><br><span class="line">input=<span class="keyword">True</span>,<span class="comment">#输入</span></span><br><span class="line">frames_per_buffer=<span class="number">1024</span>,<span class="comment">#获取的数据大小</span></span><br><span class="line">)</span><br><span class="line">times = <span class="number">0</span></span><br><span class="line">data = []</span><br><span class="line">print(<span class="string">'[+] 请说话...'</span>)</span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">while</span> times &lt; <span class="number">45</span>: <span class="comment">#控制到了说话时间为3秒</span></span><br><span class="line">audio_data = audio_equip.read(<span class="number">1024</span>) <span class="comment">#从设备中读取音频</span></span><br><span class="line">data.append(audio_data) <span class="comment">#吧每一次read读取到的音频 追加到我的data列表中</span></span><br><span class="line">times += <span class="number">1</span></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">'[+] 你说话耗时:%.2f'</span> % (end-start))</span><br><span class="line"></span><br><span class="line">audio_equip.close() <span class="comment">#关闭设备</span></span><br><span class="line">res = <span class="string">b''</span>.join(data) <span class="comment">#把列表中的所有数据拼接成整体</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">()</span>:</span></span><br><span class="line">url = <span class="string">'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s'</span></span><br><span class="line">client_id = <span class="string">'npFlwGurf1tMvMS8myW6W9AA'</span></span><br><span class="line">client_secret = <span class="string">'TZcTamTfVlYWilclkLbatZe18e8xYzIY'</span></span><br><span class="line">host = url % (client_id,client_secret)</span><br><span class="line">res = urlopen(host).read().decode() <span class="comment">#urlopen函数打开链接提交参数，获取Toekn</span></span><br><span class="line"><span class="comment">#但是这里获取到的是一个json的并且是编码过后的数据</span></span><br><span class="line">token = json.loads(res)[<span class="string">'access_token'</span>]</span><br><span class="line"><span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment">#百度音频解析 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bd_analysis</span><span class="params">()</span>:</span></span><br><span class="line">token = get_token()</span><br><span class="line">audio_data = get_audio()</span><br><span class="line">audio_data_len = len(audio_data)</span><br><span class="line">audio_data = base64.b64encode(audio_data).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment">#百度云在接收音频的时候，需要传递两个值</span></span><br><span class="line"><span class="comment">#第一个是音频的实际数据，用base64编码</span></span><br><span class="line"><span class="comment">#第二个是音频的长度, 一定是未编码之前的</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'format'</span>:<span class="string">'wav'</span>,</span><br><span class="line"><span class="string">'rate'</span>:<span class="number">16000</span>,</span><br><span class="line"><span class="string">'channel'</span>:<span class="number">1</span>,</span><br><span class="line"><span class="string">'cuid'</span>: <span class="string">'1804shuaideyipi'</span>,</span><br><span class="line"><span class="string">'dev_pid'</span>:<span class="number">1536</span>,</span><br><span class="line"><span class="string">'token'</span>:token,</span><br><span class="line"><span class="string">'speech'</span>:audio_data,</span><br><span class="line"><span class="string">'len'</span>:audio_data_len,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = json.dumps(data).encode() <span class="comment">#处理成json格式并且编码</span></span><br><span class="line">host = <span class="string">'http://vop.baidu.com/server_api'</span> <span class="comment">#把所有的东西都给到百度</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>, <span class="comment">#指明你提交的数据类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req = Request(url=host,headers=headers,data=data)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">res = json.loads(urlopen(req).read().decode())[<span class="string">'result'</span>][<span class="number">0</span>].replace(<span class="string">'，'</span>,<span class="string">''</span>)</span><br><span class="line"><span class="keyword">except</span> :</span><br><span class="line">res = <span class="string">'语音质量有问题,请重新喊话!'</span></span><br><span class="line">talk(<span class="string">'语音质量有问题,请重新喊话!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'[+] 你说话的内容:'</span>,res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="string">'yes'</span> <span class="keyword">in</span> bd_analysis():</span><br><span class="line">talk(<span class="string">'请告诉我，我要做什么！'</span>)</span><br><span class="line">res = bd_analysis()</span><br><span class="line"><span class="keyword">if</span> <span class="string">'计算器'</span> <span class="keyword">in</span> res:</span><br><span class="line">os.system(<span class="string">'calc'</span>)</span><br><span class="line">talk(<span class="string">'爷，你的计算器打开了'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="string">'取消关机'</span> <span class="keyword">in</span> res:</span><br><span class="line">os.system(<span class="string">'shutdown -a'</span>)</span><br><span class="line">talk(<span class="string">'已经取消关机了'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="string">'关机'</span> <span class="keyword">in</span> res:</span><br><span class="line">os.system(<span class="string">'shutdown -s -t 1000'</span>)</span><br><span class="line">talk(<span class="string">'OK给你关机!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">所有的文件都是在磁盘上的！</span><br><span class="line">CPU只能处理在内存中的数据，也就是说，CPU无法直接去阅读磁盘里的文件</span><br><span class="line">CPU &lt;-&gt; MEM &lt;-&gt; DISK</span><br><span class="line">- 文件操作，在程序里都是对内存中的文件进行操作！</span><br><span class="line">第一步：打开文件  fp = open(path, mode=<span class="string">'r'</span>) </span><br><span class="line">open函数返回的是一个文件的句柄，不是完全的文件展开体，只是一个可以导出整个文件的头指针</span><br><span class="line">第二步：读   </span><br><span class="line">fp.read(num)</span><br><span class="line">    函数直接阅读整个文件，并返回整个文件为一个字符串</span><br><span class="line">        把整个文件读到了内存</span><br><span class="line">        如果给read函数传递了num变量</span><br><span class="line">        那么他是通过num来读取对应文件中的指定字符个数</span><br><span class="line">        read函数获取到的文件内容会保留行末尾的\n\r</span><br><span class="line">    fp.readline()</span><br><span class="line">    readline函数一次可以读取文件中的一行内容</span><br><span class="line">        当遇到了\n\r则停止，代表当前是一行了</span><br><span class="line">        当遇到了EOF（文件结束标志）</span><br><span class="line">        readline如果去读取超过文件本身行数的次数，那么不会报错，只会返回空</span><br><span class="line">        readline不会一次性把整个文件展开在内存</span><br><span class="line">        但是需要我们手动的维护行数</span><br><span class="line">        readline函数在获取到文件内容的每一行后，也会保留结尾的\r\n</span><br><span class="line">fp.readlines()</span><br><span class="line">    返回了字符串列表</span><br><span class="line">        列表中每一个元素都是一行的数据</span><br><span class="line">        并且保留行末尾的换行符号</span><br><span class="line">第三步：关闭文件</span><br><span class="line">fp.close()</span><br><span class="line">fp.tell()  获取文件指针位置   </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'1.txt'</span>) <span class="keyword">as</span> fp  这里的<span class="keyword">with</span> <span class="keyword">as</span> 语句可以自动做资源创建和释放</span><br><span class="line">文件权限：</span><br><span class="line">w:权限可以让我们打开一个文件，进行写入，但是每一次打开都会将之前的文件内容清空</span><br><span class="line">       write函数在写入文件内容的时候，不会自动的带换行\r\n</span><br><span class="line">    a：append 追加，读写指针在文件末尾</span><br></pre></td></tr></table></figure><h5 id="缓冲和缓存"><a href="#缓冲和缓存" class="headerlink" title="缓冲和缓存"></a><strong>缓冲和缓存</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">缓冲区( 内存(临时) )  针对读写文件 </span><br><span class="line">- 缓冲区让效率慢的和效率快的组件之间可以协同工作，缓和速度之间的矛盾，不频繁的写入磁盘，可以保护设备。因为磁盘的寿命是由写次数决定的。</span><br><span class="line">    - 当你关闭文件的时候，缓冲区中的内容会刷新到磁盘上</span><br><span class="line">    - 手动刷新缓冲区：fp.flush()</span><br><span class="line">    </span><br><span class="line">- 磁盘是保存数据的</span><br><span class="line">- 内存是流通数据的</span><br><span class="line">- CPU才是真正计算数据的</span><br><span class="line">- CPU处理内存中的数据，而内存中的数据来自于磁盘</span><br><span class="line"></span><br><span class="line">缓存：为了提高数据流通速度</span><br><span class="line">缓存是在CPU里有</span><br><span class="line">缓存是一块超级告诉的数据流通空间（类似内存），但是太贵了，所以电脑上缓存空间一般不大</span><br><span class="line">L1：CPU经常从L1中拿取数据、控制线程和进程</span><br><span class="line">L2：存储数据</span><br><span class="line">L3：管控内存</span><br></pre></td></tr></table></figure><h5 id="读写指针修改"><a href="#读写指针修改" class="headerlink" title="读写指针修改"></a><strong>读写指针修改</strong></h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fp.seek(offset,when)</span><br><span class="line">offset：偏移量</span><br><span class="line">字节为单位</span><br><span class="line">when: 从哪里开始移动</span><br><span class="line"><span class="number">0</span>:文件开头</span><br><span class="line"><span class="number">1</span>:当前位置</span><br><span class="line"><span class="number">2</span>:文件末尾</span><br><span class="line">a模式下的文件末尾读写指针如何移动到文件头部呢？</span><br><span class="line">fp.seek(<span class="number">0</span>,<span class="number">0</span>) -&gt; 回到了文件开头</span><br><span class="line">fp.tell()  获取文件指针，返回的也是以一个字节为单位</span><br><span class="line"></span><br><span class="line">不同权限下读写指针位置：</span><br><span class="line">- r: 文件开头</span><br><span class="line">- w: 文件开头</span><br><span class="line">- a: 文件末尾</span><br></pre></td></tr></table></figure><h5 id="csv文件操作"><a href="#csv文件操作" class="headerlink" title="csv文件操作"></a><strong>csv</strong>文件操作</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- CSV文件是一个用于电子表格存储类型</span><br><span class="line">- csv文件是存储了以逗号分隔的数据</span><br><span class="line"></span><br><span class="line">csv文件默认写入的时候 会在每两行之间多一个空行</span><br><span class="line">解决办法：</span><br><span class="line">在打开文件的时候</span><br><span class="line">fp = open(<span class="string">'1.csv'</span>,<span class="string">'w'</span>,newline=<span class="string">''</span>)</span><br><span class="line"><span class="comment">#newline参数用来控制 每一次写入csv文件数据的时候，一行行之间是否需要空行</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: 处理普通文本对象为csv文本对象</span><br><span class="line">打开文件：</span><br><span class="line">fp = open(path,mode)</span><br><span class="line">加工：</span><br><span class="line">csv_read_fp = csv.reader(fp)  负责读取</span><br><span class="line">csv_write_fp = csv.writer(fp) 负责写入</span><br><span class="line"><span class="number">2</span>: 对csv_read_fp进行<span class="keyword">for</span>循环迭代，就可以一行行的访问csv表格中的内容</span><br><span class="line"><span class="keyword">for</span> var1,var2 <span class="keyword">in</span> csv_read_fp:</span><br><span class="line">print(var1,var2)</span><br><span class="line"><span class="number">3</span>: 对csv_write_fp文件写入内容，写入的是一些逗号分隔开的数据</span><br><span class="line">csv_write_fp.wirterow([seq])</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字典读取csv时：</span><br><span class="line">dict_read_csv = csv.DictReader(fp)</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> dict_read_csv:</span><br><span class="line">print(var[<span class="string">'name'</span>],var[<span class="string">'sex'</span>])</span><br><span class="line">csv文件中第一行是key值，下面的数据是value</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">字典写一个csv文件</span><br><span class="line">dict_write_csv = csv.DictWriter(fp,fileds)</span><br><span class="line">fp: </span><br><span class="line">打开的文件对象，需要加工成csv字典处理文件对象</span><br><span class="line">fileds： 标题行 第一行</span><br><span class="line">fileds 也是一个逗号分隔的数据 比如: fileds = [<span class="string">'name'</span>,<span class="string">'age'</span>,<span class="string">'sex'</span>]</span><br><span class="line"></span><br><span class="line">dict_write_csv.writeheader() <span class="comment">#将指定的标题行先写入到csv文件里</span></span><br><span class="line">dict_write_csv.writerow(&#123;<span class="string">'name'</span>:<span class="string">'BOB'</span>,<span class="string">'age'</span>:<span class="string">'16'</span>,<span class="string">'sex'</span>:<span class="string">'man'</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">fp = open(<span class="string">'test1.csv'</span>,<span class="string">'w'</span>,newline=<span class="string">''</span>)</span><br><span class="line">fileds = [<span class="string">'name'</span>,<span class="string">'age'</span>,<span class="string">'sex'</span>]  <span class="comment">#标题行</span></span><br><span class="line">name = [<span class="string">'Bob'</span>,<span class="string">'Jack'</span>,<span class="string">'Lucy'</span>]</span><br><span class="line">age = [<span class="number">10</span>,<span class="number">16</span>,<span class="number">18</span>]</span><br><span class="line">sex = [<span class="string">'man'</span>,<span class="string">'man'</span>,<span class="string">'woman'</span>]</span><br><span class="line">human_list = []</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment">#0-2 </span></span><br><span class="line"><span class="comment">#外层循环用来控制生产三个数据</span></span><br><span class="line">human_dict = &#123;&#125;</span><br><span class="line">human_dict[fileds[<span class="number">0</span>]] = name[index] <span class="comment">#name</span></span><br><span class="line">human_dict[fileds[<span class="number">1</span>]] = age[index] <span class="comment">#name</span></span><br><span class="line">human_dict[fileds[<span class="number">2</span>]] = sex[index] <span class="comment">#name</span></span><br><span class="line">human_list.append(human_dict)</span><br><span class="line"><span class="comment">#BOB = &#123;'name':'BOB','age':'16','sex':'man'&#125;</span></span><br><span class="line">dict_write_csv = csv.DictWriter(fp,fileds) <span class="comment">#加工文件对象，指明标题行</span></span><br><span class="line">print(help(csv.DictWriter)) <span class="comment">#写入标题行</span></span><br><span class="line"><span class="comment">#******************************</span></span><br><span class="line">dict_write_csv.writeheader() <span class="comment">#用来在csv文件中写入标题行</span></span><br><span class="line"><span class="comment">#******************************</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> human_list: <span class="comment">#遍历用户字典，分别写入csv文件中</span></span><br><span class="line">dict_write_csv.writerow(var)</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:35 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h5 id=&quot;函数参数&quot;&gt;&lt;a href=&quot;#函数参数&quot; class=&quot;headerlink&quot; title=&quot;函数参数&quot;&gt;&lt;/a&gt;&lt;strong&gt;函数参
      
    
    </summary>
    
      <category term="python" scheme="http://www.python100.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>函数进阶</title>
    <link href="http://www.python100.com/2018/07/26/%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
    <id>http://www.python100.com/2018/07/26/第三阶段函数进阶/</id>
    <published>2018-07-26T01:44:00.000Z</published>
    <updated>2018-07-31T15:51:42.402Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">实现闭包步骤：</span><br><span class="line">- <span class="number">1</span>: 你要先来一个函数嵌套</span><br><span class="line">  - 外函数里包装一个内函数</span><br><span class="line">- <span class="number">2</span>: 外函数作用域有一个局部数据对象</span><br><span class="line">- <span class="number">3</span>: 内部函数对于外部函数作用域里非全局变量的引用</span><br><span class="line">- <span class="number">4</span>: 外函数返回内部函数</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">()</span>:</span></span><br><span class="line">        a = <span class="number">1</span> <span class="comment">#a是属于wai函数作用域里的</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">()</span>:</span> <span class="comment">#nei函数就是一个载体了</span></span><br><span class="line">            print(a)</span><br><span class="line">        <span class="keyword">return</span> nei <span class="comment">#返回的是一个函数对象</span></span><br><span class="line">    func = wai() <span class="comment">#func -&gt; None</span></span><br><span class="line">    <span class="comment">#func == nei</span></span><br><span class="line">    func() <span class="comment"># a</span></span><br><span class="line">    <span class="comment">#返回的nei函数可以在wai函数执行完成之后，继续不报错执行</span></span><br><span class="line">    <span class="comment">#证明了在nei函数，也就是此时的func中，保留一个a变量。</span></span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>: 闭包内部创建载体，可以使一个局部变量续命</span><br><span class="line"><span class="number">2</span>:变量私有化：</span><br><span class="line">每一次闭包函数执行后的返回值都是一个新的，这是因为函数运行首先开辟的都   是一块新的函数临时空间</span><br><span class="line">每一次闭包函数执行后，都是返回了一个不一样的闭包函数载体，</span><br><span class="line">那么这个载体里的变量，也是不一样的</span><br><span class="line"><span class="number">3</span>: 变量状态维持：</span><br><span class="line">闭包函数载体(返回值)，只要存活着，那么它其中的变量也将会一直维护</span><br><span class="line"><span class="number">4</span>: 闭包会一直保存变量，所以呢，本该死去的局部变量现在无法及时得到释放,</span><br><span class="line">    消耗内存</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">1</span> <span class="comment">#局部变量 只能存活在函数运行期间</span></span><br><span class="line">    <span class="comment">#mylist[0] += 1 #在函数内部引用全局可变变量，那么其实你们都是全局的</span></span><br><span class="line">    mylist = [<span class="string">'a'</span>,<span class="string">'b'</span>] <span class="comment">#局部变量</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">func   <span class="comment">#函数对象 函数名</span></span><br><span class="line">func() <span class="comment">#函数调用</span></span><br><span class="line">print(mylist)</span><br><span class="line"></span><br><span class="line"><span class="comment">#让一个局部变量存活下来:</span></span><br><span class="line">    <span class="comment">#1: 返回值</span></span><br><span class="line">    <span class="comment">#2: global</span></span><br><span class="line">    <span class="comment">#3: 列表保存数据 全局共享同一个(只在函数内部做修改) 可变数据的引用</span></span><br><span class="line">    <span class="comment">#4: 闭包也可以给一个局部变量续命</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于可变数据对象：</span></span><br><span class="line">    <span class="comment">#赋值：我为自己创建了一个新得 找了新欢</span></span><br><span class="line">        <span class="comment">#直接创建了一个新的 ： 局部变量</span></span><br><span class="line">    <span class="comment">#修改：影响咱俩共有的女朋友</span></span><br><span class="line">        <span class="comment">#全局被局部所使用 ： 全局</span></span><br></pre></td></tr></table></figure><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a><strong>装饰器</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器可以在函数运行前添加功能，并且不影响原有函数内容</span></span><br><span class="line"></span><br><span class="line">函数三要素</span><br><span class="line">def func(arg): <span class="comment">#定义</span></span><br><span class="line">var = arg ** <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> var</span><br><span class="line">函数名: func</span><br><span class="line">函数参数(形参)：arg</span><br><span class="line">函数返回值: arg</span><br><span class="line">默认的，如果没有函数内的<span class="keyword">return</span>语句，函数默认返回None</span><br><span class="line"></span><br><span class="line">res = func(<span class="number">10</span>) <span class="comment">#执行</span></span><br><span class="line">函数名：func</span><br><span class="line">返回值：res</span><br><span class="line">参数(实参)：<span class="number">10</span></span><br><span class="line"></span><br><span class="line">- func：函数对象</span><br><span class="line">- func() ：函数调用</span><br></pre></td></tr></table></figure><h3 id="普通装饰器"><a href="#普通装饰器" class="headerlink" title="普通装饰器"></a><strong>普通装饰器</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">(b_func)</span>:</span> <span class="comment">#外函数的参数是一个函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"嘿嘿嘿"</span>) <span class="comment">#在nei函数里写的代码基本上都是添加的功能</span></span><br><span class="line">        <span class="keyword">return</span> b_func() <span class="comment">#这个是nei函数返回值，用来返回之前在wai函数所接收的参数</span></span><br><span class="line">        <span class="comment">#b_func()</span></span><br><span class="line">        <span class="comment">#return ''</span></span><br><span class="line">    <span class="keyword">return</span> nei <span class="comment">#返回了wai函数里的这个定义好的闭包容器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@wai #语法糖</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'哈哈哈哈'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'func'</span></span><br><span class="line"></span><br><span class="line">res = func() <span class="comment">#调用一个被装饰函数 其实相等于 wai(func)()</span></span><br><span class="line">print(<span class="string">'func的返回值:'</span>,res)</span><br><span class="line"><span class="comment">#func() 传统函数调用</span></span><br><span class="line">    <span class="comment">#1: print('哈哈哈')</span></span><br><span class="line">    <span class="comment">#2: return None</span></span><br><span class="line"><span class="comment">#func() 被装饰时调用 @wai</span></span><br><span class="line">    <span class="comment">#被装饰函数: func</span></span><br><span class="line">    <span class="comment">#装饰器函数: wai</span></span><br><span class="line">    <span class="comment">#1: wai(func) -&gt; return nei</span></span><br><span class="line">    <span class="comment">#2: nei() -&gt;</span></span><br><span class="line">        <span class="comment">#1: print("嘿嘿嘿")</span></span><br><span class="line">        <span class="comment">#2: return b_func()</span></span><br><span class="line">            <span class="comment">#1: b_func() -&gt; 'func'  #内部调用被装饰函数</span></span><br><span class="line">            <span class="comment">#2: return 'func' #内部闭包函数的返回值 其实是被装饰函数的返回值</span></span><br></pre></td></tr></table></figure><h3 id="被装饰函数带参数"><a href="#被装饰函数带参数" class="headerlink" title="被装饰函数带参数"></a><strong>被装饰函数带参数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">(func)</span>:</span> <span class="comment">#装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">(var1,var2)</span>:</span></span><br><span class="line">        var1 = <span class="number">100</span>  <span class="comment">#在闭包函数内部对被装饰函数参数进行干预</span></span><br><span class="line">        var2 = <span class="number">99</span></span><br><span class="line">        <span class="keyword">return</span> func(var1,var2)</span><br><span class="line">    <span class="keyword">return</span> nei</span><br><span class="line"></span><br><span class="line"><span class="meta">@wai</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">res = work(<span class="number">20</span>,<span class="number">30</span>)  <span class="comment">#wai(work)(a,b)</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h3 id="装饰器函数也可以有参数"><a href="#装饰器函数也可以有参数" class="headerlink" title="装饰器函数也可以有参数"></a><strong>装饰器函数也可以有参数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#商品</span></span><br><span class="line">mind = <span class="keyword">True</span></span><br><span class="line">zhekou = <span class="number">0.9</span> <span class="comment">#折扣的数值</span></span><br><span class="line">youhuiquan = <span class="number">5</span></span><br><span class="line"><span class="comment"># 当你的装饰器函数也需要参数的时候，只需要多一层包装即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dazhe</span><span class="params">(con,zk,yhq)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">(money)</span>:</span></span><br><span class="line">            print(<span class="string">'-----------'</span>)</span><br><span class="line">            <span class="keyword">if</span> con:</span><br><span class="line">                print(<span class="string">'打折!'</span>)</span><br><span class="line">                money = money * zk</span><br><span class="line">            <span class="keyword">elif</span> yhq:</span><br><span class="line">                print(<span class="string">"优惠券！"</span>)</span><br><span class="line">                money = money - yhq</span><br><span class="line">            <span class="keyword">return</span> func(money)</span><br><span class="line">        <span class="keyword">return</span> nei</span><br><span class="line">    <span class="keyword">return</span> wai</span><br><span class="line"><span class="comment">#dazhe -&gt; wai</span></span><br><span class="line"><span class="comment">#wai -&gt; nei</span></span><br><span class="line"><span class="comment">#nei -&gt; func()</span></span><br><span class="line"><span class="meta">@dazhe(mind,zhekou,youhuiquan)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apple</span><span class="params">(money)</span>:</span></span><br><span class="line">    print(<span class="string">'苹果的价钱是:%d'</span> % money)</span><br><span class="line">    <span class="keyword">return</span> money</span><br><span class="line"></span><br><span class="line"><span class="meta">@dazhe(mind,zhekou,youhuiquan)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pants</span><span class="params">(money)</span>:</span></span><br><span class="line">    print(<span class="string">'裤子的价钱是:%d'</span> % money)</span><br><span class="line">    <span class="keyword">return</span> money</span><br><span class="line"></span><br><span class="line"><span class="meta">@dazhe(mind,zhekou,youhuiquan)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skirt</span><span class="params">(money)</span>:</span></span><br><span class="line">    print(<span class="string">'裙子的价钱是:%d'</span> % money)</span><br><span class="line">    <span class="keyword">return</span> money</span><br><span class="line"></span><br><span class="line">apple(<span class="number">10</span>)</span><br><span class="line">pants(<span class="number">50</span>)</span><br><span class="line">skirt(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">(b_func)</span>:</span> <span class="comment">#外函数的参数是一个函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"嘿嘿嘿"</span>) <span class="comment">#在nei函数里写的代码基本上都是添加的功能</span></span><br><span class="line">        <span class="keyword">return</span> b_func() <span class="comment">#这个是nei函数返回值，用来返回之前在wai函数所接收的参数</span></span><br><span class="line">        <span class="comment">#b_func()</span></span><br><span class="line">        <span class="comment">#return ''</span></span><br><span class="line">    <span class="keyword">return</span> nei <span class="comment">#返回了wai函数里的这个定义好的闭包容器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@wai #语法糖</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'哈哈哈哈'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'func'</span></span><br><span class="line"></span><br><span class="line">res = func() <span class="comment">#调用一个被装饰函数 其实相等于 wai(func)()</span></span><br><span class="line">print(<span class="string">'func的返回值:'</span>,res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#func() 传统函数调用</span></span><br><span class="line">    <span class="comment">#1: print('哈哈哈')</span></span><br><span class="line">    <span class="comment">#2: return None</span></span><br><span class="line"><span class="comment">#func() 被装饰时调用 @wai</span></span><br><span class="line">    <span class="comment">#被装饰函数: func</span></span><br><span class="line">    <span class="comment">#装饰器函数: wai</span></span><br><span class="line">    <span class="comment">#1: wai(func) -&gt; return nei</span></span><br><span class="line">    <span class="comment">#2: nei() -&gt;</span></span><br><span class="line">        <span class="comment">#1: print("嘿嘿嘿")</span></span><br><span class="line">        <span class="comment">#2: return b_func()</span></span><br><span class="line">            <span class="comment">#1: b_func() -&gt; 'func'  #内部调用被装饰函数</span></span><br><span class="line">            <span class="comment">#2: return 'func' #内部闭包函数的返回值 其实是被装饰函数的返回值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'穿裙子'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'穿大衣'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'穿牛仔'</span>)</span><br><span class="line">func_dict = &#123;</span><br><span class="line">    <span class="string">'裙子'</span>:func_1,</span><br><span class="line">    <span class="string">'大衣'</span>:func_2,</span><br><span class="line">    <span class="string">'牛仔'</span>:func_3,</span><br><span class="line">&#125;</span><br><span class="line">choice = random.choice(list(func_dict.keys()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_wai</span><span class="params">(choice)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wai</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">()</span>:</span></span><br><span class="line">            func_dict[choice]()</span><br><span class="line">            <span class="keyword">return</span> func()</span><br><span class="line">        <span class="keyword">return</span> nei</span><br><span class="line">    <span class="keyword">return</span> wai</span><br><span class="line"></span><br><span class="line"><span class="meta">@_wai(choice)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">girl</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'上班了！'</span>)</span><br><span class="line"></span><br><span class="line">girl() <span class="comment">#装饰这个函数</span></span><br></pre></td></tr></table></figure><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a><strong>异常捕获</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">常见错误：</span><br><span class="line">IndentationError: unexpected indent缩进错误</span><br><span class="line">ZeroDivisionError: division by zero除数为<span class="number">0</span></span><br><span class="line">NameError: name <span class="string">'b'</span> is not defined访问未声明变量</span><br><span class="line">IndexError: list index out of range访问越界(超过了原有数据的长度)变量</span><br><span class="line">KeyError: <span class="number">2</span>访问字典中(JSON类似)不存在key值</span><br><span class="line">AttributeError: module <span class="string">'socket'</span> has no attribute <span class="string">'create'</span></span><br><span class="line">访问一个对象(变量，函数，类，模块)不存在的属性</span><br><span class="line"></span><br><span class="line">异常捕获的作用：</span><br><span class="line">- 异常捕获可以提高代码的健壮性</span><br><span class="line">- 让我们的代码在不同情况下，可以让程序继续向下，而不是直接中断</span><br><span class="line">- 有一些异常错误，需要额外导入模块才可以使用，切记。</span><br><span class="line"></span><br><span class="line">异常的类型：</span><br><span class="line">SystemExit(系统中断异常)</span><br><span class="line">KeyboardInterrupt(ctrl+c)</span><br><span class="line">Exception(内建异常类) </span><br><span class="line">Python中的异常都是继承自这个Exception而来的</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'打开文件'</span>)  <span class="comment">#捕获异常</span></span><br><span class="line">    fp = open(<span class="string">'1.txt'</span>)</span><br><span class="line">except FileNotFoundError :</span><br><span class="line">    print(<span class="string">'这个文件不存在'</span>)   <span class="comment">#捕获到异常后要做的事情</span></span><br><span class="line">except Exception as e:</span><br><span class="line"><span class="comment">#捕获所有错误，一般不用</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment">#不管错误是否发生，都执行这里的代码，比如关闭文件</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"关闭文件"</span>)</span><br><span class="line">    fp.close()</span><br><span class="line"><span class="comment">#else 分支可以在没有异常出现的时候 执行</span></span><br></pre></td></tr></table></figure><h3 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a><strong>手动抛出异常</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#手动抛出异常，就是直接raiseraise MyError('你能不能好好传参')</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">'我心情不好，我就是要报错'</span>)</span><br><span class="line">    <span class="comment">#raise语句去将一个合法的异常</span></span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    print(<span class="string">'这是我刚才自己要抛出来的异常，现在我要捕获他'</span>)</span><br><span class="line">print(<span class="string">"哈哈哈哈哈哈"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name,age)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> type(name) == str <span class="keyword">and</span> type(age) == int:</span><br><span class="line">        print(<span class="string">'%s:%d'</span> % (name,age,abc))  <span class="comment">#定义了传入参数的类型，类型不对就报错</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'你能不能好好传参'</span>)</span><br><span class="line">    <span class="comment">#%d只能接受数字</span></span><br><span class="line">name = <span class="string">'小明'</span></span><br><span class="line">age = <span class="string">'18'</span></span><br><span class="line">func(name,age)</span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span> <span class="comment">#面向对象的继承方法</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment">#什么都不干，过！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#继承已又的异常基类，从这个基础来创建自己的异常</span></span><br><span class="line"><span class="comment"># 现在已经创建出来了一个自己的错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name,age)</span>:</span></span><br><span class="line">    <span class="comment">#name str</span></span><br><span class="line">    <span class="comment">#age int</span></span><br><span class="line">    <span class="keyword">if</span> type(name) == str <span class="keyword">and</span> type(age) == int:</span><br><span class="line">        print(<span class="string">'%s:%d'</span> % (name,age,abc))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> MyError(<span class="string">'你能不能好好传参'</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="string">'小明'</span></span><br><span class="line">age = <span class="string">'18'</span></span><br><span class="line">func(name,age)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="comment">#2,3版本是两个Python</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line">    <span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> urlopen,URLError</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.asdaskljdklasjdsajdlk.com'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    res = urlopen(url)</span><br><span class="line">    print(res.read())</span><br><span class="line"><span class="keyword">except</span> URLError:</span><br><span class="line">    print(<span class="string">'[+] 链接异常，无法访问'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">human = &#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'小明'</span>,</span><br><span class="line">    <span class="string">'company'</span>:<span class="string">'小红'</span>,</span><br><span class="line">    <span class="comment">#'gays':'小暗'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'%s的老婆是%s'</span> % (human[<span class="string">'name'</span>],human[<span class="string">'company'</span>],human[<span class="string">'gays'</span>]))</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'company'</span> <span class="keyword">in</span> str(e):</span><br><span class="line">        print(<span class="string">'他没老婆'</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'gays'</span> <span class="keyword">in</span> str(e):</span><br><span class="line">        print(<span class="string">'他没老公'</span>)</span><br></pre></td></tr></table></figure><h3 id="时间模块time"><a href="#时间模块time" class="headerlink" title="时间模块time"></a><strong>时间模块time</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">- time.time()  -&gt; float_time</span><br><span class="line">  - linux时间：从<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日， <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">  - 获取从Unix时间到现在经过的秒数 -&gt; 浮点数</span><br><span class="line">- time.localtime(float_time)  -&gt; 时间元组</span><br><span class="line">  - 如果不传递参数，那么默认返回本地时间的一个时间元组</span><br><span class="line">    </span><br><span class="line">res = time.localtime() -&gt; 时间结果是具备时区的</span><br><span class="line">time.struct_time(</span><br><span class="line">    tm_year=<span class="number">2018</span>,  年</span><br><span class="line">    tm_mon=<span class="number">6</span>,  月</span><br><span class="line">    tm_mday=<span class="number">9</span>,  日</span><br><span class="line">    tm_hour=<span class="number">10</span>,  时</span><br><span class="line">    tm_min=<span class="number">17</span>,  分</span><br><span class="line">    tm_sec=<span class="number">9</span>,  秒</span><br><span class="line">    tm_wday=<span class="number">5</span>,  星期几  星期一数字是<span class="number">0</span> 从<span class="number">0</span>开始 表示星期几</span><br><span class="line">    tm_yday=<span class="number">160</span>,  今年第几天</span><br><span class="line">    tm_isdst=<span class="number">0</span>  夏令时</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">res.tm_year</span><br><span class="line">res.tm_mon</span><br><span class="line">通过返回值的内置属性来获取到对应的值</span><br><span class="line"></span><br><span class="line">time.sleep(seconds)  --&gt; 程序休眠，让程序挂起</span><br><span class="line">time.clock()  ---&gt;   一般衡量程序的耗时</span><br><span class="line">- win：</span><br><span class="line">          - 第一次调用：返回当前的CPU时间</span><br><span class="line">          - 第二次调用：返回距离上一次调用所花费的时间</span><br><span class="line">    - linux：</span><br><span class="line">         - 直接返回程序运行到执行这个函数所花费的时间</span><br><span class="line">time.asctime(时间元组)</span><br><span class="line">time.strftime(格式，时间元组)  -&gt; 良好可读性的字符串</span><br><span class="line">将时间元组根据你指定的格式来成为一个良好可读性的字符串</span><br><span class="line">time.strptime(良好可读性的字符串，格式) -&gt; 时间元组</span><br><span class="line">把一个字符串变成时间元组。</span><br><span class="line"></span><br><span class="line">%Y: 年份 Year</span><br><span class="line">%m: 月份 month</span><br><span class="line">%d: 天数 day</span><br><span class="line"><span class="comment">#年月日，时分秒中，只有月和天是小写的，其他都是大写的</span></span><br><span class="line">%H：时 Hour</span><br><span class="line">%M：分 Minute</span><br><span class="line">%S：秒 Seconds</span><br><span class="line"><span class="comment">#以上六个死记硬背</span></span><br><span class="line"><span class="string">'%Y-%m-%d %H:%M:%S'</span></span><br><span class="line"></span><br><span class="line">%x 月/日/年</span><br><span class="line">%A: 星期的全称英语</span><br><span class="line">%a：星期的缩写英语</span><br><span class="line"></span><br><span class="line">%F 年/月/日</span><br><span class="line">%T 时/分/秒</span><br><span class="line"></span><br><span class="line">- strf  将时间元组变成字符串</span><br><span class="line">- strp 将字符串变成时间元组</span><br><span class="line">- 时间元组用来被处理，时间字符串只是一个展示的</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.time()</span><br><span class="line"><span class="number">1530412385.3557775</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.localtime()</span><br><span class="line">time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">1</span>, tm_hour=<span class="number">10</span>, tm_min=<span class="number">33</span>, tm_sec=<span class="number">14</span>, tm_wday=<span class="number">6</span>, tm_yday=<span class="number">182</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.asctime(time.localtime())</span><br><span class="line"><span class="string">'Sun Jul  1 10:33:39 2018'</span></span><br></pre></td></tr></table></figure><h3 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a><strong>datetime模块</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">datetime.datetime</span><br><span class="line">    - 处理年月日，时分秒的</span><br><span class="line">    - datetime.datetime.now()</span><br><span class="line">    - datetime.datetime.today()</span><br><span class="line">      - 获取当前的时间</span><br><span class="line">      - 返回值：datetime.datetime类型</span><br><span class="line">      - 返回值类型支持差值运算，用来求出两个时间区间的秒数，或者说你指定的时间单位</span><br><span class="line"></span><br><span class="line">datetime.date</span><br><span class="line">    - 处理年月日</span><br><span class="line">    - datetime.date.today()</span><br><span class="line">      - 年月日返回当前时间</span><br><span class="line">datetime.time</span><br><span class="line">    - 只能处理时分秒</span><br><span class="line">    - 多用来创建时分秒的时间</span><br><span class="line">    </span><br><span class="line">创建时间</span><br><span class="line">    datetime.datetime(<span class="number">2018</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">59</span>) 创建年月日，时分秒</span><br><span class="line">    datetime.date(<span class="number">2018</span>,<span class="number">6</span>,<span class="number">6</span>) 创建年月日</span><br><span class="line">    datetime.time(<span class="number">10</span>,<span class="number">50</span>,<span class="number">59</span>) 创建时分秒</span><br><span class="line">    </span><br><span class="line"><span class="comment">#我想求出再过20天是啥时候</span></span><br><span class="line">&gt;&gt;&gt; de = datetime.timedelta(days=<span class="number">25</span>)</span><br><span class="line">&gt;&gt;&gt; now = datetime.datetime.now()</span><br><span class="line">&gt;&gt;&gt; now + de </span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">286059</span>)</span><br><span class="line"><span class="comment">#结果中，会自动把天数，月数向上换算</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now()</span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">36</span>, <span class="number">190926</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>de=datetime.timedelta(days=<span class="number">20</span>)  <span class="comment">#求20天后日期时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now=datetime.datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now+de</span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">31</span>, <span class="number">53</span>, <span class="number">726784</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>de=datetime.timedelta(days=<span class="number">-20</span>)  <span class="comment">#使用-20求的是20天之前的日期时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now+de</span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">31</span>, <span class="number">53</span>, <span class="number">726784</span>)</span><br></pre></td></tr></table></figure><h3 id="随机模块random"><a href="#随机模块random" class="headerlink" title="随机模块random"></a><strong>随机模块random</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- random.randrange(stop)</span><br><span class="line">  - 生产出从<span class="number">0</span>到stop区间内的一个随机整数</span><br><span class="line">  - 不包含stop</span><br><span class="line">- random.randrange(start,stop,step)  </span><br><span class="line">  - 生产出从<span class="number">0</span>到stop区间内以步长为step的一个随机整数</span><br><span class="line">  - 不包含stop</span><br><span class="line">- random.randint(start,stop)</span><br><span class="line">  - 返回start和stop区间内的一个随机整数</span><br><span class="line">  - 起点和终点都可能被取到</span><br><span class="line">- random.getrandbits(num)</span><br><span class="line">  - 传入一个num值，<span class="number">0</span>-<span class="number">2</span>**num次方，去一个随机的整数</span><br><span class="line">  - 如果传递的num是<span class="number">1</span>，<span class="number">0</span> - <span class="number">2</span> ** <span class="number">1</span>  <span class="number">0</span> -<span class="number">2</span></span><br><span class="line">  - 不能取到终点：如果你传递的是<span class="number">2</span>**<span class="number">3</span>,那么取不到<span class="number">8</span></span><br><span class="line">- 随机浮点数</span><br><span class="line">- random.random()  -&gt;   &lt;<span class="number">1</span></span><br><span class="line">  - 返回介于<span class="number">0</span>到<span class="number">1</span>之间的浮点数</span><br><span class="line">- random.uniform(start,stop)</span><br><span class="line">  - 取出一个从start开始到stop结束的一个随机浮点数</span><br><span class="line">  - 这里start也可能出现</span><br><span class="line">  - stop的值是不取的</span><br><span class="line">- 随机序列</span><br><span class="line">- random.choice(seq) </span><br><span class="line">  - 从一个非空序列中随机选择一个元素</span><br><span class="line">  - 序列为空则报错</span><br><span class="line">  - 序列：字符串，列表，元组 支持索引操作的数据</span><br><span class="line">- random.shuffle(seq)</span><br><span class="line">  - 打乱序列的顺序</span><br><span class="line">- random.sample(seq,num)</span><br><span class="line">  - num是我要从seq中随机抽取数据的长度，num 一定要小于 len(seq)</span><br><span class="line">  - 从seq中 随机抽取num个数据 返回成一个列表</span><br><span class="line">  - num代表取几个</span><br></pre></td></tr></table></figure><h3 id="SYS模块"><a href="#SYS模块" class="headerlink" title="SYS模块"></a><strong>SYS模块</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sys.argv:</span><br><span class="line">获取当前程序的命令行参数</span><br><span class="line">命令行参数 就是你在执行.py脚本时传递的</span><br><span class="line">参数的列表</span><br><span class="line">sys.argv[<span class="number">0</span>]: 当前程序的名字</span><br><span class="line">sys.platform</span><br><span class="line">  - 用来输出当前的环境平台</span><br><span class="line">  - os.name</span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line">  直接退出程序</span><br><span class="line">sys.path</span><br><span class="line">  - 环境变量列表</span><br><span class="line">IO流处理：</span><br><span class="line">i: <span class="keyword">in</span> 进去</span><br><span class="line">- 键盘向程序输入内容</span><br><span class="line">- 写文件</span><br><span class="line">- 接受其他服务器反馈</span><br><span class="line">o: out 出来</span><br><span class="line">- print向屏幕打印</span><br><span class="line">- 读文件</span><br><span class="line">- 向其他服务器发送请求</span><br><span class="line">IO是影响程序性能,print操作是IO操作，那么尽量少在代码里print</span><br><span class="line"></span><br><span class="line">sys.stdin </span><br><span class="line">    - 标准输入   input</span><br><span class="line">    sys.stdin.readline()[:-<span class="number">1</span>] == input()</span><br><span class="line">sys.stdout</span><br><span class="line">- 标准输出 print</span><br><span class="line">sys.stdout.write(<span class="string">'abc\n'</span>) == print(<span class="string">'abc'</span>)</span><br><span class="line">sys.stderr</span><br><span class="line">- 标准出错</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;&lt;strong&gt;闭包&lt;/stron
      
    
    </summary>
    
      <category term="python" scheme="http://www.python100.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>常用函数</title>
    <link href="http://www.python100.com/2018/07/26/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <id>http://www.python100.com/2018/07/26/常见函数用法/</id>
    <published>2018-07-26T01:44:00.000Z</published>
    <updated>2018-07-31T15:52:10.545Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><h3 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">map(func, seq1[, seq2,…]) </span><br><span class="line">第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个集合。</span><br><span class="line">Python函数编程中的map()函数是将func作用于seq中的每一个元素，并将所有的调用的结果作为一个list返回。如果func为<span class="keyword">None</span>，作用同zip()。</span><br><span class="line"><span class="comment">#使用lambda</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">lambda</span> x: x % <span class="number">2</span>, range(<span class="number">7</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">一个seq时，可以使用filter()函数代替</span><br><span class="line">当seq多于一个时，map可以并行（注意是并行）地对每个seq执行</span><br><span class="line">每个seq的同一位置的元素同时传入一个多元的func函数之后，得到一个返回值，并将这个返回值存放在一个列表中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">lambda</span> x , y : x ** y, [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">[<span class="number">8</span>, <span class="number">16</span>, <span class="number">6</span>]     <span class="comment">#执行过程[2**3,4**2,6**1]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">lambda</span> x , y : (x ** y, x + y), [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">[(<span class="number">8</span>, <span class="number">5</span>), (<span class="number">16</span>, <span class="number">6</span>), (<span class="number">6</span>, <span class="number">7</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">None</span>, [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])  <span class="comment">#func为NONE时，就同zip一样了</span></span><br><span class="line">[(<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">2</span>), (<span class="number">6</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">其他用法例子：</span><br><span class="line">***将元组转换成list***</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(int, (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">***将字符串转换成list***</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(int, <span class="string">'1234'</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">***提取字典的key，并将结果存放在一个list中***</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(int, &#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>,<span class="number">3</span>:<span class="number">4</span>&#125;)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">***字符串转换成元组，并将结果以列表的形式返回***</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(tuple, <span class="string">'agdf'</span>)</span><br><span class="line">[(<span class="string">'a'</span>,), (<span class="string">'g'</span>,), (<span class="string">'d'</span>,), (<span class="string">'f'</span>,)]</span><br><span class="line"><span class="comment">#将小写转成大写</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">u_to_l</span> <span class="params">(s)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> s.upper()</span><br><span class="line"><span class="keyword">print</span> map(u_to_l,<span class="string">'asdfd'</span>)</span><br></pre></td></tr></table></figure><h3 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">zip函数返回一个以元组为元素的列表，其中第 i 个元组包含每个参数序列的第 i 个元素。返回的列表长度被截断为最短的参数序列的长度。只有一个序列参数时，它返回一个<span class="number">1</span>元组的列表。没有参数时，它返回一个空的列表。</span><br><span class="line">概括起来一句话：zip函数返回的是一个列表，但是列表里面的元素是由一个个元组构成的..</span><br><span class="line">做机器学习分类的时候，就可以利用zip函数，将我们的数据点与我们的数据点对应的标签进行关联..</span><br><span class="line"><span class="comment">#例一：</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">z = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">xyz = zip(x, y, z)</span><br><span class="line"><span class="keyword">print</span> xyz</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="comment">#例二：</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x = zip(x)</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,)]</span><br><span class="line"><span class="comment">#例三：</span></span><br><span class="line">x = zip()</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line">[]</span><br><span class="line"><span class="comment">#例四：</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">z = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">xyz = zip(x, y, z)</span><br><span class="line">u = zip(*xyz)</span><br><span class="line"><span class="keyword">print</span> u</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line">一般认为这是一个unzip的过程，它的运行机制是这样的：</span><br><span class="line">在运行zip(*xyz)之前，xyz的值是：[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]</span><br><span class="line">那么，zip(*xyz) 等价于 zip((<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>))</span><br><span class="line">所以，运行结果是：[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="comment">#例五：</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">r = zip(* [x] * <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> r</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)]</span><br><span class="line">它的运行机制是这样的：</span><br><span class="line">[x]生成一个列表的列表，它只有一个元素x</span><br><span class="line">[x] * <span class="number">3</span>生成一个列表的列表，它有<span class="number">3</span>个元素，[x, x, x]</span><br><span class="line">zip(* [x] * <span class="number">3</span>)的意思就明确了，zip(x, x, x)</span><br></pre></td></tr></table></figure><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">result1=random.random() <span class="comment">#随机生成一个浮点数[0,1)</span></span><br><span class="line">result2=random.randint(<span class="number">1</span>, <span class="number">10</span>) <span class="comment">#产生1-10的一个随机整数,包含1和10</span></span><br><span class="line">result3=random.uniform(<span class="number">1.1</span>, <span class="number">2.1</span>) <span class="comment">#产生1.1-2.2之间的随机浮点数</span></span><br><span class="line">result4=random.choice(<span class="string">"python"</span>)  <span class="comment">#参数是一个可以迭代的类型，从参数中随机选一个元素</span></span><br><span class="line">result5=random.randrange(<span class="number">1</span>,<span class="number">50</span>,<span class="number">2</span>) <span class="comment">#随机产生1-50，间隔为2随机整数，左闭右开，不包含50</span></span><br><span class="line">test_list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">random.shuffle(test_list) <span class="comment">#需要注意的是这个操作是在原来参数的基础上操作的，不会返回新的数据</span></span><br><span class="line">print(<span class="string">"test_list:"</span>+str(test_list))</span><br><span class="line">test_list:[<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>]   <span class="comment">#shuffle就是将原有列表的顺序打乱，也就是重新洗牌的功能</span></span><br><span class="line">random.sample(seq,n)  <span class="comment">#可以从指定的序列中，随机的截取指定长度的片断，不作原地修改。</span></span><br></pre></td></tr></table></figure><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当前使用平台：</span></span><br><span class="line">os.name  <span class="comment">#返回当前使用平台的代表字符，Windows用'nt'表示，Linux用'posix'表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前路径和文件</span></span><br><span class="line">os.getcwd()  <span class="comment">#返回当前工作目录</span></span><br><span class="line">os.listdir(path)  <span class="comment">#返回path目录下所有文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#abspath()  将相对路径转化为绝对路径</span></span><br><span class="line">path = <span class="string">'./boys'</span><span class="comment">#相对</span></span><br><span class="line">result = os.path.abspath(path)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#系统操作：</span></span><br><span class="line">os.system()  <span class="comment">#运行shell命令</span></span><br><span class="line">&gt;&gt;&gt;os.system(<span class="string">'cmd'</span>)  <span class="comment">#Windows下打开终端</span></span><br><span class="line">&gt;&gt;&gt;os.system(<span class="string">'ls'</span>)  <span class="comment">#Linux下查看当前目录所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件名或目录：</span></span><br><span class="line">os.path.split(path)  <span class="comment">#将path的目录和文件名分开为元组，split() 将一个完整的路径切割成目录部分和主体部分</span></span><br><span class="line">os.path.join(path1,path2,...)  <span class="comment">#将path1，怕path2，...进行组合，若path2为绝对路径，则会将path1删除</span></span><br><span class="line">os.path.dirname(path)  <span class="comment">#返回path中的目录（文件夹部分），结果不包含'\'</span></span><br><span class="line">os.path.basename(path)  <span class="comment">#返回path中的文件名</span></span><br><span class="line"><span class="comment">#dirname()  获取完整路径当中的目录部分  &amp;  basename()获取完整路径当中的主体部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建目录：</span></span><br><span class="line">os.mkdir(path)  <span class="comment">#创建path目录（只能创建一级目录，如'F:\XXX\WWW'）,在XXX目录下创建WWW目录</span></span><br><span class="line">os.makedirs(path)  <span class="comment">#创建多级目录（如'F:\XXX\SSS'），在F盘下创建XXX目录，继续在XXX目录下创建SSS目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除文件或目录：</span></span><br><span class="line">os.remove(path)  <span class="comment">#删除文件（必须是文件）</span></span><br><span class="line">os.rmdir(path)  <span class="comment">#删除path目录(只能删除一级目录，如'F:\XXX\SSS'),只删除SSS目录，只能删除空目录</span></span><br><span class="line">os.removedirs(path)  <span class="comment">#删除多级目录（如'F:\XXX\SSS'）,必须为空目录，删除SSS、FFF目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更改路径：</span></span><br><span class="line">os.chdir(path)  <span class="comment">#将当前工作目录更改为指定路径path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件时间：</span></span><br><span class="line">os.path.getmtime(path)  <span class="comment">#返回文件或目录的最后修改时间，结果为秒数</span></span><br><span class="line">os.path.getatime(path)  <span class="comment">#返回文件或目录的最后访问时间，结果为秒数</span></span><br><span class="line">os.path.getctime(path)  <span class="comment">#返回文件或目录得创建时间，结果为秒数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件大小：</span></span><br><span class="line">os.path.getsize(path)  <span class="comment">#返回文件的大小，若是目录则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件：</span></span><br><span class="line">os.path.exists(path)  <span class="comment">#判断path是否存在，存在返回True,不存在返回False</span></span><br><span class="line">os.path.isfile(path)  <span class="comment">#判断path是否为文件，是返回True,不是返回False</span></span><br><span class="line">os.path.isdir(path)  <span class="comment">#判断path是否目录，是返回True，不是返回False</span></span><br><span class="line">os.path.islink(path) <span class="comment">#islink() 检测是否是链接</span></span><br><span class="line">os.path.isabs(path) <span class="comment">#isabs() 检测一个路径是否是绝对路径</span></span><br><span class="line">os.path.samefile(path1,path2) <span class="comment">#samefile() 检测2个路径是否是同一个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取文件和目录：</span></span><br><span class="line">os.walk(path)   <span class="comment">#递归返回path下的目录（包括path目录）、子目录、文件名的三元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获得shell命令返回值：</span></span><br><span class="line">fp=os.popen(cmd)   <span class="comment">#打开命令cmd或从命令cmd打开管道，返回值是连接到管道的文件对象</span></span><br><span class="line">rlt=fp.read()或 rlt=fp.readlines()  <span class="comment">#读取结果</span></span><br><span class="line">os.system(<span class="string">'dir'</span>)  <span class="comment">#获取系统命令的返回结果，但无法保存到一个变量里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rename() 文件或文件夹重命名</span></span><br><span class="line">os.rename(<span class="string">'/home/sy/a'</span>,<span class="string">'/home/sy/alibaba'</span>）</span><br><span class="line">os.rename(<span class="string">'02.txt'</span>,<span class="string">'002.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#stat() 获取文件或者文件夹的信息</span></span><br><span class="line">result = os.stat(<span class="string">'/home/sy/PycharmProject/Python3/10.27/01.py)</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">#getenv() 获取系统的环境变量</span></span><br><span class="line"><span class="string">result = os.getenv('</span>PATH<span class="string">')</span></span><br><span class="line"><span class="string">print(result.split('</span>:<span class="string">'))</span></span><br><span class="line"><span class="string">                 </span></span><br><span class="line"><span class="string">#putenv() 将一个目录添加到环境变量中(临时增加仅对当前脚本有效)</span></span><br><span class="line"><span class="string">os.putenv('</span>PATH<span class="string">','</span>/home/sy/下载<span class="string">')</span></span><br><span class="line"><span class="string">os.system('</span>syls<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#常用变量</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; os.curdir #curdir  表示当前文件夹   .表示当前文件夹  一般情况下可以省略</span></span><br><span class="line"><span class="string">'</span>.<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; os.pardir #pardir  表示上一层文件夹   ..表示上一层文件夹  不可省略!</span></span><br><span class="line"><span class="string">'</span>..<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; os.name #name 获取代表操作系统的名称字符串</span></span><br><span class="line"><span class="string">'</span>nt<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; os.sep #sep 获取系统路径间隔符号  window -&gt;\    linux -&gt;/</span></span><br><span class="line"><span class="string">'</span>\\<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; os.extsep #extsep 获取文件名称和后缀之间的间隔符号  window &amp; linux -&gt; .</span></span><br><span class="line"><span class="string">'</span>.<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; repr(os.linesep) #linesep  获取操作系统的换行符号  window -&gt; \r\n  linux/unix -&gt; \n</span></span><br><span class="line"><span class="string">"'</span>\\r\\n<span class="string">'"</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">&gt;&gt;&gt; path = '</span>/home/sy/<span class="number">000.</span>py<span class="string">'   </span></span><br><span class="line"><span class="string">#splitext() 将一个路径切割成文件后缀和其他两个部分,主要用于获取文件的后缀</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; result = os.path.splitext(path)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(result)</span></span><br><span class="line"><span class="string">('</span>/home/sy/<span class="number">000</span><span class="string">', '</span>.py<span class="string">')</span></span><br></pre></td></tr></table></figure><h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sys.argv: </span></span><br><span class="line">实现从程序外部向程序传递参数。</span><br><span class="line">可以用sys.argv获取当前正在执行的命令行参数的参数列表(list)</span><br><span class="line">sys.argv[<span class="number">0</span>] 当前程序名</span><br><span class="line">sys.argv[<span class="number">1</span>] 第一个参数</span><br><span class="line">sys.argv[<span class="number">0</span>] 第二个参数</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.exit([arg]): </span></span><br><span class="line">程序中间的退出，arg=<span class="number">0</span>为正常退出。</span><br><span class="line">调用sys.exit(n)可以中途退出程序，当参数非<span class="number">0</span>时，会引发一个SystemExit异常，从而可以在主程序中捕获该异常。</span><br><span class="line">sys.getdefaultencoding(): 获取系统当前编码，一般默认为ascii。</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.setdefaultencoding():</span></span><br><span class="line">设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding(<span class="string">'utf8'</span>)，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.getfilesystemencoding(): </span></span><br><span class="line">获取文件系统使用编码方式，Windows下返回<span class="string">'mbcs'</span>，mac下返回<span class="string">'utf-8'</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.path: </span></span><br><span class="line">获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中<span class="keyword">import</span>时正确找到。</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.platform: </span></span><br><span class="line">获取当前系统平台。如win32表示是Windows <span class="number">32</span>bit操作系统，linux2表示是linux平台；</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.stdin,sys.stdout,sys.stderr: </span></span><br><span class="line">stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而<span class="keyword">print</span> 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdin.readline()  <span class="comment">#从标准输入读一行</span></span><br><span class="line">sfdsafkjl</span><br><span class="line"><span class="string">'sfdsafkjl\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">"AAA"</span>)  </span><br><span class="line">AAA3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">"BBBBBb"</span>)</span><br><span class="line">BBBBBb6</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.modules</span></span><br><span class="line">功能：sys.modules是一个全局字典，该字典是python启动后就加载在内存中。每当程序员导入新的模块，sys.modules将自动记录该模块。当第二次再导入该模块时，python会直接到字典中查找，从而加快了程序运行的速度。它拥有字典所拥有的一切方法。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules.keys()   <span class="comment">#返回所有已经导入模块列表</span></span><br><span class="line">dict_keys([<span class="string">'builtins'</span>, <span class="string">'sys'</span>, <span class="string">'_frozen_importlib'</span>, <span class="string">'_imp'</span>, <span class="string">'_warnings'</span>, <span class="string">'_thread'</span>, <span class="string">'_weakref'</span>, <span class="string">'_frozen_importlib_external'</span>, <span class="string">'_io'</span>, <span class="string">'marshal'</span>, <span class="string">'nt'</span>, <span class="string">'winreg'</span>, <span class="string">'zipimport'</span>, <span class="string">'encodings'</span>, <span class="string">'codecs'</span>, <span class="string">'_codecs'</span>, <span class="string">'encodings.aliases'</span>, <span class="string">'encodings.utf_8'</span>, <span class="string">'_signal'</span>, <span class="string">'__main__'</span>, <span class="string">'encodings.latin_1'</span>, <span class="string">'io'</span>, <span class="string">'abc'</span>, <span class="string">'_weakrefset'</span>, <span class="string">'site'</span>, <span class="string">'os'</span>, <span class="string">'errno'</span>, <span class="string">'stat'</span>, <span class="string">'_stat'</span>, <span class="string">'ntpath'</span>, <span class="string">'genericpath'</span>, <span class="string">'os.path'</span>, <span class="string">'_collections_abc'</span>, <span class="string">'_sitebuiltins'</span>, <span class="string">'sysconfig'</span>, <span class="string">'_bootlocale'</span>, <span class="string">'_locale'</span>, <span class="string">'encodings.gbk'</span>, <span class="string">'_codecs_cn'</span>, <span class="string">'_multibytecodec'</span>, <span class="string">'atexit'</span>, <span class="string">'pydoc'</span>, <span class="string">'importlib'</span>, <span class="string">'importlib._bootstrap'</span>, <span class="string">'importlib._bootstrap_external'</span>, <span class="string">'types'</span>, <span class="string">'functools'</span>, <span class="string">'_functools'</span>, <span class="string">'collections'</span>, <span class="string">'operator'</span>, <span class="string">'_operator'</span>, <span class="string">'keyword'</span>, <span class="string">'heapq'</span>, <span class="string">'_heapq'</span>, <span class="string">'itertools'</span>, <span class="string">'reprlib'</span>, <span class="string">'_collections'</span>, <span class="string">'weakref'</span>, <span class="string">'collections.abc'</span>, <span class="string">'warnings'</span>, <span class="string">'importlib.machinery'</span>, <span class="string">'importlib.util'</span>, <span class="string">'importlib.abc'</span>, <span class="string">'contextlib'</span>, <span class="string">'inspect'</span>, <span class="string">'ast'</span>, <span class="string">'_ast'</span>, <span class="string">'dis'</span>, <span class="string">'opcode'</span>, <span class="string">'_opcode'</span>, <span class="string">'enum'</span>, <span class="string">'linecache'</span>, <span class="string">'tokenize'</span>, <span class="string">'re'</span>, <span class="string">'sre_compile'</span>, <span class="string">'_sre'</span>, <span class="string">'sre_parse'</span>, <span class="string">'sre_constants'</span>, <span class="string">'copyreg'</span>, <span class="string">'token'</span>, <span class="string">'pkgutil'</span>, <span class="string">'platform'</span>, <span class="string">'subprocess'</span>, <span class="string">'time'</span>, <span class="string">'signal'</span>, <span class="string">'threading'</span>, <span class="string">'traceback'</span>, <span class="string">'msvcrt'</span>, <span class="string">'_winapi'</span>, <span class="string">'urllib'</span>, <span class="string">'urllib.parse'</span>, <span class="string">'tempfile'</span>, <span class="string">'shutil'</span>, <span class="string">'fnmatch'</span>, <span class="string">'posixpath'</span>, <span class="string">'zlib'</span>, <span class="string">'bz2'</span>, <span class="string">'_compression'</span>, <span class="string">'_bz2'</span>, <span class="string">'lzma'</span>, <span class="string">'_lzma'</span>, <span class="string">'random'</span>, <span class="string">'math'</span>, <span class="string">'hashlib'</span>, <span class="string">'_hashlib'</span>, <span class="string">'_blake2'</span>, <span class="string">'_sha3'</span>, <span class="string">'bisect'</span>, <span class="string">'_bisect'</span>, <span class="string">'_random'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.modules[<span class="string">"os"</span>])</span><br><span class="line">&lt;module <span class="string">'os'</span> <span class="keyword">from</span> <span class="string">'D:\\Program Files (x86)\\Python36-35\\lib\\os.py'</span>&gt;</span><br><span class="line"><span class="comment">#还可以通过key值获取模块所处路径</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.hexversion <span class="comment">#获取python解释器的版本值，16进制格式</span></span><br><span class="line"><span class="number">50726384</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.version <span class="comment">#获取python解释器的版本信息</span></span><br><span class="line"><span class="string">'3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 16:07:46) [MSC v.1900 32 bit (Intel)]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.copyright <span class="comment">#返回python版权相关信息</span></span><br><span class="line"><span class="string">'Copyright (c) 2001-2018 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n\nCopyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\nAll Rights Reserved.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.api_version <span class="comment">#解释器的C的API版本</span></span><br><span class="line"><span class="number">1013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.version_info  <span class="comment">#python版本信息，final表示最终版本，candidate表示候选，还有后续发行版本</span></span><br><span class="line">sys.version_info(major=<span class="number">3</span>, minor=<span class="number">6</span>, micro=<span class="number">5</span>, releaselevel=<span class="string">'final'</span>, serial=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.executable  <span class="comment">#返回python解释器的路径</span></span><br><span class="line"><span class="string">'D:\\Program Files (x86)\\Python36-35\\python.exe'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getwindowsversion() <span class="comment">#获取windows的版本信息</span></span><br><span class="line">sys.getwindowsversion(major=<span class="number">10</span>, minor=<span class="number">0</span>, build=<span class="number">17134</span>, platform=<span class="number">2</span>, service_pack=<span class="string">''</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h3 id=&quot;map函数&quot;&gt;&lt;a href=&quot;#map函数&quot; class=&quot;headerlink&quot; title=&quot;map函数&quot;&gt;&lt;/a&gt;map函数&lt;/h
      
    
    </summary>
    
      <category term="python" scheme="http://www.python100.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>python基础数据类型</title>
    <link href="http://www.python100.com/2018/07/26/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E8%83%8C%E8%AF%B5/"/>
    <id>http://www.python100.com/2018/07/26/第一阶段背诵/</id>
    <published>2018-07-26T01:44:00.000Z</published>
    <updated>2018-07-31T15:51:57.633Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><p><strong>数据类型：数字，字符串，列表，元组，集合，字典</strong></p><h5 id="数字"><a href="#数字" class="headerlink" title="数字"></a><strong>数字</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">整数：int</span><br><span class="line">浮点数：float</span><br><span class="line">布尔值：大小写敏感  非空非零为真，<span class="number">0</span>或空为假</span><br><span class="line">复数：以J或j结尾，</span><br><span class="line"></span><br><span class="line">type(判断谁)</span><br><span class="line">查看类型</span><br></pre></td></tr></table></figure><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">字符串里面的东西是无意义的</span><br><span class="line">索引：从左到右，从<span class="number">0</span>开始，从右到左，从<span class="number">-1</span>开始</span><br><span class="line">切片：左闭右开</span><br><span class="line">    a[start:stop(不取):step]</span><br><span class="line">    step 步长  start起点 stop终点(不取)</span><br><span class="line">同符号情况下，如果步长是负数，那么应该从大到小</span><br><span class="line">start &gt; stop</span><br><span class="line">如果步长是个正的，那么从小大到</span><br><span class="line">start &gt; stop</span><br><span class="line">字符串是一个不可变数据类型</span><br><span class="line">一般对于不可变数据的函数处理，操作只会返回一个新的值，不会影响自己本身</span><br><span class="line">字符串支持 加法和乘法  分别是拼接和多次输出</span><br></pre></td></tr></table></figure><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">列表(list)</span><br><span class="line">语法:  a = [1,2,3,4,5]</span><br><span class="line">支持索引和切片</span><br><span class="line">一个列表里可以存储任意的数据类型</span><br><span class="line">可以创建一个空列表</span><br><span class="line">列表可变，可以通过索引访问修改</span><br><span class="line">通过切片重新赋值</span><br><span class="line">切片修改的时候，只要给的值和坑对应了就行</span><br><span class="line">列表的范围赋值：</span><br><span class="line">切片赋值：</span><br><span class="line">步长绝对值为1时，取一个数据集合的每一个值，放置到这个之前的位置</span><br><span class="line">步长绝对值大于1时，一个萝卜一个坑，要一一对应</span><br><span class="line">切片的步长包含起点</span><br></pre></td></tr></table></figure><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a><strong>元组</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">元组(tuple) </span><br><span class="line">()</span><br><span class="line">不可变</span><br><span class="line">创建一个只含有一个数据的元组</span><br><span class="line">a = (&apos;a&apos;,)</span><br><span class="line">只含有单个数据的元组，要加逗号</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">字符串、列表、元组  都是有顺序的一个数据集，也就是有序的序列</span><br><span class="line">序列就是有顺序的数据集。字符串 列表 元组都是序列。</span><br><span class="line">可变数据：  列表 （可变而的是列表中的数据，而不是这个对象）</span><br><span class="line">不可变数据：  数、字符串、元组</span><br><span class="line">可变不可变性质:不可变的是类型其中的数据</span><br><span class="line">不可变数据对象，不可变的是指向关系，不是这个变量名</span><br><span class="line">不可变的变量，变量在变的时候，重新给了新的指向关系，原来的不可变指向关系被抛弃了！</span><br><span class="line">可变的变量，直接就能变指向关系</span><br><span class="line"></span><br><span class="line">iterable</span><br><span class="line">可迭代的对象</span><br><span class="line">含有数据是一个集合</span><br><span class="line">数据前后可以互相找到</span><br><span class="line">有序的序列就是可迭代的对象，如字符串，列表和元组。</span><br></pre></td></tr></table></figure><h5 id="序列"><a href="#序列" class="headerlink" title="序列"></a><strong>序列</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">序列包含：字符串，元组，列表</span><br><span class="line">序列支持索引和切片</span><br><span class="line">序列是可迭代的对象</span><br></pre></td></tr></table></figure><h5 id="变量的本质"><a href="#变量的本质" class="headerlink" title="变量的本质"></a><strong>变量的本质</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">变量本质：</span><br><span class="line">变量不需要先定义(不需要声明大小类型)，可以直接使用，直接赋值a = <span class="number">1</span></span><br><span class="line">变量可以重复赋值，哪怕更换类型</span><br><span class="line">同时可以给多个变量赋值</span><br><span class="line">命名风格，不要和模块名，常用函数 <span class="keyword">print</span>，不能用数字开头，字母，数字，下划线，在python3，中文也可以做变量名</span><br><span class="line">__num__ 特殊的python内置变量</span><br><span class="line">不支持自增和自减</span><br><span class="line">引用计数： 就是针对一些不可变数据</span><br><span class="line">    变量的内存分配方式</span><br><span class="line">变量在创建的时候，首先不会直接开辟空间，会先去查找，已有的空间</span><br><span class="line">如果有这个数据了，那么他不会创建新的，而是利用已有的</span><br><span class="line"><span class="keyword">del</span>语句可以删除一个变量名，但是不会释放变量数据占据的空间</span><br><span class="line"><span class="keyword">del</span>语句还把引用计数减<span class="number">1</span>了，数据的空间只有在引用计数真正为<span class="number">0</span>的时候才会释放</span><br><span class="line">python中的del语句释放数据内存? x</span><br><span class="line">查看变量的内存地址：id(变量名)</span><br><span class="line"><span class="keyword">import</span> sys sys.getrefcount()  查看变量的引用计数</span><br><span class="line">注意：</span><br><span class="line">python解释器有没有在用</span><br><span class="line">赋值语句是否是单独创建，还是借用别人</span><br></pre></td></tr></table></figure><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a><strong>引用计数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">引用计数：</span><br><span class="line">常见变量会使用引用计数的方式分配内存，</span><br><span class="line">一个变量创建的时候，不会去直接创建一个新的地址，先去查找已有的(不可变数据：元组，字符串，整数)</span><br><span class="line"><span class="keyword">del</span> 引用计数减一</span><br><span class="line">当一个对象真正最后引用计数为<span class="number">0</span>的时候，才会被释放，延迟性</span><br><span class="line"><span class="keyword">del</span>切断了变量名和具体数据的内存地址的连接，该变量所使用的数据的引用计数减去<span class="number">1</span></span><br><span class="line">使用引用计数的原因：定义变量开辟空间，变量多，占用多，值相同的内存空间，相互共享，而不用创建</span><br></pre></td></tr></table></figure><h5 id="运算表达式"><a href="#运算表达式" class="headerlink" title="运算表达式"></a><strong>运算表达式</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">算数表达式:</span><br><span class="line">+ - * /   //  %  ** </span><br><span class="line">逻辑表达式 返回值类型是Bool</span><br><span class="line">a = <span class="number">1</span>非空非<span class="number">0</span>为真</span><br><span class="line">    b = <span class="number">0</span>  <span class="number">0</span>或空为假</span><br><span class="line">    <span class="keyword">not</span> a 逻辑非</span><br><span class="line">    a <span class="keyword">and</span> b  逻辑与</span><br><span class="line">    a <span class="keyword">or</span> b 逻辑或</span><br><span class="line">    a <span class="keyword">is</span> b  a和b是不是同一个对象</span><br><span class="line">    a <span class="keyword">is</span> <span class="keyword">not</span> b  a和b不是同一个对象</span><br><span class="line">    </span><br><span class="line"><span class="keyword">is</span>不光是判断值相同，还要判断是否是同一地址</span><br><span class="line">与：and -&gt; False 真真为真，真假为假，假假为假，只要有假则为假</span><br><span class="line">或：or -&gt; True真真为真，真假为真，假假为假，只要有真则为真</span><br><span class="line">关系表达式 如果不是数字来判断，那么判断的就是阿斯克码</span><br><span class="line">表达式          汉译              返回值类型</span><br><span class="line">    a==b         a,b是否值相等            bool</span><br><span class="line">    a!=b         a,b是否值不相等          bool</span><br><span class="line">    a&lt;&gt;b         a,b是否值不相等          bool</span><br><span class="line">    a&gt;b          a是否大于b               bool</span><br><span class="line">    a&lt;b          a是否小于b               bool</span><br><span class="line">    a&gt;=b          a是否大于等于b          bool</span><br><span class="line">    a&lt;=b          a是否小于等于b          bool</span><br><span class="line">    </span><br><span class="line">    小写字母a的十进制 ascii：<span class="number">97</span></span><br><span class="line">    大写字母A的十进制 ascii：<span class="number">65</span></span><br><span class="line">位运算：</span><br><span class="line">表达式           汉译               操作解释</span><br><span class="line">    ~a               按位取反             -(a+<span class="number">1</span>)</span><br><span class="line">    a&lt;&lt;n             左移n位              -</span><br><span class="line">    a&gt;&gt;n             右移n位              -</span><br><span class="line">    a&amp;b              a和b按位与           11-&gt;1  00-&gt;0  01-&gt;0(都是1时才得1)</span><br><span class="line">    a|b              a和b按位或           01-&gt;1  11-&gt;1  00-&gt;0(只要有1就得1)</span><br><span class="line">    a^b              a和b按位异或         01-&gt;1  11-&gt;0  00-&gt;0(相同得0，不同得1)</span><br><span class="line"></span><br><span class="line">    计算机中存储的都是二进制</span><br><span class="line">所有的运算，到最后，都是二进制的补码在运算，补码才是真正在计算机里存储的，</span><br><span class="line">符号位参与运算，计算完成的结果也是补码</span><br><span class="line">    原码，反码，补码</span><br><span class="line">    正数的原码，反码，补码都是本身</span><br><span class="line">    负数：</span><br><span class="line">        原码：<span class="number">1000</span> <span class="number">0001</span> 最高位是符号位</span><br><span class="line">        反码：<span class="number">1111</span> <span class="number">1110</span> 符号位不变，其余各位取反</span><br><span class="line">        补码：<span class="number">1111</span> <span class="number">1111</span> <span class="number">-1</span> 补码是反码加一</span><br><span class="line">所有的运算都是 补码在做运算</span><br><span class="line">       <span class="number">1</span>              <span class="number">-1</span></span><br><span class="line">    原码  <span class="number">0000</span> <span class="number">0001</span>     <span class="number">1000</span> <span class="number">0001</span> </span><br><span class="line">    反码  <span class="number">0000</span> <span class="number">0001</span>     <span class="number">1111</span> <span class="number">1110</span>  负数的反码 符号为不变，其余各位取反</span><br><span class="line">    补码  <span class="number">0000</span> <span class="number">0001</span>     <span class="number">1111</span> <span class="number">1111</span>  反码+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    对补码在求一次补码即可求出原码</span><br><span class="line">    </span><br><span class="line">    a &gt;&gt; n 向右移动  位移的位置包含起点，其实就位移了一位。类似切片中的步长，步长计算也包含起点</span><br><span class="line">    ------------------------</span><br><span class="line">    a &amp; b  a和b按位与 ，位上的值，只要有<span class="number">0</span>，结果为<span class="number">0</span></span><br><span class="line">    a | b   a和b按位或，位上的值，只要有<span class="number">1</span>，结果为<span class="number">1</span></span><br><span class="line">    a ^ b  a和b按位异或，只要值不同，结果才为<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    所有的运算，都是补码在运算！！！</span><br></pre></td></tr></table></figure><h5 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a><strong>条件分支语句</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> …. <span class="keyword">else</span>… 语句中 如果有一个条件满足，其他不会执行</span><br><span class="line"><span class="keyword">else</span>条件也可以没有,<span class="keyword">elif</span>条件也可以没有</span><br><span class="line"><span class="keyword">elif</span> 可以 继续细分条件</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>条件语句返回值为<span class="keyword">True</span>时，执行语句才会被执行</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 访问可迭代的对象</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> 可迭代的对象(str,list,tuple):</span><br><span class="line">一次次的从里面取一个值</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">条件满足时，直接跳出循环</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">条件满足时，只是跳过本次循环</span><br><span class="line">循环搭配<span class="keyword">else</span>语句来使用，这里<span class="keyword">else</span>语句中的内容会在循环正常结束之后来执行</span><br><span class="line"></span><br><span class="line"><span class="comment">#for var in seq:</span></span><br><span class="line">    <span class="comment">#遍历一个序列(前后数据间有顺序关系)，然后去其中一次次的拿取值</span></span><br><span class="line">    <span class="comment">#for循环一般不用来实现死循环</span></span><br><span class="line">    <span class="comment">#for次数一般由我们的数据长度来决定</span></span><br><span class="line">    <span class="comment">#for循环每次会向后遍历</span></span><br><span class="line">    <span class="comment">#for循环的死循环 需要构建环形或者无限延申的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#from itertools import cycle</span></span><br><span class="line">    <span class="comment">#cycle([1,2,3]) -&gt; 圈</span></span><br></pre></td></tr></table></figure><h5 id="python3和python2区别"><a href="#python3和python2区别" class="headerlink" title="python3和python2区别"></a><strong>python3和python2区别</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">python3:</span><br><span class="line">print() %s接收到的可以是任意的数据类型</span><br><span class="line">%d 用来输出整数</span><br><span class="line">%f 用来输出浮点数，%.100f 控制输出的精度</span><br><span class="line">input()所有接收到的都是字符串</span><br><span class="line">range() 抽象,不会生成数据，只有在使用的时候才会生成数据</span><br><span class="line">python2:</span><br><span class="line">    print()</span><br><span class="line">    input()  有效的数据，代码输入进来也是有效的，缓冲区溢出攻击</span><br><span class="line">    raw_input() 所有接收到的都是字符串</span><br><span class="line">    range() 具象的，会立即创建出实际的数据，很耗费内存</span><br><span class="line">xrange() 抽象的，不会生成数据，只有在使用的时候才会生成数据</span><br></pre></td></tr></table></figure><h5 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a><strong>深浅拷贝</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">拷贝： 可变数据对象的指针被共享了(引用计数)，所以需要我们引入拷贝</span><br><span class="line">创建变量的时候，我们希望的只是值相等，而不是互相影响</span><br><span class="line">a[:] 这是返回了一个新的列表，只是值和原先的a是一样的</span><br><span class="line">浅拷贝的方法：</span><br><span class="line">切片拷贝，只能是复制浅层的数据对象，返回一个新的地址中的数据，内层的数据并没有实现拷贝</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">    b=a[:]</span><br><span class="line">    <span class="keyword">import</span> copy</span><br><span class="line">    b=copy.copy(a)</span><br><span class="line">深拷贝：</span><br><span class="line">深拷贝可以实现地址不同</span><br><span class="line">    深拷贝，拷贝的都是列表中的指向关系，对应列表中的数据还是使用引用计数的</span><br><span class="line">    <span class="keyword">import</span> copy</span><br><span class="line">    a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>]]</span><br><span class="line">    b = copy.deepcopy(a)</span><br></pre></td></tr></table></figure><h5 id="作业：使用切片实现深拷贝"><a href="#作业：使用切片实现深拷贝" class="headerlink" title="作业：使用切片实现深拷贝"></a><strong>作业：使用切片实现深拷贝</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>]]]</span><br><span class="line">b=a[:]</span><br><span class="line">b[<span class="number">-1</span>]=a[<span class="number">-1</span>][:]  <span class="comment">#[1,2,3,[1,2,[1,2],3]]</span></span><br><span class="line">b[<span class="number">-1</span>][<span class="number">-1</span>]=a[<span class="number">-1</span>][<span class="number">-1</span>][:]   <span class="comment">#[1,2,[1,2],3]</span></span><br><span class="line">b[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">2</span>]=a[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">2</span>][:]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"a:"</span>,a)</span><br><span class="line">print(<span class="string">"b:"</span>,b)</span><br><span class="line">print(<span class="string">"------------"</span>)</span><br><span class="line">b[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">2</span>][<span class="number">-1</span>]=<span class="string">'abc'</span></span><br><span class="line">print(<span class="string">"a:"</span>,a)</span><br><span class="line">print(<span class="string">"b:"</span>,b)</span><br></pre></td></tr></table></figure><h5 id="作业：求出mylist中每一个值"><a href="#作业：求出mylist中每一个值" class="headerlink" title="作业：求出mylist中每一个值"></a><strong>作业：求出mylist中每一个值</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,(<span class="string">'a'</span>,<span class="string">'b'</span>)],<span class="string">'c'</span>,<span class="string">'def'</span>]</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="keyword">if</span> type(var) == type([<span class="number">1</span>]):<span class="comment">#print('----',var)#当前满足列表</span></span><br><span class="line">        <span class="keyword">for</span> var1 <span class="keyword">in</span> var:</span><br><span class="line">            <span class="keyword">if</span> type(var1) == type((<span class="number">1</span>,)):<span class="comment">#var1此时是元组</span></span><br><span class="line">                <span class="keyword">for</span> var2 <span class="keyword">in</span> var1:</span><br><span class="line">                    print(var2)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(var1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(var)</span><br><span class="line">print(<span class="string">'---------------------'</span>)</span><br></pre></td></tr></table></figure><h5 id="作业：两数交换有几种办法"><a href="#作业：两数交换有几种办法" class="headerlink" title="作业：两数交换有几种办法"></a><strong>作业：两数交换有几种办法</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">两数交换有几种办法？分别列举</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line">最笨的方法：x=a a=b b=x</span><br><span class="line">方法一：a,b=b,a</span><br><span class="line">方法二：a=a+b  a=a-b b=a-b</span><br><span class="line">方法三：a=a*b  b=a/b a=a/b</span><br><span class="line">方法四：a=a|b  b=a^b a=a^b</span><br></pre></td></tr></table></figure><h5 id="作业：实现99乘法表"><a href="#作业：实现99乘法表" class="headerlink" title="作业：实现99乘法表"></a><strong>作业：实现99乘法表</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> i&gt;j:</span><br><span class="line">print(<span class="string">"%s x %s = %s   "</span>%(j,i,i*j),end=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print()</span><br><span class="line">j+=<span class="number">1</span></span><br><span class="line">i+=<span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="作业：机器学习代码"><a href="#作业：机器学习代码" class="headerlink" title="作业：机器学习代码"></a><strong>作业：机器学习代码</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">"data.pkl"</span>):</span><br><span class="line">f=open(<span class="string">"data.pkl"</span>,<span class="string">"rb"</span>)</span><br><span class="line">mydict=pickle.load(f)</span><br><span class="line"><span class="comment"># print("数据已存在！")</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">mydict=&#123;<span class="string">'hello'</span>:<span class="string">'hello'</span>&#125;</span><br><span class="line">f=open(<span class="string">"data.pkl"</span>,<span class="string">"wb"</span>)</span><br><span class="line">pickle.dump(mydict,f)</span><br><span class="line"><span class="comment"># print("新建数据库信息！")</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">ques=input(<span class="string">"请输入困扰你的问题： "</span>)</span><br><span class="line"><span class="keyword">if</span> ques != <span class="string">"quit"</span>:</span><br><span class="line"><span class="keyword">if</span> ques <span class="keyword">in</span> mydict:</span><br><span class="line">print(mydict[ques])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">ans=input(<span class="string">"你教教俺吧。。。"</span>)</span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">mydict[ques]=ans</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">f=open(<span class="string">"data.pkl"</span>,<span class="string">"wb"</span>)</span><br><span class="line">pickle.dump(mydict,f)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h5 id="作业：实现计算器"><a href="#作业：实现计算器" class="headerlink" title="作业：实现计算器"></a><strong>作业：实现计算器</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">cm = input(<span class="string">"请输入你要计算的表达式:"</span>)</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> cm:</span><br><span class="line">    <span class="keyword">if</span> var <span class="keyword">in</span> &#123;<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>&#125;:</span><br><span class="line">        l_num,r_num = float(cm[:index]),float(cm[index+<span class="number">1</span>:])</span><br><span class="line">        <span class="comment">#取出左边的数据,并且转换成浮点型</span></span><br><span class="line">        <span class="comment">#取出右边的数据,并且转换成浮点型</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    index += <span class="number">1</span> <span class="comment">#index是操作符在输入表达式的里面</span></span><br><span class="line">cau = &#123;</span><br><span class="line">    <span class="string">'+'</span>: l_num + r_num,</span><br><span class="line">    <span class="string">'-'</span>: l_num - r_num,</span><br><span class="line">    <span class="string">"*"</span>: l_num * r_num,</span><br><span class="line">&#125; <span class="comment">#if条件远远不如字典判断快</span></span><br><span class="line"><span class="keyword">if</span> r_num != <span class="number">0</span>:</span><br><span class="line">    cau[<span class="string">'/'</span>] = l_num / r_num</span><br><span class="line">print(<span class="string">'result:'</span>,cau.get(cm[index]))</span><br><span class="line"><span class="comment">#get方法在key值不存在的时候，不会爆错</span></span><br><span class="line"><span class="comment">#cm[index]: 获取到了操作符</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line">expr = input(<span class="string">'请输入一个运算表达式:'</span>)</span><br><span class="line"><span class="comment">#'    2  |*| 0'</span></span><br><span class="line">index = <span class="number">0</span> <span class="comment">#用来查找表达式中 + - * /符号的位置</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> expr: <span class="comment">#定位表达式中操作符的位置</span></span><br><span class="line">    <span class="keyword">if</span> var <span class="keyword">in</span> &#123;<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>&#125;:</span><br><span class="line">        print(<span class="string">"[+] 操作符位置:%d"</span> % index)</span><br><span class="line">        print(<span class="string">"[+] 操作符:%s"</span> % var)</span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># 找到了操作符，那么就跳出循环即可</span></span><br><span class="line">        <span class="comment">#%d 可以整形转义输出</span></span><br><span class="line">        <span class="comment">#%s 转移输出字符串</span></span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line"><span class="comment">#找到左右两个数字</span></span><br><span class="line"><span class="comment">#通过切片访问到字符串中的所有两个数字</span></span><br><span class="line">l_num = float(expr[:index]) <span class="comment">#左边的操作数</span></span><br><span class="line">r_num = float(expr[index+<span class="number">1</span>:]) <span class="comment">#右边的操作数 不能是0</span></span><br><span class="line"><span class="comment">#除法 被除数不能为0</span></span><br><span class="line">oper = expr[index] <span class="comment">#找到了操作符</span></span><br><span class="line"></span><br><span class="line">res = &#123;</span><br><span class="line">    <span class="string">'+'</span>: l_num + r_num,</span><br><span class="line">    <span class="string">'-'</span>: l_num - r_num,</span><br><span class="line">    <span class="string">'*'</span>: l_num * r_num,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r_num != <span class="number">0</span>: <span class="comment">#当第二个操作不为0的时候 才支持除法</span></span><br><span class="line">    res[<span class="string">'/'</span>] = l_num / r_num</span><br><span class="line"></span><br><span class="line">print(<span class="string">'你的结果是: %s'</span> % res.get(oper))</span><br><span class="line"><span class="comment">#get获取字典中不存在key值不会报错，只会返回None</span></span><br><span class="line">    <span class="comment"># %d 只能支持数字(整数)</span></span><br><span class="line">    <span class="comment"># %s 随意一些，支持所有的类型</span></span><br></pre></td></tr></table></figure><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a><strong>字典</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">创建方法：</span><br><span class="line"><span class="number">1</span>、语法大括号包裹：创建字典 = &#123;key:value&#125;</span><br><span class="line"><span class="number">2</span>、工厂方法创建字典：res = dict(([<span class="number">1</span>, <span class="number">2</span>],[<span class="string">'a'</span>, <span class="string">'b'</span>]))</span><br><span class="line">    <span class="number">3</span>、内建方法：dict.fromkeys( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="string">'a'</span> )</span><br><span class="line">   批量创建key值，无法单独为每个key分配具体的value</span><br><span class="line">字典的key是绝对唯一的，不可变的数据才可以做key值</span><br><span class="line">字典的value可以重复，可以是任意的数据类型</span><br><span class="line">字典来自于hash表构成的，hash的检索特别块，hash之后，key值对应的hash值会指向一个具体value地址，也就是为啥我们通过key值访问value很快，就是因为hash表</span><br><span class="line">hash算法处理后的数据，不管之前有多么接近，之后绝对是唯一的，所以需要，key值是一个不能变的</span><br><span class="line">字典也算的上是个无序的数据类型，在python3<span class="number">.6</span> 字典有序了</span><br><span class="line"></span><br><span class="line">字典： &#123; key: value  &#125;</span><br><span class="line">key：</span><br><span class="line"><span class="number">1</span>：hash运算key创建出hash表</span><br><span class="line"><span class="number">2</span>：hash表的查询速度很快</span><br><span class="line"><span class="number">3</span>：字典，他是不可以做索引，切片</span><br><span class="line"><span class="number">4</span>：key值必须是一个不可变数据对象：数字，字符串，元组，</span><br><span class="line"><span class="number">5</span>：key值必须是一个唯一的</span><br><span class="line">value：</span><br><span class="line"><span class="number">1</span>：可以存储不同的数据类型</span><br><span class="line"><span class="number">2</span>：多个key同时对应一个value</span><br><span class="line">&#123;<span class="number">1</span>:<span class="string">'a'</span> , <span class="number">2</span>: <span class="string">'a'</span>&#125;</span><br><span class="line">访问字典：</span><br><span class="line">mydict[key]</span><br><span class="line">mydict.keys()获取字典中所有的key值</span><br><span class="line">mydict.values()获取字典中所有的value值</span><br><span class="line">更新字典：</span><br><span class="line">mydict[key]=value</span><br><span class="line">如果key存在的话，就更新value，如果key不存在的话就创建一个先的key:value的值</span><br><span class="line">删除字典：</span><br><span class="line"><span class="keyword">del</span> mydict[key]直接删除key值</span><br><span class="line">    mydict.pop()  在删除key值得过程中，还会把value值返回</span><br><span class="line">    mydict.clear() 清空字典</span><br><span class="line">    <span class="keyword">del</span> mydict  直接删除字典</span><br><span class="line">mydict.get(key)  此命令在key存在的时候返回对应的value，若key不存在，返回空，不报错</span><br></pre></td></tr></table></figure><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">可变集合：myset=set()</span><br><span class="line">不可变集合：myset=frozenset()</span><br><span class="line"></span><br><span class="line">做爬虫的时候使用集合保存爬取的URL，可以处理重复的连接</span><br><span class="line">集合中的数据没有前后关系，而且是无序的，不能使用<span class="keyword">for</span>循环来遍历</span><br><span class="line">集合的特性：</span><br><span class="line"><span class="number">1</span>、集合是无序的，无法使用<span class="keyword">for</span>来遍历,不可以索引和切片</span><br><span class="line">    <span class="number">2</span>、集合的数据是去重的</span><br><span class="line">    <span class="number">3</span>、集合不能存储可变数据对象，因为可变数据对象无法进行hash运算</span><br><span class="line">    <span class="number">4</span>、集合中的所有数据元素都要经过hash运算，会维护hash表</span><br><span class="line">    <span class="number">5</span>、一个空集合只能通过set()的方式来创建</span><br><span class="line">    myset=&#123;&#125;这个创建的是一个字典</span><br><span class="line">    <span class="number">6</span>、没有value的字典就是集合</span><br><span class="line">    <span class="number">7</span>、普通集合是可变的，不可变集合是frozenset(序列)</span><br><span class="line">更新集合：</span><br><span class="line">set.add(不可变数据类型)</span><br><span class="line">    如果这个类型是不可变序列，这个序列会原样加进集合中</span><br><span class="line">    set.update(数据集str,list,tuple,dict,set)</span><br><span class="line">    数据集将拆分成单个的元素，去掉重复的，然后加入到集合中</span><br><span class="line">        数据集不允许含有可变数据对象</span><br><span class="line">        数据集：str,list,tuple,dict(key值作为集合中的数据)，set,frozenset</span><br><span class="line">可变集合---删除集合</span><br><span class="line">set.remove(集合中的数据元素) 删除后没有任何返回</span><br><span class="line">    set.pop() 不接收任何参数，随机删除，并返回被删除的元素</span><br><span class="line">    <span class="keyword">del</span> myset  直接删除这个变量</span><br><span class="line">可变集合和不可变集合都只能通过<span class="keyword">for</span>循环迭代访问</span><br><span class="line">可用<span class="keyword">in</span> 和 <span class="keyword">not</span> <span class="keyword">in</span> 判断元素是否在集合中</span><br><span class="line">可以用<span class="keyword">in</span>和<span class="keyword">not</span> <span class="keyword">in</span>去获取一个数据集中是否有某个元素</span><br><span class="line">字符串，元组，列表，字典，集合</span><br><span class="line">    <span class="keyword">in</span>是去判断数据库里读取的数据集</span><br><span class="line">更新集合：</span><br><span class="line">myset.add(seq) 直接修改集合本身，会保留和维护数据的形态到集合中</span><br><span class="line">    myset.update(seq) 直接修改集合本身，会将数据拆分去重后加入到集合中</span><br><span class="line">    并且update不接收一个不可拆分的数据，比如整数</span><br><span class="line">        update也可以接收一个列表</span><br><span class="line">删除集合:</span><br><span class="line">    myset.pop()  随机删除并返回删除的值</span><br><span class="line">    myset.remove(obj) 在集合中删除obj,删除一个不存在的值会报错</span><br><span class="line">    myset.discard(obj) 在集合中删除obj,删除一个不存在的值不会报错</span><br><span class="line">    <span class="keyword">del</span>  myset  直接把集合删除了，集合的引用计数减去<span class="number">1</span></span><br><span class="line">集合的运算</span><br><span class="line">a的元素b都有</span><br><span class="line">        子集：a.issubset(b)  a是b的子集</span><br><span class="line">        超集：b.isuperset(b)  b是a的超集</span><br><span class="line">        交集(&amp;)：a和b中共同含有的数据，去重后返回的新的集合就a和b的交集</span><br><span class="line">        并集(|)：a和b两个集合所有元素放到一起，去掉重复返回的新的集合就是a和b的交集</span><br><span class="line">        差集(-)：a-b 从a中去掉a和b共有的，也就是b中有的a都不要了，返回一个新德集合</span><br><span class="line">        对称差分(^)：找出两个集合中各自单独有的数据，也就是a和b的交集减去并集的数据</span><br></pre></td></tr></table></figure><h5 id="系统内置函数"><a href="#系统内置函数" class="headerlink" title="系统内置函数"></a><strong>系统内置函数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">enumerate(iter):接受一个可迭代的对象作为参数，返回一个enumerate对象，</span><br><span class="line">        也是一个迭代器，该对象生成由iter每个元素的index值和item值</span><br><span class="line">len(seq):返回seq长度</span><br><span class="line">max(iter,key=<span class="keyword">None</span>) <span class="keyword">or</span> max(arg0,arg1...key=<span class="keyword">None</span>):</span><br><span class="line">    返回iter或(arg0,arg1)中的最大值，如果指定了key，</span><br><span class="line">    这个key必须是可以传给sort()方法的，用于比较回调的函数</span><br><span class="line">min(iter,key=<span class="keyword">None</span>) <span class="keyword">or</span> min(arg0,arg1...key=<span class="keyword">None</span>):</span><br><span class="line">    返回iter或(arg0,arg1)中的最大值，如果指定了key，</span><br><span class="line">    这个key必须是可以传给sort()方法的，用于比较回调的函数</span><br><span class="line">    &gt;&gt;&gt; max(<span class="string">'a123'</span>,<span class="string">'b123'</span>,key=<span class="keyword">lambda</span> x:x[<span class="number">2</span>])</span><br><span class="line">    &gt;&gt;&gt; <span class="string">'a123'</span></span><br><span class="line">max函数之后的<span class="keyword">lambda</span>表达式，在指定出元素之后，</span><br><span class="line">    会按照你选择的元素来排序，x[<span class="number">2</span>]就是x的第二个元素进行排序</span><br><span class="line">reversed(seq):接受一个序列作为参数，返回一个以逆序访问的迭代器</span><br><span class="line">sorted(iter,cmp=<span class="keyword">None</span>,key=<span class="keyword">None</span>):</span><br><span class="line">    接受一个可迭代的对象作为参数，返回一个有序的列表，可选参数是一个排序方式</span><br><span class="line">sum(seq,init=<span class="number">0</span>):返回seq和可选参数init的总和</span><br><span class="line">zip(it0,it1,...itN):返回一个列表，用法如下：</span><br><span class="line">    可以将对应的序列 对应的索引位置 拼接成一个二元组或者多元组</span><br><span class="line">如果序列长度不一，以短的为主。</span><br><span class="line">    zip函数返回的是一个抽象的数据，保证内存安全，实现了迭代器(可以延迟生产数据)</span><br><span class="line">    </span><br><span class="line">    &gt;&gt;&gt; a=zip(<span class="string">'123'</span>,<span class="string">'abcdef'</span>,<span class="string">'ABC'</span>)</span><br><span class="line">    &lt;zip object at <span class="number">0x000001E28964C848</span>&gt;</span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        ...    print(i)</span><br><span class="line">        ...</span><br><span class="line">        (<span class="string">'1'</span>, <span class="string">'a'</span>,<span class="string">'A'</span>)</span><br><span class="line">        (<span class="string">'2'</span>, <span class="string">'b'</span>,<span class="string">'B'</span>)</span><br><span class="line">        (<span class="string">'3'</span>, <span class="string">'c'</span>,<span class="string">'C'</span>)</span><br><span class="line">map(func,seq):map函数第一个参数可以是一个函数对象，第二个是一个序列</span><br><span class="line">    map函数可以传入的函数依次作用在序列的每一个元素上。</span><br><span class="line">    实例：</span><br><span class="line">    &gt;&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">ys</span><span class="params">(x)</span>:</span></span><br><span class="line">        ...     <span class="keyword">return</span> x*x+<span class="number">1</span></span><br><span class="line">    &gt;&gt;&gt; mylist=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    &gt;&gt;&gt; yes=map(ys,mylist)</span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> yes:</span><br><span class="line">        ...     print(i)</span><br><span class="line">        <span class="number">2</span></span><br><span class="line">        <span class="number">5</span></span><br><span class="line">        <span class="number">10</span></span><br><span class="line">        <span class="number">17</span></span><br><span class="line">        <span class="number">26</span></span><br><span class="line">reduce函数(导入reduce函数 <span class="keyword">from</span> functools <span class="keyword">import</span> reduce)</span><br><span class="line">    用法：reduce把一个函数作用在一个序列[x1,x2,x3...]上，这个函数必须接收两个参数</span><br><span class="line">    reduce把结果继续和序列的下一个元素左累积计算，效果如下：</span><br><span class="line">    &gt;&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        ...     <span class="keyword">return</span> x+y</span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">    &gt;&gt;&gt; mylist=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    &gt;&gt;&gt; reduce(add,mylist)</span><br><span class="line">    <span class="number">15</span></span><br><span class="line">    &gt;&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">cf</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        ...     <span class="keyword">return</span> x*y+<span class="number">1</span></span><br><span class="line">    &gt;&gt;&gt; reduce(cf,mylist)</span><br><span class="line">    <span class="number">120</span></span><br><span class="line">eval(字符串对象)  -&gt; 一般不要用</span><br><span class="line">    会把无意义的字符串变成了合法的表达式</span><br><span class="line">    表达式 一个有效的可以得出结果的式子</span><br><span class="line">repr(表达式)  </span><br><span class="line">将一个表达式变成无意义的字符串</span><br></pre></td></tr></table></figure><h5 id="str内置函数"><a href="#str内置函数" class="headerlink" title="str内置函数"></a><strong>str内置函数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">字符串内建函数--大小写转换函数</span><br><span class="line">    string.lower():字母大写转换为小写</span><br><span class="line">    string.upper():字母小写转换为大写</span><br><span class="line">    string.swapcase():字母大写转换为小写,小写转大写</span><br><span class="line">    string.title():将语句中所有单词的首字母大写</span><br><span class="line">    string.capitalize():将语句中首字母大写，其他小写</span><br><span class="line">字符串内建函数--搜索函数</span><br><span class="line">    string.find(str,[start=<span class="number">0</span>,stop=len(string)])</span><br><span class="line">        计算string中出现str的第一个字母的索引，如果没有出现，则返回<span class="number">-1</span></span><br><span class="line">    string.index(str,[start=<span class="number">0</span>,stop=len(string)])</span><br><span class="line">        计算string中出现str的第一个字母的索引，如果没有出现，出现异常</span><br><span class="line">    string.count(str,[start=<span class="number">0</span>,stop=len(string)]):</span><br><span class="line">        计算str在string中出现的次数</span><br><span class="line">    string.endswith(str,[start=<span class="number">0</span>,stop=len(string)])</span><br><span class="line">        检查sring是否是以str结尾，如果是返回<span class="keyword">True</span>，反之返回<span class="keyword">False</span></span><br><span class="line">字符串内建函数--替换函数</span><br><span class="line">    string.replace(str1,str2,[num=string.count(str1)])</span><br><span class="line">        将str1替换为str2，num为替换次数，默认次数为str1出现的次数</span><br><span class="line">    string.strip(chr):在string的开头和结尾删除chr，当chr为空时，默认删除空白符(\r,\n,\t,<span class="string">" "</span>)</span><br><span class="line">    string.rstrip():删除string字符串末尾的空格，或者换行符号</span><br><span class="line">    string.lstrip():删除string字符串开头的空格，或者换行符号</span><br><span class="line">字符串内建函数--判断函数</span><br><span class="line">    string.isdigit():如果string只包含数字，则返回<span class="keyword">True</span>，否则返回<span class="keyword">False</span></span><br><span class="line">    string.islower():如果字符串中的字母都是小写则返回<span class="keyword">True</span>，否则返回<span class="keyword">False</span></span><br><span class="line">    string.isupper():如果字符串中的字母都是大写则返回<span class="keyword">True</span>，否则返回<span class="keyword">False</span></span><br><span class="line">    string.isspace():字符串中只包含空白字符，返回<span class="keyword">True</span>，否则返回<span class="keyword">False</span></span><br></pre></td></tr></table></figure><h5 id="列表内置函数"><a href="#列表内置函数" class="headerlink" title="列表内置函数"></a><strong>列表内置函数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list.append(obj):在尾部追加obj</span><br><span class="line">list.count():返回一个对象在列表中出现的次数</span><br><span class="line">list.extend(seq):把序列seq中的内容添加到列表中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.extend(<span class="string">'abc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">list.insert(index,obj):在索引index的位置插入obj，原位置数据向后移动</span><br><span class="line">list.pop(index):删除并返回index位置的数据对象，默认是最后一个对象</span><br><span class="line">list.reverse():反转列表</span><br></pre></td></tr></table></figure><h5 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a><strong>元组内置函数</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple.index(obj,beg=<span class="number">0</span>,end=len(string)):检查obj是否包含在tuple中</span><br><span class="line">tuple.count(obj):返回obj出现的次数</span><br></pre></td></tr></table></figure><h5 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a><strong>推导式</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">推导式：</span><br><span class="line">一种方便的结合<span class="keyword">for</span>循环进行数据处理的方式</span><br><span class="line">for循环 -&gt; 序列中一个个的取值</span><br><span class="line">列表推导式</span><br><span class="line">[ 表达式 <span class="keyword">for</span> var <span class="keyword">in</span> iterable <span class="keyword">if</span> 过滤条件 ]</span><br><span class="line"><span class="number">1</span>：<span class="keyword">for</span>循环从iterable取值</span><br><span class="line"><span class="number">2</span>：取到的值首先要经过<span class="keyword">if</span>条件判断</span><br><span class="line"><span class="number">3</span>：判断条件成立的数据，放到表达式运算，运算后的结果，作为新列表中的值</span><br><span class="line">集合推导式</span><br><span class="line">&#123; key <span class="keyword">for</span> var <span class="keyword">in</span> iterable <span class="keyword">if</span> 过滤条件 &#125;</span><br><span class="line"></span><br><span class="line">字典推导式</span><br><span class="line">&#123; key:value <span class="keyword">for</span> var <span class="keyword">in</span> iterable <span class="keyword">if</span> 过滤条件 &#125;</span><br><span class="line"></span><br><span class="line">元组推导式 == 迭代器</span><br><span class="line">( key for var in iterable if 过滤条件 )  -&gt; iter</span><br><span class="line">    </span><br><span class="line">列表表达式： [ 表达式 <span class="keyword">for</span> value <span class="keyword">in</span> 序列 <span class="keyword">if</span> 过滤条件 ]</span><br><span class="line">元组表达式： ( 表达式 <span class="keyword">for</span> value <span class="keyword">in</span> 序列 <span class="keyword">if</span> 过滤条件 )</span><br><span class="line">    所有从这个<span class="keyword">for</span>循环出来的每一个数据首先会经过<span class="keyword">if</span>条件过滤，然后执行前面的表达式，</span><br><span class="line">    最后重新返回成一个新的列表，过滤条件可有可无</span><br><span class="line">    &gt;&gt;&gt; mylist=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">    &gt;&gt;&gt; [var*var <span class="keyword">for</span> var <span class="keyword">in</span> mylist <span class="keyword">if</span> var!=<span class="number">3</span>]</span><br><span class="line">    [<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>]</span><br><span class="line">    &gt;&gt;&gt; (var*var <span class="keyword">for</span> var <span class="keyword">in</span> mylist <span class="keyword">if</span> var!=<span class="number">3</span>)</span><br><span class="line">    &lt;generator object &lt;genexpr&gt; at <span class="number">0x00000238D160B3B8</span>&gt;</span><br><span class="line">    &gt;&gt;&gt; my_tuple=(var*var <span class="keyword">for</span> var <span class="keyword">in</span> mylist <span class="keyword">if</span> var!=<span class="number">3</span>)</span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> my_tuple:</span><br><span class="line">    ...     print(i)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">16</span></span><br><span class="line">    &gt;&gt;&gt; my_tuple=(var*var <span class="keyword">for</span> var <span class="keyword">in</span> mylist <span class="keyword">if</span> var!=<span class="number">3</span>)</span><br><span class="line">    &gt;&gt;&gt; my_tuple.__next__()</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    &gt;&gt;&gt; my_tuple.__next__()</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    &gt;&gt;&gt; my_tuple.__next__()</span><br><span class="line">    <span class="number">16</span></span><br><span class="line">    &gt;&gt;&gt; my_tuple.__next__()</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">      File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    StopIteration</span><br><span class="line"></span><br><span class="line">    通过列表推导式就可以把我们含有大小写的列表改成全部大写的列表</span><br><span class="line">    我们生成出所有经过表达式的一个结果序列，并且是列表类型的</span><br><span class="line">元组表达式就是生成器，只有在使用到的时候才生成，比较节约内存</span><br><span class="line"></span><br><span class="line">字典推导式：</span><br><span class="line">    和列表类似，只不过需要两个值存在来维护字典的键值对形式</span><br><span class="line">    &#123;key:value <span class="keyword">for</span> key <span class="keyword">in</span> 序列 <span class="keyword">if</span> 过滤条件&#125;</span><br><span class="line"></span><br><span class="line">    enumerate(obj):这个函数会返回两个值，一个是序列的下标，一个是下标对应的值</span><br><span class="line">    &gt;&gt;&gt; mylist=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line">    &gt;&gt;&gt; mydict=&#123;key:value <span class="keyword">for</span> key,value <span class="keyword">in</span> enumerate(mylist)&#125;</span><br><span class="line">    &gt;&gt;&gt; mydict</span><br><span class="line">    &#123;<span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span>, <span class="number">3</span>: <span class="string">'d'</span>&#125;</span><br><span class="line">    </span><br><span class="line">mydict = &#123;<span class="string">'初心'</span>:&#123;<span class="string">'money'</span>:<span class="number">100000</span>,<span class="string">'sex'</span>:<span class="string">'male'</span>&#125;,<span class="string">'Infor'</span>:&#123;<span class="string">'Money'</span>:<span class="number">110000</span>,<span class="string">'sex'</span>:<span class="string">'male'</span>&#125;&#125;</span><br><span class="line"><span class="comment">#list(mydict[var].keys())[0]</span></span><br><span class="line">newdict = &#123;var:&#123;list(mydict[var].keys())[<span class="number">0</span>]:mydict[var][list(mydict[var].keys())[<span class="number">0</span>]]+<span class="number">1000</span>&#125; <span class="keyword">for</span> var <span class="keyword">in</span> mydict&#125;</span><br><span class="line">print(newdict)</span><br><span class="line"></span><br><span class="line">集合推到式：</span><br><span class="line">    集合推导式跟列表推导式非常相似，唯一的区别在于用&#123;&#125;代替[]</span><br><span class="line">    &#123;表达式 <span class="keyword">for</span> value <span class="keyword">in</span> 序列 <span class="keyword">if</span> 过滤条件&#125;</span><br><span class="line">    &gt;&gt;&gt; mylist</span><br><span class="line">    [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line">    &gt;&gt;&gt; myset=&#123;var*<span class="number">2</span> <span class="keyword">for</span> var <span class="keyword">in</span> mylist&#125;</span><br><span class="line">    &gt;&gt;&gt; myset</span><br><span class="line">    &#123;<span class="string">'aa'</span>, <span class="string">'bb'</span>, <span class="string">'cc'</span>, <span class="string">'dd'</span>&#125;</span><br><span class="line"></span><br><span class="line">推到式：表达式  <span class="keyword">for</span> var <span class="keyword">in</span> 序列 <span class="keyword">if</span> 过滤</span><br></pre></td></tr></table></figure><h5 id="作业：2万以下的-加工资"><a href="#作业：2万以下的-加工资" class="headerlink" title="作业：2万以下的 加工资"></a><strong>作业：2万以下的 加工资</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">salary_list = [<span class="number">13000</span>,<span class="number">12700</span>,<span class="number">15000</span>,<span class="number">14000</span>,<span class="number">25000</span>,<span class="number">16000</span>,<span class="number">18000</span>,<span class="number">22000</span>,<span class="number">32000</span>]</span><br><span class="line"><span class="comment">#2万以下的 加工资</span></span><br><span class="line"><span class="comment">#加1000</span></span><br><span class="line">new_list = []</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> salary_list:</span><br><span class="line">    <span class="keyword">if</span> var &lt;= <span class="number">20000</span>:</span><br><span class="line">        var+=<span class="number">1000</span></span><br><span class="line">    new_list.append(var)</span><br><span class="line">print(new_list)</span><br><span class="line"></span><br><span class="line">res = [ var + <span class="number">1000</span> <span class="keyword">for</span> var <span class="keyword">in</span> salary_list <span class="keyword">if</span> var &lt;= <span class="number">20000</span> ]</span><br><span class="line">salary_list[:len(res)] = res</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#1: for循环取值</span></span><br><span class="line"><span class="comment">#2: 经过if条件判断</span></span><br><span class="line"><span class="comment">#3: 放到最前面，作为新列表的值</span></span><br><span class="line">    <span class="comment">#if...else  if如果不满足，那么执行else</span></span><br><span class="line">    <span class="comment">#for...else  可以循环正常结束的时候，for...else执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把新的列表替换原来的列表元素</span></span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line"></span><br><span class="line">mylist = [<span class="number">13000</span>,<span class="number">15000</span>,<span class="number">15000</span>,<span class="number">17000</span>,<span class="number">20000</span>,<span class="number">14500</span>,<span class="number">23400</span>,<span class="number">27000</span>]</span><br><span class="line">        <span class="comment">#15000 + 2000 - &gt; 17000</span></span><br><span class="line">        <span class="comment">#这个17000和后面的17000重复了，所以会替换多次，一个15000到最后多添加了好几次呢</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(old,new)</span>:</span></span><br><span class="line">    <span class="comment">#不要因为数据相同而重复替换 要避免这个</span></span><br><span class="line">    <span class="comment">#直接修改mylist 这个变量本身</span></span><br><span class="line">    <span class="keyword">global</span> mylist <span class="comment">#使用全局变量mylist及index_list</span></span><br><span class="line">    <span class="keyword">global</span> index_list</span><br><span class="line">    <span class="keyword">for</span> _index,var <span class="keyword">in</span> enumerate(mylist):</span><br><span class="line">        <span class="keyword">if</span> var == old <span class="keyword">and</span> _index <span class="keyword">not</span> <span class="keyword">in</span> index_list: <span class="comment">#如果这个索引还没出现过，那么就替换</span></span><br><span class="line">            print(<span class="string">'当前替换的是:'</span>,mylist[_index])</span><br><span class="line">            mylist[_index] = new</span><br><span class="line">            index_list.append(_index) <span class="comment">#替换完成，记录一下</span></span><br><span class="line">    print(<span class="string">"--------------"</span>) <span class="comment">#函数之行一次之后打印一次横线</span></span><br><span class="line">        <span class="comment">#函数没有返回值，那么就返回None</span></span><br><span class="line"></span><br><span class="line">[replace(var,var+<span class="number">2000</span>) <span class="keyword">for</span> var <span class="keyword">in</span> mylist <span class="keyword">if</span> var &lt; <span class="number">20000</span>]</span><br><span class="line">    <span class="comment">#var : old</span></span><br><span class="line">    <span class="comment">#var + 2000 : new</span></span><br><span class="line">print(<span class="string">'new:'</span>,mylist)</span><br></pre></td></tr></table></figure><h5 id="作业：做一个自己的帮助文档"><a href="#作业：做一个自己的帮助文档" class="headerlink" title="作业：做一个自己的帮助文档"></a><strong>作业：做一个自己的帮助文档</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        这就是我的帮助文档</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#__doc__  可以调取帮助文档</span></span><br><span class="line">help(func)</span><br><span class="line">print(func.__doc__)</span><br><span class="line">res = dir(str)</span><br><span class="line">help_dict = &#123;&#125;</span><br><span class="line"><span class="comment">#帮助文档的列表</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> res: <span class="comment">#提取每个函数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'__'</span> <span class="keyword">in</span> func: <span class="comment">#过滤下划线函数</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    help_dict[func] = func.__doc__ <span class="comment">#把帮助文档追加到列表</span></span><br><span class="line">        <span class="comment">#有则修改，没有则增加</span></span><br><span class="line">    <span class="comment">#key: func 函数名字符串</span></span><br><span class="line">    <span class="comment">#value: func.__doc__ 帮助文档</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> help_dict:</span><br><span class="line">    print(key) <span class="comment">#首先打印函数名</span></span><br><span class="line">    print(help_dict[key]) <span class="comment">#在打印帮助文档</span></span><br><span class="line">    print(<span class="string">'-------------------------'</span>)</span><br><span class="line"><span class="comment">#Web GUI</span></span><br><span class="line">***************************************************************************************</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">print(<span class="string">'退出请输入: q/Q\n'</span>)</span><br><span class="line">user_req = input(<span class="string">'请输入查询序列类型(str/list/tuple/dict/set):\n'</span>)</span><br><span class="line">print()</span><br><span class="line"><span class="keyword">if</span> user_req == <span class="string">'q'</span> <span class="keyword">or</span> user_req == <span class="string">'Q'</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">res = dir(eval(user_req))</span><br><span class="line">print(res)</span><br><span class="line">print()</span><br><span class="line">search_req = input(<span class="string">'请输入查询函数:\n'</span>)</span><br><span class="line">print()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">help(eval(user_req + <span class="string">'.'</span> + search_req))</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> first_reason:</span><br><span class="line">print(<span class="string">'请重新输入!!!The reason: '</span>,str(first_reason))</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> second_reason:</span><br><span class="line">print(<span class="string">"错啦,重新输入!!!The reason: "</span>,str(second_reason))</span><br></pre></td></tr></table></figure><h5 id="作业：每个爷们加1000工资"><a href="#作业：每个爷们加1000工资" class="headerlink" title="作业：每个爷们加1000工资"></a><strong>作业：每个爷们加1000工资</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mydict = &#123;</span><br><span class="line">    <span class="string">'KM'</span>:        &#123;<span class="string">'sex'</span>:<span class="string">'male'</span>,  <span class="string">'工作'</span>:<span class="string">'Star'</span>, <span class="string">'money'</span>:<span class="number">13000</span>,&#125;,</span><br><span class="line">    <span class="string">'Charles'</span>:   &#123;<span class="string">'money'</span>:<span class="number">13000</span>, <span class="string">'性别'</span>:<span class="string">'male'</span>,  <span class="string">'like'</span>:<span class="string">'DJ'</span>&#125;,</span><br><span class="line">    <span class="string">'Mark Smith'</span>:&#123;<span class="string">'salary'</span>:<span class="number">13000</span>, <span class="string">'sex'</span>:<span class="string">'male'</span>,  <span class="string">'job'</span>:<span class="string">'Rap'</span>&#125;,</span><br><span class="line">    <span class="string">'QQ'</span>:        &#123;<span class="string">'money'</span>:<span class="number">15000</span>, <span class="string">'性别'</span>:<span class="string">'female'</span>,<span class="string">'job'</span>:<span class="string">'Dancer'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#dict keys values dict[key] for key in dict</span></span><br><span class="line"><span class="comment">#推导式实现一下，每个爷们加个1000</span></span><br><span class="line"><span class="comment">#job要留下来,money要留下来</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(var)</span>:</span></span><br><span class="line">    var = list(var)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'male'</span> <span class="keyword">in</span> var:<span class="comment">#先判断是否是个男的</span></span><br><span class="line">        <span class="keyword">for</span> _index,value <span class="keyword">in</span> enumerate(var): <span class="comment">#判断是不是个数字</span></span><br><span class="line">            <span class="keyword">if</span> type(value) == int:</span><br><span class="line">                var[_index] = value + <span class="number">1000</span> <span class="comment">#数个数字 加1000</span></span><br><span class="line">    <span class="keyword">return</span> tuple(var)</span><br><span class="line"></span><br><span class="line">new_dict = &#123; key:dict( zip( list( mydict[key].keys() ), func( mydict[key].values() ) ) ) <span class="keyword">for</span> key <span class="keyword">in</span> mydict &#125;</span><br><span class="line"><span class="comment">#只有工资对应的value值是一个整数 int</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> new_dict:</span><br><span class="line">    print(key,<span class="string">':'</span>,new_dict[key])</span><br><span class="line">print(<span class="string">"=================="</span>)</span><br></pre></td></tr></table></figure><h5 id="作业：四色五入"><a href="#作业：四色五入" class="headerlink" title="作业：四色五入"></a><strong>作业：四色五入</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123.9443712837819</span></span><br><span class="line">float_index = <span class="number">2</span> <span class="comment">#我就要2位小数</span></span><br><span class="line">int_part = str(a).split(<span class="string">'.'</span>)[<span class="number">0</span>] <span class="comment">#123 整数部分 str</span></span><br><span class="line">float_part = str(a).split(<span class="string">'.'</span>)[<span class="number">-1</span>] <span class="comment">#90182039 小数部分 str</span></span><br><span class="line">print(<span class="string">"原有数据:"</span>,a)</span><br><span class="line">print(<span class="string">'整数部分:'</span>,int_part)</span><br><span class="line">print(<span class="string">'小数部分:'</span>,float_part)</span><br><span class="line"><span class="comment">#字符串判断整数 直接对比值大小</span></span><br><span class="line"><span class="comment">#字符串判断的是字母 那就是对比ascii码 a 97 A 65</span></span><br><span class="line"><span class="keyword">if</span> len(float_part) &lt;= float_index: <span class="comment">#判断小数长度与精度位数的大小</span></span><br><span class="line">    print(<span class="string">"处理完成之后的小数:"</span>,a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> int(float_part[float_index]) &gt;= <span class="number">5</span>: <span class="comment">#获取小数部分最后一位</span></span><br><span class="line">        print(<span class="string">'小数部分最后一位:'</span>,float_part[float_index])</span><br><span class="line">        print(<span class="string">'扔掉最后一位的结果:'</span>,float_part[:float_index])</span><br><span class="line">        float_part = str( int(float_part[:float_index]) + <span class="number">1</span> )</span><br><span class="line">        print(<span class="string">'最后的小数部分:'</span>,float_part)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#如果说位数精度的数字小于5，不满足上位的条件，那么直接把后面的位省去</span></span><br><span class="line">        print(<span class="string">'小数部分最后一位:'</span>,float_part[float_index])</span><br><span class="line">        print(<span class="string">'扔掉最后一位的结果:'</span>,float_part[:float_index])</span><br><span class="line">        float_part = str( int(float_part[:float_index]) )</span><br><span class="line">        print(<span class="string">'最后的小数部分:'</span>,float_part)</span><br><span class="line">    res = float(<span class="string">'.'</span>.join( [int_part,float_part] ))</span><br><span class="line">    <span class="comment">#res = float(int_part + '.' + float_part)</span></span><br><span class="line">    print(<span class="string">'整数和小数拼接:'</span>,res)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(var,f_index)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        func(var,f_index) -&gt; float</span></span><br><span class="line"><span class="string">        这个函数用来做四舍五入的精度处理</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            var是你传入的小数</span></span><br><span class="line"><span class="string">            f_index是你需要的精度</span></span><br><span class="line"><span class="string">        返回值：</span></span><br><span class="line"><span class="string">            处理后的小数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    int_part = str(var).split(<span class="string">'.'</span>)[<span class="number">0</span>] <span class="comment">#123 整数部分 str</span></span><br><span class="line">    float_part = str(var).split(<span class="string">'.'</span>)[<span class="number">-1</span>] <span class="comment">#90182039 小数部分 st</span></span><br><span class="line">    <span class="keyword">if</span> len(float_part) &lt;= f_index: <span class="comment">#判断小数长度与精度位数的大小</span></span><br><span class="line">        float_part = float_part.ljust(f_index,<span class="string">'0'</span>) <span class="comment">#需要补位的长度</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#如果需要来维护精度，本身的浮点数长度大于了精度要求</span></span><br><span class="line">        <span class="keyword">if</span> int(float_part[f_index]) &gt;= <span class="number">5</span>: <span class="comment">#获取小数部分最后一位</span></span><br><span class="line">            float_part = str( int(float_part[:f_index]) + <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#如果说位数精度的数字小于5，不满足上位的条件，那么直接把后面的位省去</span></span><br><span class="line">            float_part = str( int(float_part[:f_index]) )</span><br><span class="line">    res = float(<span class="string">'.'</span>.join( [int_part,float_part] ))</span><br><span class="line">    <span class="comment">#res = float(int_part + '.' + float_part)</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">res = func(<span class="number">1.2</span>,<span class="number">5</span>) <span class="comment">#-&gt;1.124</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h5 id="作业：人生"><a href="#作业：人生" class="headerlink" title="作业：人生"></a><strong>作业：人生</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># seq 序列: str list tuple set dict</span></span><br><span class="line"><span class="comment"># iterable 可迭代的对象: str list tuple set dict 文件 数据库句柄 数据库返回结果集 生成器迭代器</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#baby -&gt; 小孩</span></span><br><span class="line"><span class="comment">#babe、sweet、my cup of tea -&gt; 宝贝</span></span><br><span class="line">    <span class="comment">#you are my cup of tea</span></span><br><span class="line"><span class="comment">#random choice -&gt; a random element from a non-empty sequence.</span></span><br><span class="line"><span class="comment">#choice(seq) method of random.Random instance</span></span><br><span class="line">    <span class="comment">#Choose a random element from a non-empty sequence.</span></span><br><span class="line">    <span class="comment">#从一个不为空的序列中去取一个值</span></span><br><span class="line">te = &#123;  <span class="comment">#个人信息</span></span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'human'</span>,</span><br><span class="line">    <span class="string">'age'</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="string">'job'</span>:<span class="string">'tea'</span>,</span><br><span class="line">    <span class="string">'like'</span>:<span class="string">'study'</span>,</span><br><span class="line">    <span class="string">'babe'</span>:&#123;&#125;,</span><br><span class="line">        <span class="comment">#保存你的娃</span></span><br><span class="line">        <span class="comment">#娃的名字，娃的性别</span></span><br><span class="line">&#125;</span><br><span class="line">sex_list = [<span class="string">'male'</span>,<span class="string">'female'</span>] <span class="comment">#人的性别</span></span><br><span class="line">mind_list = [<span class="string">'不好'</span>,<span class="string">'还行'</span>,<span class="string">'非常好'</span>,<span class="string">' '</span>] <span class="comment">#情绪的列表，为了可以随机抽样选择</span></span><br><span class="line">things_list = [<span class="string">'normal'</span>,<span class="string">'dangours'</span>,<span class="string">'love'</span>,<span class="string">'gay'</span>,<span class="string">'moeny'</span>,<span class="string">'babe'</span>]</span><br><span class="line">active_dict = &#123; <span class="comment">#当你情绪不一样的时候，所要做的事情</span></span><br><span class="line">    <span class="string">'不好'</span>: <span class="string">'play computer'</span>, <span class="comment">#可以这样创建，但是后面的表达式 会实际的运行的</span></span><br><span class="line">    <span class="string">'还行'</span>: <span class="string">'eat'</span>,</span><br><span class="line">    <span class="string">'非常好'</span> : <span class="string">'不上课了 我要到外面的世界'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#字典不具体的来保存行为，他只是来保存我们要做的事情</span></span><br><span class="line">    <span class="comment">#这个事情一定不要在定义字典的时候来实现</span></span><br><span class="line"><span class="comment">#赋值语句是没有返回值的，直接修改的是对象本身</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">365</span> * <span class="number">80</span>):</span><br><span class="line">    mind = random.choice(mind_list) <span class="comment">#随机抽取今天的情绪</span></span><br><span class="line">    things = random.choice(things_list) <span class="comment">#随机抽取时间</span></span><br><span class="line">    active = active_dict.get(mind) <span class="comment">#执行今天这个心情我要做的事情</span></span><br><span class="line">    <span class="keyword">if</span> things == <span class="string">'babe'</span>:</span><br><span class="line">        print(<span class="string">'今天是第%d天,今天生了!'</span> % var)</span><br><span class="line">        print(<span class="string">'         *         '</span>)</span><br><span class="line">        print(<span class="string">'        ***        '</span>)</span><br><span class="line">        print(<span class="string">'       ******     '</span>)</span><br><span class="line">        print(<span class="string">'         **       '</span>)</span><br><span class="line">        print(<span class="string">'         **       '</span>)</span><br><span class="line">        babe_name = <span class="string">'babe'</span> + str(var) <span class="comment">#宝宝名字命名</span></span><br><span class="line">        babe_sex = random.choice(sex_list)</span><br><span class="line">        te[<span class="string">'babe'</span>][babe_name] = babe_sex</span><br><span class="line">    <span class="keyword">elif</span> things == <span class="string">'dangours'</span>:</span><br><span class="line">        print(<span class="string">'这是第%d天,今天GG了'</span> % var)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#其他时候都是平平淡淡</span></span><br><span class="line">        <span class="keyword">if</span> active:</span><br><span class="line">            te[<span class="string">'like'</span>] = active</span><br><span class="line">        print(<span class="string">'今天是第%d天,今天我遇到了%s: 今天的心情%s, 我要做的事情%s'</span> % (var, things, mind, te[<span class="string">'like'</span>] ))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'完美结束'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'----------人生总结----------'</span>)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> te:</span><br><span class="line">    print(<span class="string">'%s:%s'</span> % (key,te[key]))</span><br><span class="line">    <span class="keyword">if</span> key == <span class="string">'babe'</span>:</span><br><span class="line">        print(<span class="string">"你还有孩子，在下面-------"</span>)</span><br><span class="line">        <span class="keyword">for</span> babe_name <span class="keyword">in</span> te[key]: <span class="comment">#拿到我的孩子列表</span></span><br><span class="line">            print(<span class="string">'%s:%s'</span> % (babe_name,te[key][babe_name]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#'rich':富有</span></span><br><span class="line"><span class="comment">#'handsome':帅气</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;数据类型：数字，字符串，列表，元组，集合，字典&lt;/strong&gt;&lt;/p&gt;&lt;h5 id=&quot;数字&quot;&gt;&lt;a href=&quot;#数字&quot; clas
      
    
    </summary>
    
      <category term="python" scheme="http://www.python100.com/categories/python/"/>
    
    
      <category term="python基础数据类型" scheme="http://www.python100.com/tags/python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>kvm安装</title>
    <link href="http://www.python100.com/2018/07/24/%E5%AE%89%E8%A3%85kvm/"/>
    <id>http://www.python100.com/2018/07/24/安装kvm/</id>
    <published>2018-07-24T10:09:00.000Z</published>
    <updated>2018-07-31T15:52:41.951Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><p>VMware虚机在启动之前开启CPU虚拟化<br><img src="/images/kvm/虚拟化" alt="1"></p><p>1、安装桌面GUI</p><pre><code>yum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot; </code></pre><p>2、安装kvm</p><pre><code>yum -y install libcanberra-gtk2 qemu-kvm.x86_64 qemu-kvm-tools.x86_64  libvirt.x86_64 libvirt-cim.x86_64 libvirt-client.x86_64 libvirt-java.noarch  libvirt-python.x86_64 libiscsi-1.7.0-5.el6.x86_64  dbus-devel  virt-clone tunctl virt-manager libvirt libvirt-python python-virtinst</code></pre><p>查看kvm模块是否已经安装成功<br><img src="/images/kvm/lsmod" alt="2"></p><p>3、安装桥接网络，并设置/</p><p>yum -y install bridge-utils</p><p><img src="/images/kvm/br0" alt="3"></p><p><img src="/images/kvm/ifconfig" alt="4"></p><p>设置完成后重启网络，并查看网络</p><pre><code>[root@localhost network-scripts]# brctl showbridge name    bridge id        STP enabled    interfacesbr0        8000.000c29c12e49    yes        ens37virbr0        8000.525400c9ff4e    yes        virbr0-nic</code></pre><p>4、重启libvirt,设置开机自启动</p><pre><code>systemctl start libvirtdsystemctl enable libvirtd</code></pre><p>5、使用virt-manager图形化来管理kvm虚机<br><img src="/images/kvm/1-1" alt="1531910233741"><br><img src="/images/kvm/1-2" alt="1531910233741"><br><img src="/images/kvm/1-3" alt="1531910233741"><br><img src="/images/kvm/1-4" alt="1531910233741"><br><img src="/images/kvm/1-5" alt="1531910233741"><br><img src="/images/kvm/1-6" alt="1531910233741"><br><img src="/images/kvm/1-7" alt="1531910233741"><br><img src="/images/kvm/1-8" alt="1531910233741"><br><img src="/images/kvm/1-9" alt="1531910233741"><br><img src="/images/kvm/1-10" alt="1531910233741"></p><p>之后就是正常安装系统的步骤</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;p&gt;VMware虚机在启动之前开启CPU虚拟化&lt;br&gt;&lt;img src=&quot;/images/kvm/虚拟化&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;p&gt;1、安装桌面GUI&lt;/
      
    
    </summary>
    
      <category term="kvm" scheme="http://www.python100.com/categories/kvm/"/>
    
    
  </entry>
  
  <entry>
    <title>mongo常用操作</title>
    <link href="http://www.python100.com/2018/07/24/mongo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.python100.com/2018/07/24/mongo常用命令/</id>
    <published>2018-07-24T10:06:00.000Z</published>
    <updated>2018-07-24T10:18:23.348Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><h1 id="mongo常用操作"><a href="#mongo常用操作" class="headerlink" title="mongo常用操作"></a>mongo常用操作</h1><p>参考文档：<a href="https://www.jb51.net/article/48217.htm" target="_blank" rel="noopener">https://www.jb51.net/article/48217.htm</a></p><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><pre><code>helpdb.help();db.yourColl.help();db.youColl.find().help();rs.help();</code></pre><h2 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h2><pre><code># 查看数据库    show dbs# 切换数据库    use mydatabase# 删除当前数据库    db.dropDatabase()  #进入需要删除的数据库下执行此命令#克隆数据库    db.cloneDatabase(“127.0.0.1”); 将指定机器上的数据库的数据克隆到当前数据库    db.copyDatabase(&quot;mydb&quot;, &quot;temp&quot;, &quot;127.0.0.1&quot;);将本机的mydb的数据复制到temp数据库中    db.repairDatabase(); 修复当前数据库#获取当前数据库的状态    db.getName();    db;     db和getName方法是一样的效果，都可以查询当前使用的数据库    db.stats(); 显示当前db状态    db.version();  当前db版本    db.getMongo();  查看当前db的链接机器地址</code></pre><h2 id="集合操作-Collection聚集集合"><a href="#集合操作-Collection聚集集合" class="headerlink" title="集合操作 Collection聚集集合"></a>集合操作 Collection聚集集合</h2><pre><code># 查看集合    show collections# 删除集合    db.users.drop()#创建一个聚集集合（table）    db.createCollection(“collName”, {size: 20, capped: 5, max: 100});//创建成功会显示{“ok”:1}    //判断集合是否为定容量db.collName.isCapped();# 得到指定名称的聚集集合（table）    db.getCollection(&quot;account&quot;);# 得到当前db的所有聚集集合    db.getCollectionNames();#显示当前db所有聚集索引的状态    db.printCollectionStats();</code></pre><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><pre><code>插入文档    db.users.insert({       name:&apos;harttle&apos;,       url:&apos;http://harttle.com&apos;    })查询文档    # 查询所有        db.users.find()    # 条件查询        db.users.find({           name:&apos;harttle&apos;        })    # 有缩进的输出 db.users.find().pretty()更新文档    db.users.update({       name:&apos;harttle&apos;    }, {       url:&apos;http://harttle.com&apos;        })删除文档    # 删除所有        db.users.remove({})    # 条件删除        db.users.remove({           url:&apos;http://harttle.com&apos;        })</code></pre><p>##用户操作##</p><pre><code># 添加一个用户    db.addUser(&quot;name&quot;);    db.addUser(&quot;userName&quot;, &quot;pwd123&quot;, true); 添加用户、设置密码、是否只读# 数据库认证、安全模式    db.auth(&quot;userName&quot;, &quot;123123&quot;);# 显示当前所有用户    show users;# 删除用户     db.removeUser(&quot;userName&quot;);</code></pre><p>##查询操作##</p><pre><code># 去掉查询结果显示id#查询所有记录    db.userInfo.find();    # 相当于：select* from userInfo;# 查询去掉后的当前聚集集合中的某列的重复数据    db.userInfo.distinct(&quot;name&quot;);   会过滤掉name中的相同数据# 查询age = 22的记录    db.userInfo.find({&quot;age&quot;: 22});# 查询age &gt; 22的记录    db.userInfo.find({age: {$gt: 22}});# 查询age &lt; 22的记录    db.userInfo.find({age: {$lt: 22}});# 查询age &gt;= 25的记录    db.userInfo.find({age: {$gte: 25}});# 查询age &lt;= 25的记录    db.userInfo.find({age: {$lte: 25}});# 查询age &gt;= 23 并且 age &lt;= 26    db.userInfo.find({age: {$gte: 23, $lte: 26}});# 查询name中包含 mongo的数据    db.userInfo.find({name: /mongo/});# 查询name中以mongo开头的    db.userInfo.find({name: /^mongo/});# 查询指定列name、age数据     db.userInfo.find({}, {name: 1, age: 1});# 查询指定列name、age数据, age &gt; 25    db.userInfo.find({age: {$gt: 25}}, {name: 1, age: 1});# 按照年龄排序    升序：db.userInfo.find().sort({age: 1});    降序：db.userInfo.find().sort({age: -1});# 查询name = zhangsan, age = 22的数据    db.userInfo.find({name: &apos;zhangsan&apos;, age: 22});# 查询前5条数据    db.userInfo.find().limit(5);# 查询10条以后的数据    db.userInfo.find().skip(10);# 查询在5-10之间的数据    db.userInfo.find().limit(10).skip(5);    可用于分页，limit是pageSize，skip是第几页*pageSize# or与 查询    db.userInfo.find({$or: [{age: 22}, {age: 25}]});# 查询第一条数据    db.userInfo.findOne();# 查询某个结果集的记录条数    db.userInfo.find({age: {$gte: 25}}).count();# 按照某列进行排序    db.userInfo.find({sex: {$exists: true}}).count();</code></pre><p>##索引##</p><pre><code># 创建索引    db.userInfo.ensureIndex({name: 1});    db.userInfo.ensureIndex({name: 1, ts: -1});# 查询当前聚集集合所有索引    db.userInfo.getIndexes();# 查看总索引记录大小    db.userInfo.totalIndexSize();# 读取当前集合的所有index信息    db.users.reIndex();# 删除指定索引    db.users.dropIndex(&quot;name_1&quot;);    # 删除所有索引索引    db.users.dropIndexes();</code></pre><p>##修改、添加、删除集合数据##</p><pre><code># 添加    db.users.save({name: ‘zhangsan&apos;, age: 25, sex: true});# 修改    db.users.update({age: 25}, {$set: {name: &apos;changeName&apos;}}, false, true);    相当于：update users set name = ‘changeName&apos; where age = 25;    db.users.update({name: &apos;Lisi&apos;}, {$inc: {age: 50}}, false, true);    相当于：update users set age = age + 50 where name = ‘Lisi&apos;;    db.users.update({name: &apos;Lisi&apos;}, {$inc: {age: 50}, $set: {name: &apos;hoho&apos;}}, false, true);    相当于：update users set age = age + 50, name = ‘hoho&apos; where name = ‘Lisi&apos;;# 删除    db.users.remove({age: 132});# 查询修改删除    db.users.findAndModify({        query: {age: {$gte: 25}},            #query 查询过滤条件 {}         sort: {age: -1},          #如果多个文档符合查询过滤条件，将以该参数指定的排列方式选择出排在首位的对象        update: {$set: {name: &apos;a2&apos;}, $inc: {age: 2}},        remove: true            #若为true，被选中对象将在返回前被删除     });    db.runCommand({ findandmodify : &quot;users&quot;,        query: {age: {$gte: 25}},        sort: {age: -1},        update: {$set: {name: &apos;a2&apos;}, $inc: {age: 2}},        remove: true    });    #update 或 remove 其中一个是必须的参数; 其他参数可选。</code></pre><p>##语句块操作##</p><pre><code># 简单Hello World    print(&quot;Hello World!&quot;);# 将一个对象转换成json    tojson(new Object());    tojson(new Object(&apos;a&apos;));# 循环添加数据    &gt; for (var i = 0; i &lt; 30; i++) {    ... db.users.save({name: &quot;u_&quot; + i, age: 22 + i, sex: i % 2});    ... };    &gt; for (var i = 0; i &lt; 30; i++) db.users.save({name: &quot;u_&quot; + i, age: 22 + i, sex: i % 2});# find 游标查询    &gt;var cursor = db.users.find();    &gt; while (cursor.hasNext()) {        printjson(cursor.next());    }# forEach迭代循环    db.users.find().forEach(printjson);    # forEach中必须传递一个函数来处理每条迭代的数据信息    db.things.find({x:4}).forEach(function(x) {print(tojson(x));});  # forEach传递函数显示信息# 将find游标当数组处理    var cursor = db.users.find();    cursor[4];    # 取得下标索引为4的那条数据    # 既然可以当做数组处理，那么就可以获得它的长度：cursor.length();或者cursor.count();    # 那样我们也可以用循环显示数据    for (var i = 0, len = c.length(); i &lt; len; i++) printjson(c[i]);# 将find游标转换成数组    &gt; var arr = db.users.find().toArray();    # 用toArray方法将其转换为数组    &gt; printjson(arr[2]);# 定制我们自己的查询结果，只显示age &lt;= 28的并且只显示age这列数据    db.users.find({age: {$lte: 28}}, {age: 1}).forEach(printjson);    db.users.find({age: {$lte: 28}}, {age: true}).forEach(printjson);    db.users.find({age: {$lte: 28}}, {age: false}).forEach(printjson);   #排除age序列</code></pre><p>##其他 ##</p><pre><code># 查询之前的错误信息    db.getPrevError();# 清除错误记录    db.resetError();查看聚集集合基本信息1、查看帮助  db.yourColl.help();2、查询当前集合的数据条数  db.yourColl.count();3、查看数据空间大小 db.userInfo.dataSize();4、得到当前聚集集合所在的db db.userInfo.getDB();5、得到当前聚集的状态 db.userInfo.stats();6、得到聚集集合总大小 db.userInfo.totalSize();7、聚集集合储存空间大小 db.userInfo.storageSize();8、Shard版本信息  db.userInfo.getShardVersion()9、聚集集合重命名 db.userInfo.renameCollection(&quot;users&quot;); 将userInfo重命名为users10、删除当前聚集集合 db.userInfo.drop();show dbs:显示数据库列表show collections：显示当前数据库中的集合（类似关系数据库中的表）show users：显示用户use &lt;db name&gt;：切换当前数据库，这和MS-SQL里面的意思一样db.help()：显示数据库操作命令，里面有很多的命令db.foo.help()：显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令db.foo.find()：对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据）db.foo.find( { a : 1 } )：对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h1 id=&quot;mongo常用操作&quot;&gt;&lt;a href=&quot;#mongo常用操作&quot; class=&quot;headerlink&quot; title=&quot;mongo常用操作&quot;&gt;
      
    
    </summary>
    
      <category term="mongo" scheme="http://www.python100.com/categories/mongo/"/>
    
    
  </entry>
  
  <entry>
    <title>linux系统根目录扩容</title>
    <link href="http://www.python100.com/2018/07/24/%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9/"/>
    <id>http://www.python100.com/2018/07/24/根目录扩容/</id>
    <published>2018-07-24T10:06:00.000Z</published>
    <updated>2018-07-31T15:53:24.984Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><p>VMware的虚机根目录空间不足，添加一个100g磁盘，然后给根目录进行磁盘扩展</p><p>原磁盘：/dev/sda 20g</p><p>新磁盘：/dev/sdb 100g</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment"># df -Th</span></span><br><span class="line">Filesystem              Type      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root xfs        <span class="number">17</span>G  <span class="number">8.7</span>G  <span class="number">8.4</span>G  <span class="number">51</span>% /</span><br><span class="line">devtmpfs                devtmpfs  <span class="number">1.5</span>G     <span class="number">0</span>  <span class="number">1.5</span>G   <span class="number">0</span>% /dev</span><br><span class="line">tmpfs                   tmpfs     <span class="number">1.5</span>G     <span class="number">0</span>  <span class="number">1.5</span>G   <span class="number">0</span>% /dev/shm</span><br><span class="line">tmpfs                   tmpfs     <span class="number">1.5</span>G   <span class="number">11</span>M  <span class="number">1.5</span>G   <span class="number">1</span>% /run</span><br><span class="line">tmpfs                   tmpfs     <span class="number">1.5</span>G     <span class="number">0</span>  <span class="number">1.5</span>G   <span class="number">0</span>% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               xfs      <span class="number">1014</span>M  <span class="number">137</span>M  <span class="number">878</span>M  <span class="number">14</span>% /boot</span><br><span class="line">tmpfs                   tmpfs     <span class="number">300</span>M  <span class="number">4.0</span>K  <span class="number">300</span>M   <span class="number">1</span>% /run/user/<span class="number">42</span></span><br><span class="line">tmpfs                   tmpfs     <span class="number">300</span>M   <span class="number">28</span>K  <span class="number">300</span>M   <span class="number">1</span>% /run/user/<span class="number">1000</span></span><br><span class="line">/dev/sr0                iso9660   <span class="number">4.2</span>G  <span class="number">4.2</span>G     <span class="number">0</span> <span class="number">100</span>% /run/media/qmc/CentOS <span class="number">7</span> x86_64</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment"># pvcreate /dev/sdb</span></span><br><span class="line">  Physical volume <span class="string">"/dev/sdb"</span> successfully created.</span><br><span class="line"> [root@server ~]<span class="comment"># vgs     #查看当前卷组名centos</span></span><br><span class="line">  VG     <span class="comment">#PV #LV #SN Attr   VSize   VFree</span></span><br><span class="line">  centos   <span class="number">1</span>   <span class="number">2</span>   <span class="number">0</span> wz--n- &lt;<span class="number">19.00</span>g    <span class="number">0</span> </span><br><span class="line">[root@server ~]<span class="comment"># vgextend  centos /dev/sdb</span></span><br><span class="line">  Volume group <span class="string">"centos"</span> successfully extended</span><br><span class="line">[root@server ~]<span class="comment"># vgs</span></span><br><span class="line">  VG     <span class="comment">#PV #LV #SN Attr   VSize   VFree   </span></span><br><span class="line">  centos   <span class="number">2</span>   <span class="number">2</span>   <span class="number">0</span> wz--n- <span class="number">118.99</span>g &lt;<span class="number">100.00</span>g</span><br><span class="line">[root@server ~]<span class="comment"># lvextend /dev/centos/root /dev/sdb </span></span><br><span class="line">  Size of logical volume centos/root changed from &lt;<span class="number">17.00</span> GiB (<span class="number">4351</span> extents) to <span class="number">116.99</span> GiB (<span class="number">29950</span> extents).</span><br><span class="line">  Logical volume centos/root successfully resized.</span><br><span class="line">[root@server ~]<span class="comment"># xfs_growfs /dev/mapper/centos-root </span></span><br><span class="line">meta-data=/dev/mapper/centos-root isize=<span class="number">512</span>    agcount=<span class="number">4</span>, agsize=<span class="number">1113856</span> blks</span><br><span class="line">         =                       sectsz=<span class="number">512</span>   attr=<span class="number">2</span>, projid32bit=<span class="number">1</span></span><br><span class="line">         =                       crc=<span class="number">1</span>        finobt=<span class="number">0</span> spinodes=<span class="number">0</span></span><br><span class="line"><span class="keyword">data</span>     =                       bsize=<span class="number">4096</span>   blocks=<span class="number">4455424</span>, imaxpct=<span class="number">25</span></span><br><span class="line">         =                       sunit=<span class="number">0</span>      swidth=<span class="number">0</span> blks</span><br><span class="line">naming   =version <span class="number">2</span>              bsize=<span class="number">4096</span>   ascii-ci=<span class="number">0</span> ftype=<span class="number">1</span></span><br><span class="line">log      =internal               bsize=<span class="number">4096</span>   blocks=<span class="number">2560</span>, version=<span class="number">2</span></span><br><span class="line">         =                       sectsz=<span class="number">512</span>   sunit=<span class="number">0</span> blks, lazy-count=<span class="number">1</span></span><br><span class="line">realtime =none                   extsz=<span class="number">4096</span>   blocks=<span class="number">0</span>, rtextents=<span class="number">0</span></span><br><span class="line"><span class="keyword">data</span> blocks changed from <span class="number">4455424</span> to <span class="number">30668800</span></span><br><span class="line">[root@server ~]<span class="comment"># df -Th</span></span><br><span class="line">Filesystem              Type      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root xfs       <span class="number">117</span>G  <span class="number">8.7</span>G  <span class="number">109</span>G   <span class="number">8</span>% /</span><br><span class="line">devtmpfs                devtmpfs  <span class="number">1.5</span>G     <span class="number">0</span>  <span class="number">1.5</span>G   <span class="number">0</span>% /dev</span><br><span class="line">tmpfs                   tmpfs     <span class="number">1.5</span>G     <span class="number">0</span>  <span class="number">1.5</span>G   <span class="number">0</span>% /dev/shm</span><br><span class="line">tmpfs                   tmpfs     <span class="number">1.5</span>G   <span class="number">11</span>M  <span class="number">1.5</span>G   <span class="number">1</span>% /run</span><br><span class="line">tmpfs                   tmpfs     <span class="number">1.5</span>G     <span class="number">0</span>  <span class="number">1.5</span>G   <span class="number">0</span>% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               xfs      <span class="number">1014</span>M  <span class="number">137</span>M  <span class="number">878</span>M  <span class="number">14</span>% /boot</span><br><span class="line">tmpfs                   tmpfs     <span class="number">300</span>M  <span class="number">4.0</span>K  <span class="number">300</span>M   <span class="number">1</span>% /run/user/<span class="number">42</span></span><br><span class="line">tmpfs                   tmpfs     <span class="number">300</span>M   <span class="number">28</span>K  <span class="number">300</span>M   <span class="number">1</span>% /run/user/<span class="number">1000</span></span><br><span class="line">/dev/sr0                iso9660   <span class="number">4.2</span>G  <span class="number">4.2</span>G     <span class="number">0</span> <span class="number">100</span>% /run/media/qmc/CentOS <span class="number">7</span> x86_64</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;p&gt;VMware的虚机根目录空间不足，添加一个100g磁盘，然后给根目录进行磁盘扩展&lt;/p&gt;&lt;p&gt;原磁盘：/dev/sda 20g&lt;/p&gt;&lt;p&gt;新磁盘：
      
    
    </summary>
    
      <category term="linux" scheme="http://www.python100.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>virsh相关命令</title>
    <link href="http://www.python100.com/2018/07/24/%E5%85%B3%E4%BA%8Evirsh%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.python100.com/2018/07/24/关于virsh相关命令/</id>
    <published>2018-07-24T10:06:00.000Z</published>
    <updated>2018-07-24T10:16:15.780Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><h2 id="关于virsh相关命令"><a href="#关于virsh相关命令" class="headerlink" title="关于virsh相关命令"></a>关于virsh相关命令</h2><p>常用文件路径</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">虚拟机配置文件默认路径：</span><br><span class="line">[root@bainuo qemu]<span class="comment"># pwd</span></span><br><span class="line">/etc/libvirt/qemu</span><br><span class="line">[root@bainuo qemu]<span class="comment"># ls</span></span><br><span class="line">networks  vm01.xml</span><br><span class="line"></span><br><span class="line">磁盘文件默认路径：</span><br><span class="line">[root@bainuo images]<span class="comment"># pwd</span></span><br><span class="line">/var/lib/libvirt/images</span><br><span class="line">[root@bainuo images]<span class="comment"># ls</span></span><br><span class="line">vm01.img</span><br></pre></td></tr></table></figure><h3 id="虚机"><a href="#虚机" class="headerlink" title="虚机"></a>虚机</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">virsh命令参数 功能 用法举例</span><br><span class="line"></span><br><span class="line">list 查看已经存在的domain信息(可以带参数) virsh list --all (查看所有的虚拟机)</span><br><span class="line">start 开始一个不活跃的domain(前提是存在)   virsh start test2</span><br><span class="line">autostart 配置domain随boot启动 virsh autostart test2</span><br><span class="line">shutdown 优雅的关闭domain virsh shutdown test2</span><br><span class="line">destroy 立刻终止一个domain(强制关闭) virsh destroy test2</span><br><span class="line">reboot 重启一个domain(仅仅发送reboot命令)    virsh reboot test2</span><br><span class="line">suspend  挂起服务器   virsh suspend  test2</span><br><span class="line">resume   恢复服务器virsh resume test2</span><br><span class="line"></span><br><span class="line">console 连接domain的虚拟的控制台(只能有<span class="number">1</span>个)  virsh console test2</span><br><span class="line">ttyconsole 输出设备使用的domain的tty console virsh ttyconsole test2</span><br><span class="line">dominfo 返回关于domain的基本信息 virsh dominfo test2</span><br><span class="line">migrate 迁移一个domain到另一台主机  </span><br><span class="line"> </span><br><span class="line">KVM虚拟网络管理命令(virtual network)：</span><br><span class="line">virsh命令参数 功能 用法举例</span><br><span class="line">net-autostart 配置一个虚拟网络开机自启(--disable可以关闭) virsh net-autostart br0</span><br><span class="line">net-create 通过一个xml文件创建一个虚拟网络 virsh net-create ./virbr1.xml</span><br><span class="line">net-define 通过xml文件定义一个虚拟网络，仅定义不实例化 virsh net-define ./virbr1.xml</span><br><span class="line">net-destory 停止由其名称(uuid)指定的虚拟网络，立即生效 virsh net-destroy br0</span><br><span class="line">net-dumpxml 以xml文件的形式输出一个虚拟网络的配置信息 virsh net-dumpxml br0</span><br><span class="line">net-edit 编辑一个虚拟网络的配置文件(修改虚拟网络配置) virsh net-edit br0</span><br><span class="line">net-info 返回要查看的虚拟网络的基本信息 virsh net-info default</span><br><span class="line">net-list 查看当前的虚拟网络信息(可以带参数) virsh net-list --all</span><br><span class="line">net-name  </span><br><span class="line">net-start 开始一个不活跃的虚拟网络 virsh net-start br0</span><br><span class="line">net-undefine 将一个不活跃的虚拟网络取消定义 virsh net-undefine br0</span><br><span class="line">net-uuid  </span><br><span class="line">net-update  </span><br><span class="line"></span><br><span class="line">创建并启用一个网络：net-define -&gt; net-start</span><br><span class="line">virsh net-define br0.xml</span><br><span class="line">virsh net-list --all (有br0网络,但处于不活跃状态)</span><br><span class="line">virsh net-start br0</span><br><span class="line">virsh net-list --all (br0网络已处于活跃状态)</span><br><span class="line"> </span><br><span class="line">停用并删除一个网络(以br0为例)：net-destroy -&gt; net-undefine</span><br><span class="line">virsh net-destroy br0</span><br><span class="line">virsh net-list --all (br0网络变为不活跃状态)</span><br><span class="line">virsh </span><br><span class="line">net-undefine br0</span><br><span class="line">virsh net-list --all (br0网络已被删除)</span><br></pre></td></tr></table></figure><h3 id="存储池"><a href="#存储池" class="headerlink" title="存储池"></a>存储池</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创建基于文件夹的存储池</span><br><span class="line"><span class="number">1</span>) 定义一个存储池</span><br><span class="line">virsh pool-define-as kvm_images dir - - - - “/kvm/images”</span><br><span class="line"><span class="number">2</span>) 查看创建的存储池信息</span><br><span class="line">virsh pool-list –all</span><br><span class="line"><span class="number">3</span>) 建立基于文件夹的存储池</span><br><span class="line">virsh pool-build kvm_images</span><br><span class="line"><span class="number">4</span>) 使存储池生效</span><br><span class="line">virsh pool-start kvm_images</span><br><span class="line"><span class="number">5</span>) 这时候，存储池还不是自动运行，使用virsh pool-autostart</span><br><span class="line">virsh pool-autostart kvm_images</span><br><span class="line"><span class="number">6</span>) 验证存储池</span><br><span class="line">virsh pool-info kvm_images</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">　　virsh回车进入交互式界面：</span><br><span class="line"></span><br><span class="line">version</span><br><span class="line">pwd</span><br><span class="line">hostname　　显示本节点主机名</span><br><span class="line">nodeinfo　　  显示节点信息</span><br><span class="line">list --all　　　显示所有云主机</span><br><span class="line"><span class="number">7</span>种状态：</span><br><span class="line"></span><br><span class="line">  running 　　运行中</span><br><span class="line">  idel　　　　 空闲，未运行</span><br><span class="line">  paused　　 暂停状态</span><br><span class="line">  shutdown　关闭</span><br><span class="line">  crashed　　虚拟机崩溃</span><br><span class="line">  dying　　　垂死状态，但是又没有完全关闭或崩溃</span><br><span class="line">  shutdown &lt;domain&gt;　　</span><br><span class="line">  destroy    &lt;domain&gt;　　强制关闭虚拟机（相当于直接拨电源）</span><br><span class="line">  start　　　&lt;domain&gt;　　启动虚拟机</span><br><span class="line">  edit　 &lt;domain&gt;　　　　 编辑该虚拟机的xml文件</span><br><span class="line">  dommemstat &lt;domain&gt;　获取domain的内存状态</span><br><span class="line">  suspend  &lt;domain&gt;　　    挂起一个正在运行的虚拟机，该虚拟机仍占资源；</span><br><span class="line">  resume  &lt;domain&gt;　　　　从挂起状态恢复一下虚拟机</span><br><span class="line">  vcpuinfo &lt;domain&gt;　　　　显示一些虚拟机的vcpu的信息</span><br><span class="line">  vncdisplay  &lt;domain&gt;　　  显示vnc监听地址和端口</span><br></pre></td></tr></table></figure><h3 id="快照相关命令"><a href="#快照相关命令" class="headerlink" title="快照相关命令"></a>快照相关命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">snapshot-create &lt;domain&gt; xmlfile 　　给domain创建一个snapshot，详细内容保存在xmlfile中</span><br><span class="line">snapshot-current &lt;domain&gt; 　　　　　显示一个domain的当前的snapshot</span><br><span class="line">snapshot-list &lt;domain&gt;　　　　　　　　 显示一个domain的所有的snapshot</span><br><span class="line">snapshot-revert &lt;domain&gt; snapshot 　　    恢复一个domian到以前的snapshot</span><br><span class="line">snapshot-delete &lt;domain&gt; snapshot --children   删除一个domain的snapshot</span><br></pre></td></tr></table></figure><p>如何用<strong>libvirt</strong>远程管理虚拟机？</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">要用libvirt连接到超级管理程序，我们需要一个URI，这个URI配合virsh和virt-viewer命令使用，后面可以跟一些可选项，virt-viewer可以调用一些链接参数，例如：virsh -c qemu:///system 当链接到远程机器时，可以定义几种使用的协议：ssh，tcp，tls。当链接到远程机器时，需要使用远程主机的用户和主机名进行链接，如果没有定义链接用户，则会使用本机环境的<span class="variable">$USER</span>的用户进行链接，当连接到qemu hypervisor时，接受两种链接类型：system可以有所有的访问权限，session有限制的访问。例如：</span><br><span class="line"></span><br><span class="line">使用full access链接至本机的qemu hypervisor，前面的-c 是为了执行后面的list命令(--connect)</span><br><span class="line">virsh -c  qemu:///system list</span><br><span class="line"></span><br><span class="line">使用full access链接至远程主机的qemu hypervisor，每次都要输入ssh密码，改成ssh无密码登陆就不需要输入密码了，直接显示结果。</span><br><span class="line"></span><br><span class="line">　　virsh -c qemu+ssh://tux@mercur/system   直接进入交互virsh模式</span><br><span class="line"></span><br><span class="line">　　virsh -c qemu+ssh://<span class="number">10.1</span>.<span class="number">1.8</span>/system list   直接显示list后的结果</span><br><span class="line"></span><br><span class="line">　　其余连接格式如下：</span><br><span class="line">　　qemu:///session                      (local access to per-user instance)</span><br><span class="line">　　qemu+unix:///session                 (local access to per-user instance)</span><br><span class="line">　　qemu:///system                       (local access to system instance)</span><br><span class="line">　　qemu+unix:///system                  (local access to system instance)</span><br><span class="line">　　qemu://example.com/system            (remote access, TLS/x509)　　</span><br><span class="line">　　qemu+tcp://example.com/system        (remote access, SASl/Kerberos)</span><br><span class="line">　　qemu+ssh:///system   (remote access, SSH tunnelled)</span><br></pre></td></tr></table></figure><h3 id="使用libvirt创建kvm虚拟机："><a href="#使用libvirt创建kvm虚拟机：" class="headerlink" title="使用libvirt创建kvm虚拟机："></a>使用libvirt创建kvm虚拟机：</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、制作虚拟机镜像</span><br><span class="line">qemu-img create -f qcow2 test.qcow2 <span class="number">10</span>G //格式，名字，大小</span><br><span class="line"><span class="number">2</span>、下载并复制iso镜像到指定目录（在第<span class="number">3</span>步中创建xml文件中指定）</span><br><span class="line"><span class="number">3</span>、创建安装配置文件，demo.xml如下，可以根据自己需求更改</span><br><span class="line">virsh define  demo.xml　　　　//创建虚拟机</span><br><span class="line">virsh  start    test_ubuntu 　　//启动虚拟机</span><br><span class="line">virsh  vncdisplay   test_ubuntu   ////查看虚拟机的vnc端口， 然后就可以通过vnc登录来完成虚拟机的安装</span><br></pre></td></tr></table></figure><p>demo.xml 内容如下 默认路径在/etc/libvirt/qemu</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;domain type=<span class="string">'kvm'</span>&gt;</span><br><span class="line">        &lt;name&gt;test_ubuntu&lt;/name&gt; //虚拟机名称</span><br><span class="line">        &lt;memory&gt;<span class="number">1048576</span>&lt;/memory&gt; //最大内存，单位k</span><br><span class="line">        &lt;currentMemory&gt;<span class="number">1048576</span>&lt;/currentMemory&gt; //可用内存，单位k</span><br><span class="line">        &lt;vcpu&gt;<span class="number">8</span>&lt;/vcpu&gt; //虚拟cpu个数</span><br><span class="line">        &lt;os&gt;</span><br><span class="line">          &lt;type arch=<span class="string">'x86_64'</span> machine=<span class="string">'pc'</span>&gt;hvm&lt;/type&gt;</span><br><span class="line">          &lt;boot dev=<span class="string">'cdrom'</span>/&gt; //光盘启动</span><br><span class="line">       &lt;/os&gt;</span><br><span class="line">       &lt;features&gt;</span><br><span class="line">         &lt;acpi/&gt;</span><br><span class="line">         &lt;apic/&gt;</span><br><span class="line">         &lt;pae/&gt;</span><br><span class="line">       &lt;/features&gt;</span><br><span class="line">       &lt;clock offset=<span class="string">'localtime'</span>/&gt;</span><br><span class="line">       &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;</span><br><span class="line">       &lt;on_reboot&gt;restart&lt;/on_reboot&gt;</span><br><span class="line">       &lt;on_crash&gt;destroy&lt;/on_crash&gt;</span><br><span class="line">       &lt;devices&gt;</span><br><span class="line">         &lt;emulator&gt;/usr/libexec/qemu-kvm&lt;/emulator&gt;</span><br><span class="line">         &lt;disk type=<span class="string">'file'</span> device=<span class="string">'disk'</span>&gt;</span><br><span class="line">          &lt;driver name=<span class="string">'qemu'</span> type=<span class="string">'qcow2'</span>/&gt;</span><br><span class="line">           &lt;source file=<span class="string">'/var/lib/libvirt/images/test.qcow2'</span>/&gt; //目的镜像路径</span><br><span class="line">           &lt;target dev=<span class="string">'hda'</span> bus=<span class="string">'ide'</span>/&gt;</span><br><span class="line">         &lt;/disk&gt;</span><br><span class="line">         &lt;disk type=<span class="string">'file'</span> device=<span class="string">'cdrom'</span>&gt;</span><br><span class="line">           &lt;source file=<span class="string">'/var/lib/libvirt/images/ubuntu.iso'</span>/&gt; //光盘镜像路径</span><br><span class="line">           &lt;target dev=<span class="string">'hdb'</span> bus=<span class="string">'ide'</span>/&gt;</span><br><span class="line">         &lt;/disk&gt;</span><br><span class="line">        &lt;interface type=<span class="string">'bridge'</span>&gt; //虚拟机网络连接方式</span><br><span class="line">          &lt;source bridge=<span class="string">'kvmbr0'</span>/&gt; //当前主机网桥的名称</span><br><span class="line">          &lt;mac address=<span class="string">"00:16:3e:5d:aa:a8"</span>/&gt; </span><br><span class="line">          //为虚拟机分配mac地址，务必唯一，否则dhcp获得同样ip,引起冲突</span><br><span class="line">         &lt;/interface&gt;</span><br><span class="line">         &lt;input type=<span class="string">'mouse'</span> bus=<span class="string">'ps2'</span>/&gt;</span><br><span class="line">          &lt;graphics type=<span class="string">'vnc'</span> port=<span class="string">'-1'</span> autoport=<span class="string">'yes'</span> listen = <span class="string">'0.0.0.0'</span> keymap=<span class="string">'en-us'</span>/&gt;</span><br><span class="line">          //vnc方式登录，端口号自动分配，自动加<span class="number">1</span>，可以通过virsh vncdisplay来查询</span><br><span class="line">        &lt;/devices&gt;</span><br><span class="line">      &lt;/domain&gt;</span><br></pre></td></tr></table></figure><h3 id="使用virsh-install安装虚机命令"><a href="#使用virsh-install安装虚机命令" class="headerlink" title="使用virsh-install安装虚机命令"></a>使用virsh-install安装虚机命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt-install \ --name=guest1-rhel5-<span class="number">64</span> \ --file=/var/lib/libvirt/images/guest1-rhel5-<span class="number">64</span>.dsk \ --file-size=<span class="number">8</span> \ --nonsparse --graphics spice \ --vcpus=<span class="number">2</span> --ram=<span class="number">2048</span> \ --location=http://example1.com/installation_tree/RHEL5.<span class="number">6</span>-Serverx86_64/os \ --network bridge=br0 \ --os-type=linux \ --os-variant=rhel5.<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="使用-qemu-img-和-qemu-kvm-命令行方式安装"><a href="#使用-qemu-img-和-qemu-kvm-命令行方式安装" class="headerlink" title="使用 qemu-img 和 qemu-kvm 命令行方式安装"></a>使用 qemu-img 和 qemu-kvm 命令行方式安装</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）创建一个空的qcow2格式的镜像文件</span><br><span class="line">qemu-img create -f qcow2 windows-master.qcow2 <span class="number">10</span>G</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）启动一个虚机，将系统安装盘挂到 cdrom，安装操作系统</span><br><span class="line">qemu-kvm  -hda  windows-master.qcow2  -m <span class="number">512</span> -boot d  -cdrom /home/user/isos/en_winxp_pro_with_sp2.iso</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）现在你就拥有了一个带操作系统的镜像文件。你可以以它为模板创建新的镜像文件。使用模板的好处是，它会被设置为只读所以可以免于破坏。</span><br><span class="line">qemu-img create -b windows-master.qcow2 -f  qcow2   windows-clone.qcow2</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）你可以在新的镜像文件上启动虚机了</span><br><span class="line">qemu-kvm  -hda  windows-clone.qcow2  -m <span class="number">400</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h2 id=&quot;关于virsh相关命令&quot;&gt;&lt;a href=&quot;#关于virsh相关命令&quot; class=&quot;headerlink&quot; title=&quot;关于virsh
      
    
    </summary>
    
      <category term="kvm" scheme="http://www.python100.com/categories/kvm/"/>
    
    
  </entry>
  
  <entry>
    <title> mongo安装和使用</title>
    <link href="http://www.python100.com/2018/07/24/Mongo%E5%AE%89%E8%A3%85%E5%8F%8A%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/"/>
    <id>http://www.python100.com/2018/07/24/Mongo安装及用户认证/</id>
    <published>2018-07-24T10:06:00.000Z</published>
    <updated>2018-07-24T10:24:28.399Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:35 GMT+0800 (CST) --><hr><h1 id="mongo安装和使用"><a href="#mongo安装和使用" class="headerlink" title="mongo安装和使用"></a>mongo安装和使用</h1><p>#<br>安装mongo</p><p>参考文档：<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-red-hat/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-red-hat/</a></p><h3 id="yum安装，先获取repo源"><a href="#yum安装，先获取repo源" class="headerlink" title="yum安装，先获取repo源"></a>yum安装，先获取repo源</h3><pre><code>[mongodb-enterprise]name=MongoDB Enterprise Repositorybaseurl=https://repo.mongodb.com/yum/redhat/$releasever/mongodb-enterprise/3.6/$basearch/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc</code></pre><p>sudo yum install -y mongodb-enterprise #安装最新mongo，默认会依赖安装下面的包</p><pre><code>mongodb-enterprise,mongodb-enterprise-server,mongodb-enterprise-shell,mongodb-enterprise-mongos,mongodb-enterprise-tools</code></pre><p>安装指定版本使用下面命令</p><pre><code>yum install -y mongodb-enterprise-3.6.5 mongodb-enterprise-server-3.6.5 mongodb-enterprise-shell-3.6.5 mongodb-enterprise-mongos-3.6.5 mongodb-enterprise-tools-3.6.5</code></pre><p>启动使用</p><pre><code>systemctl start mongodservice mongod start/stop/restartchkconfig mongod onmongo --host 127.0.0.1:27017</code></pre><p>数据目录</p><pre><code>日志：/var/log/mongodb数据：/var/lig/mongo</code></pre><h3 id="使用resource安装"><a href="#使用resource安装" class="headerlink" title="使用resource安装"></a>使用resource安装</h3><p>获取Mongo的安装包：</p><pre><code>curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.6.tgztar -xf mongodb-linux-x86_64-3.4.6.tgzmv mongodb-3.4.6 /usr/local/mongodbcd /usr/local/mongodb手动创建db和log目录mkdir -p /data/dbmkdir /data/logtouch /data/log/mongodb.log</code></pre><p>启动mongo</p><pre><code>./bin/mongod  --dbpath /data/db --logpath /data/log/mongodb.log --fork --port 27017--dbpath 数据存储目录--logpath mongo运行日志记录--fork 是后台运行--port  是运行的端口（默认是27017）</code></pre><p><img src="/images/mongo/mongo1.jpg" alt="mongo1"></p><p>出现如上图的字样就说明启动成功了</p><p>进入数据库</p><pre><code>./bin/mongo  </code></pre><p><img src="/images/mongo/mongo2.jpg" alt="mongo2"></p><h3 id="mongodb数据简介"><a href="#mongodb数据简介" class="headerlink" title="mongodb数据简介"></a>mongodb数据简介</h3><pre><code>mongodb是一个介于nosql数据库和mysql数据库之间的一个数据存储系统，它没有严格的数据格式，但同时支持复杂查询，而且自带sharding模式和Replica Set模式，支持分片模式，复制模式，自动故障处理，自动故障转移，自动扩容，全内容索引，动态查询等功能。扩展性和功能都比较强大。mongodb在数据查询方面，支持类sql查询，可以一个key多value内容，可以组合多个value内容来查询，支持索引，支持联合索引，支持复杂查询 ，支持排序，基本上除了join和事务类型的操作外，mongodb支持所有mysql支持的查询，甚至某个客户端api支持直接使用sql语句查询mongodb。mongodb的sharding功能目前日渐完善，支持自定义范围分片，hash自动分片等，分片自动扩容，shard之间自动负载均衡等功能。实际使用中功能还不错。mongodb 文档数据库,存储的是文档(Bson-&gt;json的二进制化).特点:内部执行引擎为JS解释器, 把文档存储成bson结构,在查询时,转换为JS对象,并可以通过熟悉的js语法来操作.mongo和传统型数据库相比,最大的不同:传统型数据库: 结构化数据, 定好了表结构后,每一行的内容,必是符合表结构的,就是说--列的个数,类型都一样.mongo文档型数据库: 表下的每篇文档,都可以有自己独特的结构(json对象都可以有自己独特的属性和值)</code></pre><p>安装目录下，bin下脚本作用</p><p><img src="/images/mongo/mongo3.png" alt="mongo3"></p><p>##mongo数据库的用户验证##<br>超级账号创建<br>&gt; db.createUser(<br>… … {<br>… … user:”admin”,<br>… … pwd:”admin123”,<br>… … roles:[ { role:”userAdminAnyDatabase”,db:”admin”}]<br>… … } )</p><pre><code>创建完成后，修改mongo启动的配置文件，加入auth=ondbpath=/data/dblogpath=/data/log/mongodb.confport=27017auth=onfork=truelogappend=true杀死mongo的所有进程，pkill -9 mongo  重新启动mongod(server)[root@www1 mongodb]# ~/bin/mongod -f conf/mongodb.conf about to fork child process, waiting until server is ready for connections.forked process: 18135child process started successfully, parent exiting[root@www1 mongodb]# ./bin/mongo  启动mongo(client)&gt; show dbs2018-06-24T21:47:19.974+0800 E QUERY    [thread1] Error: listDatabases failed:{    &quot;ok&quot; : 0,    &quot;errmsg&quot; : &quot;not authorized on admin to execute command { listDatabases: 1.0, $db: \&quot;admin\&quot; }&quot;,    &quot;code&quot; : 13,    &quot;codeName&quot; : &quot;Unauthorized&quot;} :这时无法show dbs就没有权限查看数据库了，需要使用admin来验证登陆&gt; db.auth(&apos;admin&apos;,&apos;admin123&apos;)1返回1表示已经验证成功 &gt; show dbsadmin   0.000GBconfig  0.000GBdata    0.000GBlocal   0.000GB此时admin验证成功，但是每个数据库此时会要有自己的认证用户若要查看某一个数据库的数据，还要使用admin超管为每个数据库创建账号，并认证登陆需要注意的是在建立data数据库用户的时候一定要先启用data数据库，否则会出现问题&gt;use data&gt;db.createUser({user:&apos;u1&apos;,pwd:&apos;123qwe&apos;,roles:[{role:&apos;readWrite&apos;,db:&apos;data&apos;}]})&gt; db.auth(&apos;u1&apos;,&apos;123qwe&apos;)1&gt; show collectionsstu</code></pre><p>超管密码忘记，更改密码步骤：</p><p>1、更改配置文件，将auth=true注释掉，或者true改为false</p><p>2、重启mongo</p><pre><code>pkill -9 mongo  ./bin/mongod -f conf/mongodb.conf./bin/mongo&gt;use admin&gt; db.system.users.find()  #查找admin用户&gt; db.system.users.remove({&apos;_id&apos;:&apos;data.admin&apos;}) #根据id将admin用户删除，然后重新建admin&gt; &gt; db.createUser(    ... ... {    ... ...    user:&quot;admin&quot;,    ... ...    pwd:&quot;admin123&quot;,    ... ...    roles:[ { role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;}]    ... ... } )db.createUser({ user:&quot;admin&quot;,pwd:&quot;admin123&quot;, roles:[{role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;}]})</code></pre><p>3、再次kill掉mongo，将auth改为true后进行重启</p><h2 id="mongo数据库Role"><a href="#mongo数据库Role" class="headerlink" title="mongo数据库Role"></a>mongo数据库Role</h2><pre><code>Built-In Roles（内置角色）：1. 数据库用户角色：read、readWrite;2. 数据库管理角色：dbAdmin、dbOwner、userAdmin；3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；4. 备份恢复角色：backup、restore；5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase6. 超级用户角色：root  // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）7. 内部角色：__systemRead：允许用户读取指定数据库readWrite：允许用户读写指定数据库dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profileuserAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。root：只在admin数据库中可用。超级账号，超级权限userAdminAnyDatabase 权限只是针对用户管理的，对其他是没有权限的。mongodump --port=27020 -uzjyr -pzjyr --db=test -o backup   #只要读权限就可以备份mongorestore --port=27020 -uzjy -pzjy --db=test backup/test/  #读写权限可以进行还原更新用户密码    use xx    db.changeUserPassword(&quot;username&quot;,&quot;newpassword&quot;)删除用户    切换到用户授权的db    use xx    执行删除操作    db.dropUser(&quot;username&quot;)更新用户    切换到用户授权的db    use xx    执行更新    字段会覆盖原来的内容    db.updateUser(&quot;username&quot;,{        pwd:&quot;new password&quot;,        customData:{            &quot;title&quot;:&quot;PHP developer&quot;        }    })查看角色信息    use admin    db.getRole(&quot;rolename&quot;,{showPrivileges:true})删除角色    use admin    db.dropRole(&quot;rolename&quot;)更新用户密码查看用户信息    use admin    db.getUser(&quot;username&quot;)</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:35 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h1 id=&quot;mongo安装和使用&quot;&gt;&lt;a href=&quot;#mongo安装和使用&quot; class=&quot;headerlink&quot; title=&quot;mongo安装和使
      
    
    </summary>
    
      <category term="mongo" scheme="http://www.python100.com/categories/mongo/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodump与mongorestore</title>
    <link href="http://www.python100.com/2018/07/24/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>http://www.python100.com/2018/07/24/mongo数据库备份与恢复/</id>
    <published>2018-07-24T10:06:00.000Z</published>
    <updated>2018-07-31T15:54:03.147Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --><hr><h1 id="MongoDB-备份-mongodump-与恢复-mongorestore"><a href="#MongoDB-备份-mongodump-与恢复-mongorestore" class="headerlink" title="MongoDB 备份(mongodump)与恢复(mongorestore)"></a>MongoDB 备份(mongodump)与恢复(mongorestore)</h1><ul><li>mongoexport/mongoimport导入/导出的是JSON格式，而mongodump/mongorestore导入/导出的是BSON格式。<br>JSON可读性强但体积较大，BSON则是二进制文件，体积小但对人类几乎没有可读性。<br>在一些mongodb版本之间，BSON格式可能会随版本不同而有所不同，所以不同版本之间用mongodump/mongorestore可能<br>不会成功，具体要看版本之间的兼容性。当无法使用BSON进行跨版本的数据迁移的时候，使用JSON格式即mongoexport/mongoimport是一个可选项。跨版本的mongodump/mongorestore个人并不推荐，实在要做请先检查文档看两个版本是否兼容（大部分时候是的）。<br>JSON虽然具有较好的跨版本通用性，但其只保留了数据部分，不保留索引，账户等其他基础信息。使用时应该注意。</li></ul><p>mongodump命令脚本语法如下：</p><pre><code>&gt;mongodump -h dbhost -d dbname -o dbdirectory -h：    MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017-d：    需要备份的数据库实例，例如：test-o：    备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，    系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 </code></pre><p>mongodump –host HOST_NAME –port PORT_NUMBER 该命令将备份所有MongoDB数据<br>mongodump –host runoob.com –port 27017</p><p>[root@www1 mongodb]# mongodump -h localhost -u u1 -p 123qwe -d data -o data_mongo.tar</p><p>mongodump –dbpath DB_PATH –out BACKUP_DIRECTORY<br>mongodump –dbpath /data/db/ –out /data/backup/</p><p>mongodump –collection COLLECTION –db DB_NAME 该命令将备份指定数据库的集合。<br>mongodump –collection mycol –db test</p><h1 id="mongorestore"><a href="#mongorestore" class="headerlink" title="mongorestore"></a>mongorestore</h1><p>mogorestore命令脚本语法如下：</p><pre><code>&gt;mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;--host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017--db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2--drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！path：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 &lt;path&gt; 和 --dir 选项，--dir也可以设置备份目录。--dir：指定备份的目录你不能同时指定 &lt;path&gt; 和 --dir 选项。</code></pre><h1 id="mongoexport"><a href="#mongoexport" class="headerlink" title="mongoexport"></a>mongoexport</h1><pre><code>参数    -h:指明数据库宿主机的IP    -u:指明数据库的用户名    -p:指明数据库的密码    -d:指明数据库的名字    -c:指明collection的名字    -f:指明要导出那些列    -o:指明到要导出的文件名    -q:指明导出数据的过滤条件    root@mongo:~/cas.mongo# mongorestore -h mongo:27017 -uadmin -pPassw0rd  -d admin admin    root@mongo:~/cas.mongo# mongorestore -h mongo:27017 -ucas -pPassw0rd  -d cas cas[root@localhost mongodb]# ./bin/mongoexport -d test -c students -o students.dat      -d:指明使用的库，本例中为test    -c:指明要导出的集合，本例中为students    -o:指明要导出的文件名，本例中为students.dat./bin/mongoexport -d test -c students --csv -f classid,name,age -o students_csv.dat     -csv：指明要导出为csv格式    -f：指明需要导出classid、name、age这3列的数据 </code></pre><h1 id="mongoimport"><a href="#mongoimport" class="headerlink" title="mongoimport"></a>mongoimport</h1><pre><code>参数    -h:指明数据库宿主机的IP    -u:指明数据库的用户名    -p:指明数据库的密码    -d:指明数据库的名字    -c:指明collection的名字    -f:指明要导入那些列./bin/mongoimport -d test -c students students.dat     参数说明：    -d:指明数据库名，本例中为test    -c:指明collection名，本例中为students    students.dat：导入的文件名./bin/mongoimport -d test -c students --type csv --headerline --file students_csv.dat       -type:指明要导入的文件格式    -headerline:指明第一行是列名，不需要导入    -file：指明要导入的文件</code></pre><p>–备份单个表</p><pre><code>mongodump -u  superuser -p 123456  --port 27017 --authenticationDatabase admin -d myTest -c d -o /backup/mongodb/myTest_d_bak_201507021701.bak</code></pre><p>–备份单个库</p><pre><code>mongodump  -u  superuser -p 123456 --port 27017  --authenticationDatabase admin -d myTest -o  /backup/mongodb/</code></pre><p>–备份所有库</p><pre><code>mongodump  -u  superuser -p 123456 --authenticationDatabase admin  --port 27017 -o /root/bak </code></pre><p>–备份所有库推荐使用添加–oplog参数的命令，这样的备份是基于某一时间点的快照，只能用于备份全部库时才可用，单库和单表不适用：</p><pre><code>mongodump -h 127.0.0.1 --port 27017   --oplog -o  /root/bak </code></pre><p>–同时，恢复时也要加上–oplogReplay参数，具体命令如下(下面是恢复单库的命令)：</p><pre><code>mongorestore  -d swrd --oplogReplay  /home/mongo/swrdbak/swrd/</code></pre><p>–恢复单个库：</p><pre><code>mongorestore  -u  superuser -p 123456 --port 27017  --authenticationDatabase admin -d myTest   /backup/mongodb/</code></pre><p>–恢复所有库：</p><pre><code>mongorestore   -u  superuser -p 123456 --port 27017  --authenticationDatabase admin  /root/bak</code></pre><p>–恢复单表</p><pre><code>mongorestore -u  superuser -p 123456  --authenticationDatabase admin -d myTest -c d /backup/mongodb/myTest_d_bak_201507021701.bak/myTest/d.bson</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Oct 12 2018 16:22:34 GMT+0800 (CST) --&gt;&lt;hr&gt;&lt;h1 id=&quot;MongoDB-备份-mongodump-与恢复-mongorestore&quot;&gt;&lt;a href=&quot;#MongoDB-备份-mongodump
      
    
    </summary>
    
      <category term="mongo" scheme="http://www.python100.com/categories/mongo/"/>
    
    
  </entry>
  
</feed>
