{"meta":{"title":"乘风破浪","subtitle":null,"description":null,"author":"chen","url":"http://www.python100.com"},"pages":[{"title":"404公益","date":"2018-07-24T09:19:40.000Z","updated":"2018-07-24T09:22:29.893Z","comments":true,"path":"404公益/index.html","permalink":"http://www.python100.com/404公益/index.html","excerpt":"","text":"&lt;!DOCTYPE HTML&gt;"},{"title":"About","date":"2018-07-24T09:13:58.000Z","updated":"2018-07-24T09:42:57.490Z","comments":true,"path":"About/index.html","permalink":"http://www.python100.com/About/index.html","excerpt":"","text":"wo shi chen"},{"title":"categories","date":"2018-07-13T08:55:27.000Z","updated":"2018-07-13T08:57:25.640Z","comments":true,"path":"categories/index.html","permalink":"http://www.python100.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-06-15T05:05:00.782Z","updated":"2018-06-15T02:18:29.429Z","comments":false,"path":"repository/index.html","permalink":"http://www.python100.com/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-13T08:55:16.000Z","updated":"2018-07-13T08:57:45.320Z","comments":true,"path":"tags/index.html","permalink":"http://www.python100.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"kvm安装","slug":"安装kvm","date":"2018-07-24T10:09:00.000Z","updated":"2018-07-24T10:17:24.624Z","comments":true,"path":"2018/07/24/安装kvm/","link":"","permalink":"http://www.python100.com/2018/07/24/安装kvm/","excerpt":"","text":"VMware虚机在启动之前开启CPU虚拟化1、安装桌面GUIyum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot; 2、安装kvmyum -y install libcanberra-gtk2 qemu-kvm.x86_64 qemu-kvm-tools.x86_64 libvirt.x86_64 libvirt-cim.x86_64 libvirt-client.x86_64 libvirt-java.noarch libvirt-python.x86_64 libiscsi-1.7.0-5.el6.x86_64 dbus-devel virt-clone tunctl virt-manager libvirt libvirt-python python-virtinst 查看kvm模块是否已经安装成功3、安装桥接网络，并设置/yum -y install bridge-utils设置完成后重启网络，并查看网络[root@localhost network-scripts]# brctl show bridge name bridge id STP enabled interfaces br0 8000.000c29c12e49 yes ens37 virbr0 8000.525400c9ff4e yes virbr0-nic 4、重启libvirt,设置开机自启动systemctl start libvirtd systemctl enable libvirtd 5、使用virt-manager图形化来管理kvm虚机之后就是正常安装系统的步骤","categories":[],"tags":[]},{"title":" mongo安装和使用","slug":"Mongo安装及用户认证","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:24:28.399Z","comments":true,"path":"2018/07/24/Mongo安装及用户认证/","link":"","permalink":"http://www.python100.com/2018/07/24/Mongo安装及用户认证/","excerpt":"","text":"mongo安装和使用#安装mongo参考文档：https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-red-hat/yum安装，先获取repo源[mongodb-enterprise] name=MongoDB Enterprise Repository baseurl=https://repo.mongodb.com/yum/redhat/$releasever/mongodb-enterprise/3.6/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc sudo yum install -y mongodb-enterprise #安装最新mongo，默认会依赖安装下面的包mongodb-enterprise, mongodb-enterprise-server, mongodb-enterprise-shell, mongodb-enterprise-mongos, mongodb-enterprise-tools 安装指定版本使用下面命令yum install -y mongodb-enterprise-3.6.5 mongodb-enterprise-server-3.6.5 mongodb-enterprise-shell-3.6.5 mongodb-enterprise-mongos-3.6.5 mongodb-enterprise-tools-3.6.5 启动使用systemctl start mongod service mongod start/stop/restart chkconfig mongod on mongo --host 127.0.0.1:27017 数据目录日志：/var/log/mongodb 数据：/var/lig/mongo 使用resource安装获取Mongo的安装包：curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.6.tgz tar -xf mongodb-linux-x86_64-3.4.6.tgz mv mongodb-3.4.6 /usr/local/mongodb cd /usr/local/mongodb 手动创建db和log目录 mkdir -p /data/db mkdir /data/log touch /data/log/mongodb.log 启动mongo./bin/mongod --dbpath /data/db --logpath /data/log/mongodb.log --fork --port 27017 --dbpath 数据存储目录 --logpath mongo运行日志记录 --fork 是后台运行 --port 是运行的端口（默认是27017） 出现如上图的字样就说明启动成功了进入数据库./bin/mongo mongodb数据简介mongodb是一个介于nosql数据库和mysql数据库之间的一个数据存储系统，它没有严格的数据格式， 但同时支持复杂查询，而且自带sharding模式和Replica Set模式，支持分片模式，复制模式， 自动故障处理，自动故障转移，自动扩容，全内容索引，动态查询等功能。扩展性和功能都比较强大。 mongodb在数据查询方面，支持类sql查询，可以一个key多value内容，可以组合多个value内容来查询， 支持索引，支持联合索引，支持复杂查询 ，支持排序，基本上除了join和事务类型的操作外， mongodb支持所有mysql支持的查询，甚至某个客户端api支持直接使用sql语句查询mongodb。 mongodb的sharding功能目前日渐完善，支持自定义范围分片，hash自动分片等，分片自动扩容， shard之间自动负载均衡等功能。实际使用中功能还不错。 mongodb 文档数据库,存储的是文档(Bson-&gt;json的二进制化). 特点:内部执行引擎为JS解释器, 把文档存储成bson结构,在查询时,转换为JS对象,并可以通过熟悉的js语法来操作. mongo和传统型数据库相比,最大的不同: 传统型数据库: 结构化数据, 定好了表结构后,每一行的内容,必是符合表结构的,就是说--列的个数,类型都一样. mongo文档型数据库: 表下的每篇文档,都可以有自己独特的结构(json对象都可以有自己独特的属性和值) 安装目录下，bin下脚本作用##mongo数据库的用户验证##超级账号创建&gt; db.createUser(… … {… … user:”admin”,… … pwd:”admin123”,… … roles:[ { role:”userAdminAnyDatabase”,db:”admin”}]… … } )创建完成后，修改mongo启动的配置文件，加入auth=on dbpath=/data/db logpath=/data/log/mongodb.conf port=27017 auth=on fork=true logappend=true 杀死mongo的所有进程， pkill -9 mongo 重新启动mongod(server) [root@www1 mongodb]# ~/bin/mongod -f conf/mongodb.conf about to fork child process, waiting until server is ready for connections. forked process: 18135 child process started successfully, parent exiting [root@www1 mongodb]# ./bin/mongo 启动mongo(client) &gt; show dbs 2018-06-24T21:47:19.974+0800 E QUERY [thread1] Error: listDatabases failed:{ &quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;not authorized on admin to execute command { listDatabases: 1.0, $db: \\&quot;admin\\&quot; }&quot;, &quot;code&quot; : 13, &quot;codeName&quot; : &quot;Unauthorized&quot; } : 这时无法show dbs就没有权限查看数据库了，需要使用admin来验证登陆 &gt; db.auth(&apos;admin&apos;,&apos;admin123&apos;) 1 返回1表示已经验证成功 &gt; show dbs admin 0.000GB config 0.000GB data 0.000GB local 0.000GB 此时admin验证成功，但是每个数据库此时会要有自己的认证用户 若要查看某一个数据库的数据，还要使用admin超管为每个数据库创建账号，并认证登陆 需要注意的是在建立data数据库用户的时候一定要先启用data数据库，否则会出现问题 &gt;use data &gt;db.createUser({user:&apos;u1&apos;,pwd:&apos;123qwe&apos;,roles:[{role:&apos;readWrite&apos;,db:&apos;data&apos;}]}) &gt; db.auth(&apos;u1&apos;,&apos;123qwe&apos;) 1 &gt; show collections stu 超管密码忘记，更改密码步骤：1、更改配置文件，将auth=true注释掉，或者true改为false2、重启mongopkill -9 mongo ./bin/mongod -f conf/mongodb.conf ./bin/mongo &gt;use admin &gt; db.system.users.find() #查找admin用户 &gt; db.system.users.remove({&apos;_id&apos;:&apos;data.admin&apos;}) #根据id将admin用户删除，然后重新建admin &gt; &gt; db.createUser( ... ... { ... ... user:&quot;admin&quot;, ... ... pwd:&quot;admin123&quot;, ... ... roles:[ { role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;}] ... ... } ) db.createUser({ user:&quot;admin&quot;,pwd:&quot;admin123&quot;, roles:[{role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;}]}) 3、再次kill掉mongo，将auth改为true后进行重启mongo数据库RoleBuilt-In Roles（内置角色）： 1. 数据库用户角色：read、readWrite; 2. 数据库管理角色：dbAdmin、dbOwner、userAdmin； 3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager； 4. 备份恢复角色：backup、restore； 5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase 6. 超级用户角色：root // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase） 7. 内部角色：__system Read：允许用户读取指定数据库 readWrite：允许用户读写指定数据库 dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户 clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。 readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限 userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限 dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。 root：只在admin数据库中可用。超级账号，超级权限 userAdminAnyDatabase 权限只是针对用户管理的，对其他是没有权限的。 mongodump --port=27020 -uzjyr -pzjyr --db=test -o backup #只要读权限就可以备份 mongorestore --port=27020 -uzjy -pzjy --db=test backup/test/ #读写权限可以进行还原 更新用户密码 use xx db.changeUserPassword(&quot;username&quot;,&quot;newpassword&quot;) 删除用户 切换到用户授权的db use xx 执行删除操作 db.dropUser(&quot;username&quot;) 更新用户 切换到用户授权的db use xx 执行更新 字段会覆盖原来的内容 db.updateUser(&quot;username&quot;,{ pwd:&quot;new password&quot;, customData:{ &quot;title&quot;:&quot;PHP developer&quot; } }) 查看角色信息 use admin db.getRole(&quot;rolename&quot;,{showPrivileges:true}) 删除角色 use admin db.dropRole(&quot;rolename&quot;)更新用户密码 查看用户信息 use admin db.getUser(&quot;username&quot;)","categories":[{"name":"mongo","slug":"mongo","permalink":"http://www.python100.com/categories/mongo/"}],"tags":[]},{"title":"mysql数据库迁移如mongo数据库步骤","slug":"cq平台迁移数据库备份步骤","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:26:36.891Z","comments":true,"path":"2018/07/24/cq平台迁移数据库备份步骤/","link":"","permalink":"http://www.python100.com/2018/07/24/cq平台迁移数据库备份步骤/","excerpt":"","text":"备份MySQL12root@db:/# mysqldump -uroot -p -d campus&gt;campus.sql #密码 Passwrd备份Mongo12root@mongo:~# mongodump -d user -o userroot@mongo:~# mongodump -d store -o store将MySQL备份成Mongo格式，使用python脚本来实现，脚本如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import pymysql,osimport pandas as pdfrom sqlalchemy import create_enginehost='192.168.100.100'port=3306user='root'password='123qwe'database='data'#存放导出的数据的路径BASE_DIR=\"D:\\\\mygit\\\\old\\\\\"#定义连接数据库的引擎dbconn=pymysql.connect( host=host, port=port, user=user, password=password, database=database, charset='utf8', cursorclass=pymysql.cursors.DictCursor )table_list=[]#查询数据库中的表的sql语句tab_sql=\"show tables;\"#获取查询数据库游标cursor=dbconn.cursor()#执行查询所有表cursor.execute(tab_sql)#获取查询的结果，结果是一系列字典组成的字典res=cursor.fetchall()#使用循环，将具体的表名从结果中取出来存入存放到一个列表中for i in range(len(res)): table_list.append(res[i]['Tables_in_%s'%database])# print(table_list)cursor.close()dbconn.close()import csvfor t in table_list: print((\"%s表中数据\"%t).center(50,\"*\")) #为每一个表新建一个文件，保存输出的结果 path=BASE_DIR+t fp=open(path,'w',encoding=\"utf-8\") conn=pymysql.connect( host=host, port=port, user=user, password=password, database=database, charset='utf8', cursorclass=pymysql.cursors.DictCursor ) cursor=conn.cursor() print(cursor) sql=\"select * from %s\"%t print(sql) cursor.execute(sql) res =cursor.fetchall() for var in res: fileds=var.keys() fp.write(str(var)) fp.close()将导出的文件导入Mongo123456789#!/bin/bashBASE_PATH=\"/root/old\"for var in `ls $BASE_PATH` :do echo $var #mongoimport -uadmin -pPassw0rd -d old -c $var $BASE_PATH/$var mongoimport -d old -c $var $BASE_PATH/$vardone将MySQL导出为csv格式1mysql -uusername -ppassword -h 172.16.81.236 –D my_db --default-character-set=gbk -e 'select * from server_warning_unrepaired' | sed 's/\\t/\",\"/g;s/^/\"/;s/$/\"/;s/\\n//g' &gt; /tmp/file.csv将csv到如到mongo1mongoimport --db network1 --collection networkmanagement --type csv --headerline --ignoreBlanks --file /home/erik/Documents/networkmanagement-1.csv","categories":[{"name":"mongo","slug":"mongo","permalink":"http://www.python100.com/categories/mongo/"}],"tags":[{"name":"mysql迁移","slug":"mysql迁移","permalink":"http://www.python100.com/tags/mysql迁移/"}]},{"title":"docker设置本地仓库","slug":"docker_registry","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:20:14.325Z","comments":true,"path":"2018/07/24/docker_registry/","link":"","permalink":"http://www.python100.com/2018/07/24/docker_registry/","excerpt":"","text":"account:chenqmcopenssl req -newkey rsa:4096 -nodes -sha256 -keyout ${HOSTNAME}.key -x509 -days 365 -out ${HOSTNAME}.crt vim /etc/docker/daemon.json{&quot;registry-mirrors&quot;: [&quot;http://187193f5.m.daocloud.io&quot;]} 拉取registrydocker pull registry 启动registrydocker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry 将镜像进行tag打包，传入本地镜像[root@www1 ~]# docker tag 471e783ffeca 127.0.0.1:5000/mdc-cas [root@www1 ~]# docker push 127.0.0.1:5000/mdc-cas","categories":[{"name":"docker","slug":"docker","permalink":"http://www.python100.com/categories/docker/"}],"tags":[]},{"title":"linux系统根目录扩容","slug":"根目录扩容","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:09:02.326Z","comments":true,"path":"2018/07/24/根目录扩容/","link":"","permalink":"http://www.python100.com/2018/07/24/根目录扩容/","excerpt":"","text":"VMware的虚机根目录空间不足，添加一个100g磁盘，然后给根目录进行磁盘扩展原磁盘：/dev/sda 20g新磁盘：/dev/sdb 100g1234567891011[root@server ~]# df -ThFilesystem Type Size Used Avail Use% Mounted on/dev/mapper/centos-root xfs 17G 8.7G 8.4G 51% /devtmpfs devtmpfs 1.5G 0 1.5G 0% /devtmpfs tmpfs 1.5G 0 1.5G 0% /dev/shmtmpfs tmpfs 1.5G 11M 1.5G 1% /runtmpfs tmpfs 1.5G 0 1.5G 0% /sys/fs/cgroup/dev/sda1 xfs 1014M 137M 878M 14% /boottmpfs tmpfs 300M 4.0K 300M 1% /run/user/42tmpfs tmpfs 300M 28K 300M 1% /run/user/1000/dev/sr0 iso9660 4.2G 4.2G 0 100% /run/media/qmc/CentOS 7 x86_641234567891011121314151617181920212223242526272829303132333435[root@server ~]# pvcreate /dev/sdb Physical volume \"/dev/sdb\" successfully created. [root@server ~]# vgs #查看当前卷组名centos VG #PV #LV #SN Attr VSize VFree centos 1 2 0 wz--n- &lt;19.00g 0 [root@server ~]# vgextend centos /dev/sdb Volume group \"centos\" successfully extended[root@server ~]# vgs VG #PV #LV #SN Attr VSize VFree centos 2 2 0 wz--n- 118.99g &lt;100.00g[root@server ~]# lvextend /dev/centos/root /dev/sdb Size of logical volume centos/root changed from &lt;17.00 GiB (4351 extents) to 116.99 GiB (29950 extents). Logical volume centos/root successfully resized.[root@server ~]# xfs_growfs /dev/mapper/centos-root meta-data=/dev/mapper/centos-root isize=512 agcount=4, agsize=1113856 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0 spinodes=0data = bsize=4096 blocks=4455424, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0data blocks changed from 4455424 to 30668800[root@server ~]# df -ThFilesystem Type Size Used Avail Use% Mounted on/dev/mapper/centos-root xfs 117G 8.7G 109G 8% /devtmpfs devtmpfs 1.5G 0 1.5G 0% /devtmpfs tmpfs 1.5G 0 1.5G 0% /dev/shmtmpfs tmpfs 1.5G 11M 1.5G 1% /runtmpfs tmpfs 1.5G 0 1.5G 0% /sys/fs/cgroup/dev/sda1 xfs 1014M 137M 878M 14% /boottmpfs tmpfs 300M 4.0K 300M 1% /run/user/42tmpfs tmpfs 300M 28K 300M 1% /run/user/1000/dev/sr0 iso9660 4.2G 4.2G 0 100% /run/media/qmc/CentOS 7 x86_64","categories":[{"name":"根目录扩容","slug":"根目录扩容","permalink":"http://www.python100.com/categories/根目录扩容/"}],"tags":[]},{"title":"hexo搭建个人博客","slug":"hexo搭建","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:19:15.999Z","comments":true,"path":"2018/07/24/hexo搭建/","link":"","permalink":"http://www.python100.com/2018/07/24/hexo搭建/","excerpt":"","text":"1、安装12345678yum -y install npm gitmkdir /hexocd /hexohexo init npm install npm install --save hexo-admin npm install hexo-cli hexo server2、常用命令12345清理缓存命令：hexo clean重新构建项目：hexo generate启动server: hexo server -p 4000 提交改动到git：hexo deploy新建标签页：hexo new page tags3、博客主题下载网址1https://hexo.io/themes/4、","categories":[{"name":"hexo","slug":"hexo","permalink":"http://www.python100.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.python100.com/tags/hexo/"}]},{"title":"zfs和gluster安装","slug":"centos7上安装zfs和gluster","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:22:25.110Z","comments":true,"path":"2018/07/24/centos7上安装zfs和gluster/","link":"","permalink":"http://www.python100.com/2018/07/24/centos7上安装zfs和gluster/","excerpt":"","text":"在同一台主机上zfs和gluster无法同时安装centos7上安装zfshttps://blog.csdn.net/linuxnews/article/details/512863581、获取163yum源wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo2、安装zfs的yum源yum -y install http://download.zfsonlinux.org/epel/zfs-release.el7_3.noarch.rpm3、安装zfsyum -y install kernel zfs12yum localinstall --nogpgcheck http://epel.mirror.net.in/epel/7/x86_64/e/epel-release-7-5.noarch.rpmyum localinstall --nogpgcheck http://archive.zfsonlinux.org/epel/zfs-release.el7.noarch.rpm1yum install kernel-devel zfszfs命令 ——&gt; https://docs.oracle.com/cd/E26926_01/html/E29115/zfs-1m.htmlzpool命令 ——&gt; https://docs.oracle.com/cd/E26926_01/html/E29115/zpool-1m.html安装gluster1、获取163yum源​ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo2、安装最新版本的gluster软件仓库：​ yum -y install centos-release-gluster3103、安装gluster软件：​ yum -y install glusterfs glusterfs-server glusterfs-fuse glusterfs-cli glusterfs-geo-replication4、 查看版本信息：​ glusterfs -VCentOS 7 升级内核到4.4.6 LTSrpm –import https://www.elrepo.org/RPM-GPG-KEY-elrepo.orgrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpmyum –enablerepo=elrepo-kernel install kernel-lt-devel kernel-lt -yawk -F\\’ ‘$1==”menuentry “ {print $2}’ /etc/grub2.cfggrub2-set-default xxxx rebootuname -r","categories":[{"name":"zfs","slug":"zfs","permalink":"http://www.python100.com/categories/zfs/"}],"tags":[{"name":"zfs","slug":"zfs","permalink":"http://www.python100.com/tags/zfs/"}]},{"title":"mongo常用操作","slug":"mongo常用命令","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:18:23.348Z","comments":true,"path":"2018/07/24/mongo常用命令/","link":"","permalink":"http://www.python100.com/2018/07/24/mongo常用命令/","excerpt":"","text":"mongo常用操作参考文档：https://www.jb51.net/article/48217.htmhelphelp db.help(); db.yourColl.help(); db.youColl.find().help(); rs.help(); 数据库的操作# 查看数据库 show dbs # 切换数据库 use mydatabase # 删除当前数据库 db.dropDatabase() #进入需要删除的数据库下执行此命令 #克隆数据库 db.cloneDatabase(“127.0.0.1”); 将指定机器上的数据库的数据克隆到当前数据库 db.copyDatabase(&quot;mydb&quot;, &quot;temp&quot;, &quot;127.0.0.1&quot;);将本机的mydb的数据复制到temp数据库中 db.repairDatabase(); 修复当前数据库 #获取当前数据库的状态 db.getName(); db; db和getName方法是一样的效果，都可以查询当前使用的数据库 db.stats(); 显示当前db状态 db.version(); 当前db版本 db.getMongo(); 查看当前db的链接机器地址 集合操作 Collection聚集集合# 查看集合 show collections # 删除集合 db.users.drop() #创建一个聚集集合（table） db.createCollection(“collName”, {size: 20, capped: 5, max: 100});//创建成功会显示{“ok”:1} //判断集合是否为定容量db.collName.isCapped(); # 得到指定名称的聚集集合（table） db.getCollection(&quot;account&quot;); # 得到当前db的所有聚集集合 db.getCollectionNames(); #显示当前db所有聚集索引的状态 db.printCollectionStats(); 文档操作插入文档 db.users.insert({ name:&apos;harttle&apos;, url:&apos;http://harttle.com&apos; }) 查询文档 # 查询所有 db.users.find() # 条件查询 db.users.find({ name:&apos;harttle&apos; }) # 有缩进的输出 db.users.find().pretty() 更新文档 db.users.update({ name:&apos;harttle&apos; }, { url:&apos;http://harttle.com&apos; }) 删除文档 # 删除所有 db.users.remove({}) # 条件删除 db.users.remove({ url:&apos;http://harttle.com&apos; }) ##用户操作### 添加一个用户 db.addUser(&quot;name&quot;); db.addUser(&quot;userName&quot;, &quot;pwd123&quot;, true); 添加用户、设置密码、是否只读 # 数据库认证、安全模式 db.auth(&quot;userName&quot;, &quot;123123&quot;); # 显示当前所有用户 show users; # 删除用户 db.removeUser(&quot;userName&quot;); ##查询操作### 去掉查询结果显示id #查询所有记录 db.userInfo.find(); # 相当于：select* from userInfo; # 查询去掉后的当前聚集集合中的某列的重复数据 db.userInfo.distinct(&quot;name&quot;); 会过滤掉name中的相同数据 # 查询age = 22的记录 db.userInfo.find({&quot;age&quot;: 22}); # 查询age &gt; 22的记录 db.userInfo.find({age: {$gt: 22}}); # 查询age &lt; 22的记录 db.userInfo.find({age: {$lt: 22}}); # 查询age &gt;= 25的记录 db.userInfo.find({age: {$gte: 25}}); # 查询age &lt;= 25的记录 db.userInfo.find({age: {$lte: 25}}); # 查询age &gt;= 23 并且 age &lt;= 26 db.userInfo.find({age: {$gte: 23, $lte: 26}}); # 查询name中包含 mongo的数据 db.userInfo.find({name: /mongo/}); # 查询name中以mongo开头的 db.userInfo.find({name: /^mongo/}); # 查询指定列name、age数据 db.userInfo.find({}, {name: 1, age: 1}); # 查询指定列name、age数据, age &gt; 25 db.userInfo.find({age: {$gt: 25}}, {name: 1, age: 1}); # 按照年龄排序 升序：db.userInfo.find().sort({age: 1}); 降序：db.userInfo.find().sort({age: -1}); # 查询name = zhangsan, age = 22的数据 db.userInfo.find({name: &apos;zhangsan&apos;, age: 22}); # 查询前5条数据 db.userInfo.find().limit(5); # 查询10条以后的数据 db.userInfo.find().skip(10); # 查询在5-10之间的数据 db.userInfo.find().limit(10).skip(5); 可用于分页，limit是pageSize，skip是第几页*pageSize # or与 查询 db.userInfo.find({$or: [{age: 22}, {age: 25}]}); # 查询第一条数据 db.userInfo.findOne(); # 查询某个结果集的记录条数 db.userInfo.find({age: {$gte: 25}}).count(); # 按照某列进行排序 db.userInfo.find({sex: {$exists: true}}).count(); ##索引### 创建索引 db.userInfo.ensureIndex({name: 1}); db.userInfo.ensureIndex({name: 1, ts: -1}); # 查询当前聚集集合所有索引 db.userInfo.getIndexes(); # 查看总索引记录大小 db.userInfo.totalIndexSize(); # 读取当前集合的所有index信息 db.users.reIndex(); # 删除指定索引 db.users.dropIndex(&quot;name_1&quot;); # 删除所有索引索引 db.users.dropIndexes(); ##修改、添加、删除集合数据### 添加 db.users.save({name: ‘zhangsan&apos;, age: 25, sex: true}); # 修改 db.users.update({age: 25}, {$set: {name: &apos;changeName&apos;}}, false, true); 相当于：update users set name = ‘changeName&apos; where age = 25; db.users.update({name: &apos;Lisi&apos;}, {$inc: {age: 50}}, false, true); 相当于：update users set age = age + 50 where name = ‘Lisi&apos;; db.users.update({name: &apos;Lisi&apos;}, {$inc: {age: 50}, $set: {name: &apos;hoho&apos;}}, false, true); 相当于：update users set age = age + 50, name = ‘hoho&apos; where name = ‘Lisi&apos;; # 删除 db.users.remove({age: 132}); # 查询修改删除 db.users.findAndModify({ query: {age: {$gte: 25}}, #query 查询过滤条件 {} sort: {age: -1}, #如果多个文档符合查询过滤条件，将以该参数指定的排列方式选择出排在首位的对象 update: {$set: {name: &apos;a2&apos;}, $inc: {age: 2}}, remove: true #若为true，被选中对象将在返回前被删除 }); db.runCommand({ findandmodify : &quot;users&quot;, query: {age: {$gte: 25}}, sort: {age: -1}, update: {$set: {name: &apos;a2&apos;}, $inc: {age: 2}}, remove: true }); #update 或 remove 其中一个是必须的参数; 其他参数可选。 ##语句块操作### 简单Hello World print(&quot;Hello World!&quot;); # 将一个对象转换成json tojson(new Object()); tojson(new Object(&apos;a&apos;)); # 循环添加数据 &gt; for (var i = 0; i &lt; 30; i++) { ... db.users.save({name: &quot;u_&quot; + i, age: 22 + i, sex: i % 2}); ... }; &gt; for (var i = 0; i &lt; 30; i++) db.users.save({name: &quot;u_&quot; + i, age: 22 + i, sex: i % 2}); # find 游标查询 &gt;var cursor = db.users.find(); &gt; while (cursor.hasNext()) { printjson(cursor.next()); } # forEach迭代循环 db.users.find().forEach(printjson); # forEach中必须传递一个函数来处理每条迭代的数据信息 db.things.find({x:4}).forEach(function(x) {print(tojson(x));}); # forEach传递函数显示信息 # 将find游标当数组处理 var cursor = db.users.find(); cursor[4]; # 取得下标索引为4的那条数据 # 既然可以当做数组处理，那么就可以获得它的长度：cursor.length();或者cursor.count(); # 那样我们也可以用循环显示数据 for (var i = 0, len = c.length(); i &lt; len; i++) printjson(c[i]); # 将find游标转换成数组 &gt; var arr = db.users.find().toArray(); # 用toArray方法将其转换为数组 &gt; printjson(arr[2]); # 定制我们自己的查询结果，只显示age &lt;= 28的并且只显示age这列数据 db.users.find({age: {$lte: 28}}, {age: 1}).forEach(printjson); db.users.find({age: {$lte: 28}}, {age: true}).forEach(printjson); db.users.find({age: {$lte: 28}}, {age: false}).forEach(printjson); #排除age序列 ##其他 ### 查询之前的错误信息 db.getPrevError(); # 清除错误记录 db.resetError(); 查看聚集集合基本信息 1、查看帮助 db.yourColl.help(); 2、查询当前集合的数据条数 db.yourColl.count(); 3、查看数据空间大小 db.userInfo.dataSize(); 4、得到当前聚集集合所在的db db.userInfo.getDB(); 5、得到当前聚集的状态 db.userInfo.stats(); 6、得到聚集集合总大小 db.userInfo.totalSize(); 7、聚集集合储存空间大小 db.userInfo.storageSize(); 8、Shard版本信息 db.userInfo.getShardVersion() 9、聚集集合重命名 db.userInfo.renameCollection(&quot;users&quot;); 将userInfo重命名为users 10、删除当前聚集集合 db.userInfo.drop(); show dbs:显示数据库列表 show collections：显示当前数据库中的集合（类似关系数据库中的表） show users：显示用户 use &lt;db name&gt;：切换当前数据库，这和MS-SQL里面的意思一样 db.help()：显示数据库操作命令，里面有很多的命令 db.foo.help()：显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令 db.foo.find()：对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据） db.foo.find( { a : 1 } )：对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1","categories":[{"name":"mongo","slug":"mongo","permalink":"http://www.python100.com/categories/mongo/"}],"tags":[]},{"title":"mongodump与mongorestore","slug":"mongo数据库备份与恢复","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:18:06.163Z","comments":true,"path":"2018/07/24/mongo数据库备份与恢复/","link":"","permalink":"http://www.python100.com/2018/07/24/mongo数据库备份与恢复/","excerpt":"","text":"MongoDB 备份(mongodump)与恢复(mongorestore)mongoexport/mongoimport导入/导出的是JSON格式，而mongodump/mongorestore导入/导出的是BSON格式。JSON可读性强但体积较大，BSON则是二进制文件，体积小但对人类几乎没有可读性。在一些mongodb版本之间，BSON格式可能会随版本不同而有所不同，所以不同版本之间用mongodump/mongorestore可能不会成功，具体要看版本之间的兼容性。当无法使用BSON进行跨版本的数据迁移的时候，使用JSON格式即mongoexport/mongoimport是一个可选项。跨版本的mongodump/mongorestore个人并不推荐，实在要做请先检查文档看两个版本是否兼容（大部分时候是的）。JSON虽然具有较好的跨版本通用性，但其只保留了数据部分，不保留索引，账户等其他基础信息。使用时应该注意。mongodump命令脚本语法如下：&gt;mongodump -h dbhost -d dbname -o dbdirectory -h： MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d： 需要备份的数据库实例，例如：test -o： 备份的数据存放位置，例如：c:\\data\\dump，当然该目录需要提前建立，在备份完成后， 系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 mongodump –host HOST_NAME –port PORT_NUMBER 该命令将备份所有MongoDB数据mongodump –host runoob.com –port 27017[root@www1 mongodb]# mongodump -h localhost -u u1 -p 123qwe -d data -o data_mongo.tarmongodump –dbpath DB_PATH –out BACKUP_DIRECTORYmongodump –dbpath /data/db/ –out /data/backup/mongodump –collection COLLECTION –db DB_NAME 该命令将备份指定数据库的集合。mongodump –collection mycol –db testmongorestoremogorestore命令脚本语法如下：&gt;mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt; --host &lt;:port&gt;, -h &lt;:port&gt;： MongoDB所在服务器地址，默认为： localhost:27017 --db , -d ： 需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2 --drop： 恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！ path： mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\\data\\dump\\test。 你不能同时指定 &lt;path&gt; 和 --dir 选项，--dir也可以设置备份目录。 --dir： 指定备份的目录 你不能同时指定 &lt;path&gt; 和 --dir 选项。 mongoexport参数 -h:指明数据库宿主机的IP -u:指明数据库的用户名 -p:指明数据库的密码 -d:指明数据库的名字 -c:指明collection的名字 -f:指明要导出那些列 -o:指明到要导出的文件名 -q:指明导出数据的过滤条件 root@mongo:~/cas.mongo# mongorestore -h mongo:27017 -uadmin -pPassw0rd -d admin admin root@mongo:~/cas.mongo# mongorestore -h mongo:27017 -ucas -pPassw0rd -d cas cas [root@localhost mongodb]# ./bin/mongoexport -d test -c students -o students.dat -d:指明使用的库，本例中为test -c:指明要导出的集合，本例中为students -o:指明要导出的文件名，本例中为students.dat ./bin/mongoexport -d test -c students --csv -f classid,name,age -o students_csv.dat -csv：指明要导出为csv格式 -f：指明需要导出classid、name、age这3列的数据 mongoimport参数 -h:指明数据库宿主机的IP -u:指明数据库的用户名 -p:指明数据库的密码 -d:指明数据库的名字 -c:指明collection的名字 -f:指明要导入那些列 ./bin/mongoimport -d test -c students students.dat 参数说明： -d:指明数据库名，本例中为test -c:指明collection名，本例中为students students.dat：导入的文件名 ./bin/mongoimport -d test -c students --type csv --headerline --file students_csv.dat -type:指明要导入的文件格式 -headerline:指明第一行是列名，不需要导入 -file：指明要导入的文件 –备份单个表mongodump -u superuser -p 123456 --port 27017 --authenticationDatabase admin -d myTest -c d -o /backup/mongodb/myTest_d_bak_201507021701.bak –备份单个库mongodump -u superuser -p 123456 --port 27017 --authenticationDatabase admin -d myTest -o /backup/mongodb/ –备份所有库mongodump -u superuser -p 123456 --authenticationDatabase admin --port 27017 -o /root/bak –备份所有库推荐使用添加–oplog参数的命令，这样的备份是基于某一时间点的快照，只能用于备份全部库时才可用，单库和单表不适用：mongodump -h 127.0.0.1 --port 27017 --oplog -o /root/bak –同时，恢复时也要加上–oplogReplay参数，具体命令如下(下面是恢复单库的命令)：mongorestore -d swrd --oplogReplay /home/mongo/swrdbak/swrd/ –恢复单个库：mongorestore -u superuser -p 123456 --port 27017 --authenticationDatabase admin -d myTest /backup/mongodb/ –恢复所有库：mongorestore -u superuser -p 123456 --port 27017 --authenticationDatabase admin /root/bak –恢复单表mongorestore -u superuser -p 123456 --authenticationDatabase admin -d myTest -c d /backup/mongodb/myTest_d_bak_201507021701.bak/myTest/d.bson","categories":[{"name":"mogno","slug":"mogno","permalink":"http://www.python100.com/categories/mogno/"}],"tags":[]},{"title":"根据PID查看进程启动路径","slug":"shell命令","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:17:01.035Z","comments":true,"path":"2018/07/24/shell命令/","link":"","permalink":"http://www.python100.com/2018/07/24/shell命令/","excerpt":"","text":"12345根据PID查看进程启动路径cqxyw1 ~ # ps eho command -p 30143/// MvGJ6F80QE USER=www-data PWD=/tmp HOME=/var/www SHLVL=3 _=/usr/bin/nohup OLDPWD=/srv/drupal根据pid查看网络状况netstat -pan | grep 23371/// MvGJ6F80QE USER=www-data PWD=/tmp HOME=/var/www SHLVL=3 _=/usr/bin/nohup OLDPWD=/srv/drupal","categories":[],"tags":[]},{"title":"virsh相关命令","slug":"关于virsh相关命令","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:16:15.780Z","comments":true,"path":"2018/07/24/关于virsh相关命令/","link":"","permalink":"http://www.python100.com/2018/07/24/关于virsh相关命令/","excerpt":"","text":"关于virsh相关命令常用文件路径1234567891011虚拟机配置文件默认路径：[root@bainuo qemu]# pwd/etc/libvirt/qemu[root@bainuo qemu]# lsnetworks vm01.xml磁盘文件默认路径：[root@bainuo images]# pwd/var/lib/libvirt/images[root@bainuo images]# lsvm01.img虚机1234567891011121314151617181920212223242526272829303132333435363738394041424344virsh命令参数 功能 用法举例list 查看已经存在的domain信息(可以带参数) virsh list --all (查看所有的虚拟机)start 开始一个不活跃的domain(前提是存在) virsh start test2autostart 配置domain随boot启动 virsh autostart test2shutdown 优雅的关闭domain virsh shutdown test2destroy 立刻终止一个domain(强制关闭) virsh destroy test2reboot 重启一个domain(仅仅发送reboot命令) virsh reboot test2suspend 挂起服务器 virsh suspend test2resume 恢复服务器 virsh resume test2console 连接domain的虚拟的控制台(只能有1个) virsh console test2ttyconsole 输出设备使用的domain的tty console virsh ttyconsole test2dominfo 返回关于domain的基本信息 virsh dominfo test2migrate 迁移一个domain到另一台主机 KVM虚拟网络管理命令(virtual network)：virsh命令参数 功能 用法举例net-autostart 配置一个虚拟网络开机自启(--disable可以关闭) virsh net-autostart br0net-create 通过一个xml文件创建一个虚拟网络 virsh net-create ./virbr1.xmlnet-define 通过xml文件定义一个虚拟网络，仅定义不实例化 virsh net-define ./virbr1.xmlnet-destory 停止由其名称(uuid)指定的虚拟网络，立即生效 virsh net-destroy br0net-dumpxml 以xml文件的形式输出一个虚拟网络的配置信息 virsh net-dumpxml br0net-edit 编辑一个虚拟网络的配置文件(修改虚拟网络配置) virsh net-edit br0net-info 返回要查看的虚拟网络的基本信息 virsh net-info defaultnet-list 查看当前的虚拟网络信息(可以带参数) virsh net-list --allnet-name net-start 开始一个不活跃的虚拟网络 virsh net-start br0net-undefine 将一个不活跃的虚拟网络取消定义 virsh net-undefine br0net-uuid net-update 创建并启用一个网络：net-define -&gt; net-startvirsh net-define br0.xmlvirsh net-list --all (有br0网络,但处于不活跃状态)virsh net-start br0virsh net-list --all (br0网络已处于活跃状态) 停用并删除一个网络(以br0为例)： net-destroy -&gt; net-undefinevirsh net-destroy br0virsh net-list --all (br0网络变为不活跃状态)virsh net-undefine br0virsh net-list --all (br0网络已被删除)存储池12345678910111213创建基于文件夹的存储池1) 定义一个存储池virsh pool-define-as kvm_images dir - - - - “/kvm/images”2) 查看创建的存储池信息virsh pool-list –all3) 建立基于文件夹的存储池virsh pool-build kvm_images4) 使存储池生效virsh pool-start kvm_images5) 这时候，存储池还不是自动运行，使用virsh pool-autostartvirsh pool-autostart kvm_images6) 验证存储池virsh pool-info kvm_images123456789101112131415161718192021222324 virsh回车进入交互式界面：versionpwdhostname 显示本节点主机名nodeinfo 显示节点信息list --all 显示所有云主机7种状态： running 运行中 idel 空闲，未运行 paused 暂停状态 shutdown 关闭 crashed 虚拟机崩溃 dying 垂死状态，但是又没有完全关闭或崩溃 shutdown &lt;domain&gt; destroy &lt;domain&gt; 强制关闭虚拟机（相当于直接拨电源） start &lt;domain&gt; 启动虚拟机 edit &lt;domain&gt; 编辑该虚拟机的xml文件 dommemstat &lt;domain&gt; 获取domain的内存状态 suspend &lt;domain&gt; 挂起一个正在运行的虚拟机，该虚拟机仍占资源； resume &lt;domain&gt; 从挂起状态恢复一下虚拟机 vcpuinfo &lt;domain&gt; 显示一些虚拟机的vcpu的信息 vncdisplay &lt;domain&gt; 显示vnc监听地址和端口快照相关命令12345snapshot-create &lt;domain&gt; xmlfile 给domain创建一个snapshot，详细内容保存在xmlfile中snapshot-current &lt;domain&gt; 显示一个domain的当前的snapshotsnapshot-list &lt;domain&gt; 显示一个domain的所有的snapshotsnapshot-revert &lt;domain&gt; snapshot 恢复一个domian到以前的snapshotsnapshot-delete &lt;domain&gt; snapshot --children 删除一个domain的snapshot如何用libvirt远程管理虚拟机？12345678910111213141516171819要用libvirt连接到超级管理程序，我们需要一个URI，这个URI配合virsh和virt-viewer命令使用，后面可以跟一些可选项，virt-viewer可以调用一些链接参数，例如：virsh -c qemu:///system 当链接到远程机器时，可以定义几种使用的协议：ssh，tcp，tls。当链接到远程机器时，需要使用远程主机的用户和主机名进行链接，如果没有定义链接用户，则会使用本机环境的$USER的用户进行链接，当连接到qemu hypervisor时，接受两种链接类型：system可以有所有的访问权限，session有限制的访问。例如：使用full access链接至本机的qemu hypervisor，前面的-c 是为了执行后面的list命令(--connect)virsh -c qemu:///system list使用full access链接至远程主机的qemu hypervisor，每次都要输入ssh密码，改成ssh无密码登陆就不需要输入密码了，直接显示结果。 virsh -c qemu+ssh://tux@mercur/system 直接进入交互virsh模式 virsh -c qemu+ssh://10.1.1.8/system list 直接显示list后的结果 其余连接格式如下： qemu:///session (local access to per-user instance) qemu+unix:///session (local access to per-user instance) qemu:///system (local access to system instance) qemu+unix:///system (local access to system instance) qemu://example.com/system (remote access, TLS/x509) qemu+tcp://example.com/system (remote access, SASl/Kerberos) qemu+ssh:///system (remote access, SSH tunnelled)使用libvirt创建kvm虚拟机：12345671、制作虚拟机镜像qemu-img create -f qcow2 test.qcow2 10G //格式，名字，大小2、下载并复制iso镜像到指定目录（在第3步中创建xml文件中指定）3、创建安装配置文件，demo.xml如下，可以根据自己需求更改virsh define demo.xml //创建虚拟机virsh start test_ubuntu //启动虚拟机virsh vncdisplay test_ubuntu ////查看虚拟机的vnc端口， 然后就可以通过vnc登录来完成虚拟机的安装demo.xml 内容如下 默认路径在/etc/libvirt/qemu123456789101112131415161718192021222324252627282930313233343536373839&lt;domain type='kvm'&gt; &lt;name&gt;test_ubuntu&lt;/name&gt; //虚拟机名称 &lt;memory&gt;1048576&lt;/memory&gt; //最大内存，单位k &lt;currentMemory&gt;1048576&lt;/currentMemory&gt; //可用内存，单位k &lt;vcpu&gt;8&lt;/vcpu&gt; //虚拟cpu个数 &lt;os&gt; &lt;type arch='x86_64' machine='pc'&gt;hvm&lt;/type&gt; &lt;boot dev='cdrom'/&gt; //光盘启动 &lt;/os&gt; &lt;features&gt; &lt;acpi/&gt; &lt;apic/&gt; &lt;pae/&gt; &lt;/features&gt; &lt;clock offset='localtime'/&gt; &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt; &lt;on_reboot&gt;restart&lt;/on_reboot&gt; &lt;on_crash&gt;destroy&lt;/on_crash&gt; &lt;devices&gt; &lt;emulator&gt;/usr/libexec/qemu-kvm&lt;/emulator&gt; &lt;disk type='file' device='disk'&gt; &lt;driver name='qemu' type='qcow2'/&gt; &lt;source file='/var/lib/libvirt/images/test.qcow2'/&gt; //目的镜像路径 &lt;target dev='hda' bus='ide'/&gt; &lt;/disk&gt; &lt;disk type='file' device='cdrom'&gt; &lt;source file='/var/lib/libvirt/images/ubuntu.iso'/&gt; //光盘镜像路径 &lt;target dev='hdb' bus='ide'/&gt; &lt;/disk&gt; &lt;interface type='bridge'&gt; //虚拟机网络连接方式 &lt;source bridge='kvmbr0'/&gt; //当前主机网桥的名称 &lt;mac address=\"00:16:3e:5d:aa:a8\"/&gt; //为虚拟机分配mac地址，务必唯一，否则dhcp获得同样ip,引起冲突 &lt;/interface&gt; &lt;input type='mouse' bus='ps2'/&gt; &lt;graphics type='vnc' port='-1' autoport='yes' listen = '0.0.0.0' keymap='en-us'/&gt; //vnc方式登录，端口号自动分配，自动加1，可以通过virsh vncdisplay来查询 &lt;/devices&gt; &lt;/domain&gt;使用virsh-install安装虚机命令1virt-install \\ --name=guest1-rhel5-64 \\ --file=/var/lib/libvirt/images/guest1-rhel5-64.dsk \\ --file-size=8 \\ --nonsparse --graphics spice \\ --vcpus=2 --ram=2048 \\ --location=http://example1.com/installation_tree/RHEL5.6-Serverx86_64/os \\ --network bridge=br0 \\ --os-type=linux \\ --os-variant=rhel5.4使用 qemu-img 和 qemu-kvm 命令行方式安装1234567891011（1）创建一个空的qcow2格式的镜像文件 qemu-img create -f qcow2 windows-master.qcow2 10G（2）启动一个虚机，将系统安装盘挂到 cdrom，安装操作系统 qemu-kvm -hda windows-master.qcow2 -m 512 -boot d -cdrom /home/user/isos/en_winxp_pro_with_sp2.iso（3）现在你就拥有了一个带操作系统的镜像文件。你可以以它为模板创建新的镜像文件。使用模板的好处是，它会被设置为只读所以可以免于破坏。 qemu-img create -b windows-master.qcow2 -f qcow2 windows-clone.qcow2（4）你可以在新的镜像文件上启动虚机了 qemu-kvm -hda windows-clone.qcow2 -m 400","categories":[{"name":"kvm","slug":"kvm","permalink":"http://www.python100.com/categories/kvm/"}],"tags":[]},{"title":"mongodb的优缺点","slug":"mongodb的优缺点","date":"2018-07-24T10:06:00.000Z","updated":"2018-07-24T10:18:40.104Z","comments":true,"path":"2018/07/24/mongodb的优缺点/","link":"","permalink":"http://www.python100.com/2018/07/24/mongodb的优缺点/","excerpt":"","text":"mongodb的优缺点对比mysql, mongo的优缺点有：缺点不支持事务操作占用空间过大MongoDB没有如MySQL那样成熟的维护工具无法进行关联表查询，不适用于关系多的数据复杂聚合操作通过mapreduce创建，速度慢模式自由， 自由灵活的文件存储格式带来的数据错误预分配模式带来的磁盘瓶颈。mongodb采用数据文件预分配模式来生成数据文件，数据文件的大小从64M开始，每增加一个文件，大小翻倍，直到2G，以后每次增加数据就会生成2G左右的数据文件，结合mongodb的mmap内存模型，对于写数据文件，将随机写转换为顺序写，一定程度上缓解了磁盘的io压力。但在实际使用中，遇到了在预分配2G的数据文件时，如果磁盘io较慢，则mongodb基本锁死，无法响应请求的情况。持续时间则根据磁盘io的性能来确定。这个问题在2.0之后版本可能会有些改善，但在磁盘性能低的服务器上，该问题依旧存在.这个问题目前没有太好的解决方案，只能建议使用读写性能比较好的服务器来跑mongodb。在数据存量大于内存大小时，mongodb遇到冷数据查询速度变慢。mongodb使用mmap的内存管理模式，如果查询的都是热数据，那么会在内存中直接查询，如果遇到冷数据，就需要从磁盘读取，并将一部分热数据从内存卸载掉.有人曾经说mongodb内存管理是加载固定大小的文件块到内存，即如果冷数据在磁盘上，他会根据请求的数据，加载一定大小的数据块到内存，并卸载掉同样的热数据，这个操作本身会带来一定io.因为mongodb使用的是全局锁，在某个操作缓慢时，整个操作队列会全部变慢。这个问题造成了mongodb会出现偶发性堵塞问题，连带整个库的性能下降。该问题在应用需要尽量避免出现，需要将mongodb的数据大小规划好，尽量不要使数据量超过内存的大小，如果超过内存大小后，尽量不要去请求冷数据。Mongodb全局锁机制。mongodb最大的问题或者可以说是它的锁机制，在2.2版本之前，一个实例只有一个读写锁，不管有多少数据库和数据集合，当一个操作进行时其他操作只能等待，在2.2版本后，mongodb锁降低了粒度，改为按库锁。MongoDB 使用的是“readers-writer”锁， 可以支持并发但有很大的局限性，当一个读锁存在,许多读操作可以使用这把锁，然而, 当一个写锁的存在，一个单一的写操作会exclusively 持有该锁，同时其它读，写操作不能使用共享这个锁；举个例子，假设一个集合里有 10 个文档，多个 update 操作不能并发在这个集合上，即使是更新不同的文档。删除数据集合后空间不会自动释放mongodb删除集合后磁盘空间不释放，只有用db.repairDatabase()去修复才能释放。修复可能要花费很长的时间,在使用db.repairDatabase()去修复时一定要停掉读写，并且mongodb要有备机才可以，不然千万不要随便使用db.repairDatabase()来修复数据库，切记。但是在修复的过程中如果出现了非正常的mongodb的挂掉，再次启动时启动不了的，需要先修复才可以，可以利用./mongod –repair –dbpath=/data/mongo/如果你是把数据库单独的放在一个文件夹中指定dbpath时就指向要修复的数据库就可以。###replica set一些隐含问题 ###replica set模式最多支持12台服务器，而有投票权的服务器只支持7台，如果超过7台服务器，需设置部分服务器为无投票权服务器replica set模式中，一个set服务器如果小于2台服务器，则自动故障恢复不会起作用，如果4台服务器出现2/2互相ping不通的情况，同样不会自动故障恢复。一般来说，一个set中尽量是有单数服务器。replica set中，因为mongodb是按照时间进行操作，如果set中某个服务器时间超前或者延迟，很容易出现secondaries不断尝试更新oplog或者同步延迟的问题。甚至造成某些操作失败，如drop操作。###分片模式的一些隐含问题 ###config server尽量按照官方的要求，有3个configserver，如果只有2个configserver，则shard的自动负载均衡和自动切片功能不可用。api中的nearest模式在shard中，判断的是set到mongos的距离而非set到client的距离，在切片模式下，尽量不要使用nearest模式，可能会造成一些请求延迟增加的问题。优点文档结构的存储方式，能够更便捷的获取数据内置GridFS，支持大容量的存储内置Sharding，分片简单海量数据下，性能优越支持自动故障恢复（复制集）mongodb是一个介于nosql数据库和mysql数据库之间的一个数据存储系统，它没有严格的数据格式，但同时支持复杂查询，而且自带sharding模式和Replica Set模式，支持分片模式，复制模式，自动故障处理，自动故障转移，自动扩容，全内容索引，动态查询等功能。扩展性和功能都比较强大。mongodb在数据查询方面，支持类sql查询，可以一个key多value内容，可以组合多个value内容来查询，支持索引，支持联合索引，支持复杂查询 ，支持排序，基本上除了join和事务类型的操作外，mongodb支持所有mysql支持的查询，甚至某个客户端api支持直接使用sql语句查询mongodb。mongodb的sharding功能目前日渐完善，支持自定义范围分片，hash自动分片等，分片自动扩容，shard之间自动负载均衡等功能。实际使用中功能还不错。","categories":[],"tags":[]},{"title":"cloudstack-概念","slug":"cloudstack-概念","date":"2018-07-24T05:11:00.000Z","updated":"2018-07-24T05:13:04.474Z","comments":true,"path":"2018/07/24/cloudstack-概念/","link":"","permalink":"http://www.python100.com/2018/07/24/cloudstack-概念/","excerpt":"","text":"CloudStack是一个开源的具有高可用性及扩展性的云计算平台 ，现在又Apache基金会在管理。云计算的三种服务模式123SAAS：软件即服务PAAS：平台即服务IAAS：基础架构即服务区域(Zone)：1区域可以理解为一个数据中心或机房，是逻辑范围最大的组成单元。由一组POD、二级存储、及网络架构组成。区域只能选择一中网络架构。区域间是相互独立的，如需要通信，只能在网络配置打通区域的公有网络。区域之间只能复制ISO和模板，虚拟机不能进行区域之间的迁移工作，如需要，可将虚机转换成模板，再复制到另一个区域。创建时，可以选择该区域是公共区域，还是只对某组用户的私有区域。提供点（POD）1可理解为一个物理机架，包括交换机、服务器和存储。所以提供点内的计算服务器，系统虚机都在同一个子网中集群（cluster）1最小的逻辑组织单元，由一组计算服务器及一个或多个主存储组成， 同一个集群内的服务器必须使用相同的虚拟化管理程序，硬件型号也必须相同。集群内的虚拟机可以在集群内的不同主机之间实现动态迁移。集群内可以添加多个作为共享存储所使用的主存储计算节点（HOST) 就是运行虚拟机（VM）的主机主存储 (一级存储)12一般作为每个集群多台计算服务器共同使用的共享存储存在。一个集群中可以有一个或多个不同类型的存储。主存储用于存储所有虚拟机内数据的镜像文件和数据卷文件。分为共享存储和本地存储。使用共享存储可以实现虚机的在线迁移。一级存储与 cluster 关联，它为该 cluster 中的主机的全部虚拟机提供磁盘卷。一个 cluster 至少有一个一级存储，且在部署时位置要临近主机以提供高性能。二级存储12每个区域只需要一个二级存储，用于存放创建虚拟所使用的ISO镜像文件、模板文件，以及对虚机所做的快照和卷备份文件。这些都是占用空间大、读写频率低的数据文件(冷数据),并不是关键数据，使用配置不高、最简单的NFS来存储就够了。二级存储与 zone 关联，它存储模板文件，ISO 镜像和磁盘卷快照。一个 zone 包含多个 pod，一个 pod 包含多个 cluster，一个 cluster 包含多个 host123模板：可以启动虚拟机的操作系统镜像，也包括了诸如已安装应用的其余配置信息。ISO 镜像：包含操作系统数据或启动媒质的磁盘镜像。磁盘卷快照：虚拟机数据的已储存副本，能用于数据恢复或者创建新模板。123一个完整的 CloudStack 环境包括两部分： 管理服务器（Management Server） 虚拟机管理器 (Hypervisor) 也叫主机host或者代理agent虚拟机实例的动态迁移12静态迁移：在虚拟机关机或暂停的情况下从一台物理机迁移到另一台物理机动态迁移：让虚拟机在不关机且能持续提供服务的前提下，从一个虚拟平台的主机（Host）迁移到其他虚拟平台的主机上运行，中间仅有非常短暂的停机时间，普通用户无法对自己的虚拟机进行动态迁移，只有管理员可以。虚拟机实例的动态迁移只能在同一集群中进安全组1安全组相当于在虚拟机实例的操作系统之外部署了一道防火墙，每个CloudStack账户都会生成一个默认安全组，该组默认拒绝所有流入流量和允许所有流出流量。一个用户可以创建多个安全组，一个安全组可以应用到多个虚拟机实例上，一个虚拟机实例也可以使用多个安全组。一个安全组相当于一条或多条防火墙规则。虚拟机实例在创建时可以选择多个安全组，选择后不可以加入或退出其他安全组高级网络功能12345678910111213141516171819202122232425虚拟路由器本质上一个运行Debian 7.0的虚拟机实例，提供了各种高级网络管理功能。1、防火墙（不能基于账户进行策略指定，也不能设定出口规则） 不能基于账户进行策略指定，也不能设定出口规则 默认可以访问外部服务，但外部服务不能访问虚拟机实例2、负载均衡 负载均衡有工作在二层，三层，四层和七层的负载均衡 可以通过集群的方式来保证高可用 CloudStack的负载均衡是通过在虚拟路由器里使用HAProxy实现的 轮询算法：根据用户的请求依次将请求转发给内部的应用服务器 最少连接算法：把当前请求分配给连接数最少的应用服务器 源算法：尽量保证始终来自同一个客户端的请求分发给同一个应用服务器，适用于不使用Cookie的Web应用 要使用负载均衡，前端的负载均衡器需要为该服务配置一个服务IP地址，服务地址用于接收用户的请求。 公用端口用于接收用户外部的请求，专用端口指虚拟机提供服务的端口3、静态NAT：将内外的私有IP转换为公有IP（1对1）4、端口转发：把访问A服务器某端口的数据转发到B服务器的某端口中5、VPN VPN可以使用户安全，方便地访问一个虚拟网络内的所有虚拟机 默认情况下，防火墙信任VPN拨入者6、VPC：Virtual Private Cloud 从整体网络中分割出来的一个逻辑隔离的网络，在该虚拟网络中，用户具有完全的控制权7、冗余路由 使用多个路由来防止单点故障时导致内部网络不能与外部网络通信的问题 冗余路由组共用一个内网IP（网关）和一个外网IP 提供冗余功能的两天虚拟路由器应尽量运行在不同物理主机上","categories":[{"name":"cloudstack","slug":"cloudstack","permalink":"http://www.python100.com/categories/cloudstack/"}],"tags":[{"name":"cloudstack","slug":"cloudstack","permalink":"http://www.python100.com/tags/cloudstack/"}]},{"title":"cloudstack安装","slug":"cloudstack文档","date":"2018-07-24T05:11:00.000Z","updated":"2018-07-24T05:13:58.490Z","comments":true,"path":"2018/07/24/cloudstack文档/","link":"","permalink":"http://www.python100.com/2018/07/24/cloudstack文档/","excerpt":"","text":"cloudstack安装http://developer.huawei.com/ict/forum/thread-23211.htmlhttps://blog.csdn.net/chengxuyuanyonghu/article/details/78847656https://blog.csdn.net/hejin_some/article/details/72673192https://blog.csdn.net/hzhsan/article/details/44098537/ kvm网络virt-install –virt-type=kvm –name=centos88 –vcpus=2 –memory=4096 –location=/tmp/CentOS-7-x86_64-Minimal-1511.iso –disk path=/home/vms/centos88.qcow2,size=40,format=qcow2 –network bridge=br0 –graphics none –extra-args=’console=ttyS0’ –force1virt-install --connect qemu:///system --name centos7 --memory=1024 --vcpus=2 --disk path=/data/secondary/kali.qcow2,device=disk,format=qcow2,bus=virtio,cache=none,size=5 --cdrom /tmp/CentOS-7-x86_64-DVD-1804.iso --os-type=linux --network bridge=br0,model=virtio,model=e1000 --hvm --virt-type=kvm --noautoconsole --graphics vnc,listen=0.0.0.0,port=59011virt-install --virt-type=kvm --name=centos88 --vcpus=2 --memory=1024 --location=/tmp/CentOS-7-x86_64-DVD-1804.iso --disk path=/data/secondary/kali.qcow2,size=6,format=qcow2 --network bridge=br0 --graphics none --extra-args='console=ttyS0' --force","categories":[{"name":"cloudstack","slug":"cloudstack","permalink":"http://www.python100.com/categories/cloudstack/"}],"tags":[{"name":"cloudstack","slug":"cloudstack","permalink":"http://www.python100.com/tags/cloudstack/"}]},{"title":"VNC安装","slug":"VNC安装","date":"2018-07-24T05:11:00.000Z","updated":"2018-07-24T05:16:10.446Z","comments":true,"path":"2018/07/24/VNC安装/","link":"","permalink":"http://www.python100.com/2018/07/24/VNC安装/","excerpt":"","text":"VNC安装安装在Centos71、安装的centos已经安装了GUI桌面系统123456#安装桌面版，安装有500M以上，有点慢yum groupinstall \"GNOME Desktop\" \"Graphical Administration Tools\" #默认使用图形化桌面启动,三种命令ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target systemctl set-default runlevel5.target systemctl set-default graphical.target2、安装vncserver1yum -y install tigervnc-server3、启动并配置vncserver12[root@cloud ~]# vncserver [root@cloud ~]# vncpasswd4、修改配置文件12345678910111213141516171819202122[root@cloud ~]# cd /root/.vnc/[root@cloud .vnc]# cat config [Unit]Description=Remote desktop service (VNC)After=syslog.target network.target[Service]Type=forkingUser=root #设置远程连接用户为root# Clean any existing files in /tmp/.X11-unix environmentExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill 1 &gt; /dev/null 2&gt;&amp;1 || :'#这一句不要改变ExecStart=/usr/bin/vncserver :1 -geometry 1280x1024 -depth 16 -securitytypes=none -fp /usr/share/X11/fonts/miscPIDFile=/root/.vnc/%H%i.pidExecStop=/bin/sh -c '/usr/bin/vncserver -kill 1 &gt; /dev/null 2&gt;&amp;1 || :'[Install]WantedBy=multi-user.target5、修改完后启动 vncserver-1[root@cloud system]# systemctl start vncserver@\\:1.service6、然后使用vncviewer，输入IP:5901就可以连接到虚机了安装在win10下载server和viewer两个版本，都分别安装https://www.xp510.com/xiazai/Networking/mstsc/23862.htmlserver配置：","categories":[],"tags":[]},{"title":"cloudstack管理节点安装参考","slug":"cloudstack管理节点安装","date":"2018-07-24T05:11:00.000Z","updated":"2018-07-24T05:14:48.263Z","comments":true,"path":"2018/07/24/cloudstack管理节点安装/","link":"","permalink":"http://www.python100.com/2018/07/24/cloudstack管理节点安装/","excerpt":"","text":"参考文档：https://www.ibm.com/developerworks/cn/cloud/library/1303_chenyz_cloudstack/","categories":[{"name":"cloudstack","slug":"cloudstack","permalink":"http://www.python100.com/categories/cloudstack/"}],"tags":[{"name":"cloudstack","slug":"cloudstack","permalink":"http://www.python100.com/tags/cloudstack/"}]},{"title":"hexo博客next主题设计","slug":"hexo博客next主题设计","date":"2018-07-24T05:11:00.000Z","updated":"2018-07-24T06:06:18.181Z","comments":true,"path":"2018/07/24/hexo博客next主题设计/","link":"","permalink":"http://www.python100.com/2018/07/24/hexo博客next主题设计/","excerpt":"","text":"hexo博客next主题设计参考文章：http://theme-next.iissnan.com/getting-started.html一、新增访客统计及网站字数统计1234567891011121314151617181920212223242526272829303132331、安装依赖包，切换到博客根目录，打开Git Bash，输入以下代码安装字数统计包npm install hexo-wordcount --save2、打开文件：themes/next/layout/_partials/footer.swig,输入以下代码后保存退出。&lt;!-- 新增访客统计代码 --&gt;&lt;div class=\"copyright\" &gt; &#123;% set current = date(Date.now(), \"YYYY\") %&#125; &amp;copy; &#123;% if theme.since and theme.since != current %&#125; &#123;&#123; theme.since &#125;&#125; - &#123;% endif %&#125; &lt;span itemprop=\"copyrightYear\"&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class=\"with-love\"&gt; &lt;i class=\"fa fa-balance-scale\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=\"author\" itemprop=\"copyrightHolder\"&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=\"busuanzi-count\"&gt; &lt;script async=\"\" src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; &lt;span class=\"site-uv\"&gt; &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; 访问用户： &lt;span class=\"busuanzi-value\" id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt; 人 &lt;/span&gt; &lt;div class=\"powered-by\"&gt;&lt;/div&gt; &lt;span class=\"site-uv\"&gt; &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; 访问次数： &lt;span class=\"busuanzi-value\" id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt; 次 &lt;/span&gt; &lt;!-- 博客字数统计 --&gt; &lt;span class=\"site-pv\"&gt; &lt;i class=\"fa fa-pencil\"&gt;&lt;/i&gt; 博客全站共： &lt;span class=\"post-count\"&gt;&#123;&#123; totalcount(site) &#125;&#125;&lt;/span&gt; 字 &lt;/span&gt;&lt;/div&gt;&lt;!-- 新增访客统计代码 END--&gt;二、next主题如何添加动态背景注意：如果next主题在5.1.1以上的话就不用我这样设置，直接在主题配置文件中找到canvas_nest: false，把它改为canvas_nest: true就行了（注意分号后面要加一个空格）修改_layout.swig打开 next/layout/_layout.swig在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面)123&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125;修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面)123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\\（￣︶￣）/如果你感觉默认的线条太多的话可以这么设置====&gt;在上一步修改 _layout.swig中，把刚才的这些代码：123&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125;改为1234&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\"color=\"0,0,255\" opacity='0.7' zIndex=\"-2\" count=\"99\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125;color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B)opacity: 线条透明度（0~1）, 默认: 0.5count: 线条的总数量, 默认: 150zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1三、然hexo内的markdown文件显示文件将网站根目录下的source文件夹下新建images目录，将需要的文件根据自己的需要在新建文件夹来保存图片，引用图片的格式为/images/img/1.jpg四、添加评论可以使用的评论系统有HyperComments：https://www.hypercomments.com （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气，，）来必力：https://livere.com （来自韩国，使用邮箱注册。）畅言： http://changyan.kuaizhan.com （安装需要备案号。不太好用。）Gitment： https://github.com/imsun/gitment （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。）Valine: https://github.com/xCss/Valine (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？）综上，最终采用了来必力。打开来必力官网：https://livere.com按套路注册（有可能注册上面要花费点功夫）。（貌似需要科学上网？之前没科学上网好像登录界面显示不了）。安装点击上方的安装，选择免费的city版本。 获取UUID复制其中的uid字段。打开主题目录下的 blog/themes/next/_config.yml 配置文件，定位到 livere_uid 字段，粘贴上刚刚复制的UID。至此，大功告成。五、添加打赏功能六、添加本地搜索安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：$ npm install hexo-generator-searchdb –save编辑 站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000编辑 主题配置文件，启用本地搜索功能：123# Local searchlocal_search: enable: true","categories":[{"name":"hexo","slug":"hexo","permalink":"http://www.python100.com/categories/hexo/"}],"tags":[]},{"title":"进程线程","slug":"进程线程","date":"2018-07-03T14:19:00.000Z","updated":"2018-07-13T09:08:17.628Z","comments":true,"path":"2018/07/03/进程线程/","link":"","permalink":"http://www.python100.com/2018/07/03/进程线程/","excerpt":"","text":"进程、线程、多线程相关总结一、说说概念1、进程（process）狭义定义：进程就是一段程序的执行过程。广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。简单的来讲进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。进程状态：进程有三个状态，就绪、运行和阻塞。就绪状态其实就是获取了出cpu外的所有资源，只要处理器分配资源就可以马上执行。就绪状态有排队序列什么的，排队原则不再赘述。运行态就是获得了处理器分配的资源，程序开始执行。阻塞态，当程序条件不够时候，需要等待条件满足时候才能执行，如等待i/o操作时候，此刻的状态就叫阻塞态。2、程序说起进程，就不得不说下程序。先看定义：程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程则是在处理机上的一次执行过程，它是一个动态的概念。这个不难理解，其实进程是包含程序的，进程的执行离不开程序，进程中的文本区域就是代码区，也就是程序。3、线程通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。4、多线程在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也不可能只有一节车厢。多线程的出现就是为了提高效率。二、说说区别1、进程与线程的区别：进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.2) 线程的划分尺度小于进程，使得多线程程序的并发性高。3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。三、说说优缺点线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP(多核处理机)机器上运行，而进程则可以跨机器迁移。四、总结入职第一天闲的无聊，参考下别人的总结自己也简单总结了下。知道以上的基本面试够用了，至于进程、线程的细节，底层构成，调度等问题是操作系统的东西。我就不详述了。五、实例1、多线程写日志，涉及到单例模式，异步写","categories":[{"name":"进程线程","slug":"进程线程","permalink":"http://www.python100.com/categories/进程线程/"}],"tags":[]},{"title":"git和markdown使用总结","slug":"git和markdown使用总结","date":"2018-06-20T18:36:00.000Z","updated":"2018-07-24T04:42:20.913Z","comments":true,"path":"2018/06/21/git和markdown使用总结/","link":"","permalink":"http://www.python100.com/2018/06/21/git和markdown使用总结/","excerpt":"","text":"git 上传更新代码步骤- git pull #先拉取最新代码 - 将自己的写好的代码放入到相应的文件夹下，比如op/issues - 如果有图片将对应的图片也复制到当前目录下的img下 - git add 自己加入到的文件和图片 - git commit 自己加入和文件和图片 -m message - 这里如果不加-m message 选项可能会push不成功，最好加上 - git push #上传自己新加的文件到GitHub markdown语法总结- 图片方法一： - 加入图片，格式是 ![]() - 其中的[]中的内容可以自定义，比如[log] - ()中写使用该图片的文件相对图片的相对路径 方法二： &lt;img src=&quot;images/img/1.jpg&quot; width=256 height=256 /&gt; 图片引用方法一实例此时img文件夹和当前文档在同一级目录下 ![1](/images/img/1.jpg) ![2](/images/img/2.jpg) 图片引用方法二实例，可以控制图片大小&lt;img src=&quot;/images/img/1.jpg&quot; width=256 height=256 /&gt; &lt;img src=&quot;/images/img/2.jpg&quot; width=256 height=256 /&gt; 让图片居中的方法，使用div标签&lt;div align=center&gt; &lt;img src=&quot;/images/img/1.jpg&quot; width=256 height=256 /&gt; &lt;/div&gt; - 斜体- 用左右各一个 *的方式包裹住文字就是斜体的语法 - 粗体- 用左右各两个**的方式包裹住文字就是粗体的语法 - 改变字体大小- 一个字、一句话、一个段落加上#就可以改变字体的大小 - 分割线- 输入三个--就可以得到分割线 - 引用-在内容首位加入&gt;符号即可 - 表格1、 原生的表格语法 | 嘻嘻 | 哈哈 | 呵呵 | :------------- :|:-------------:| :-----:| | 你好|我好|大家好 | | 是的| 是的 | 是的 | 2、 也可以使用html语言来实现，实例如下 &lt;table&gt; &lt;tr&gt; &lt;th width=10%, bgcolor=yellow &gt;参数&lt;/th&gt; &lt;th width=40%, bgcolor=yellow&gt;详细解释&lt;/th&gt; &lt;th width=50%, bgcolor=yellow&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td bgcolor=#eeeeee&gt; -l &lt;/td&gt; &lt;td&gt; use a long listing format &lt;/td&gt; &lt;td&gt; 以长列表方式显示（显示出文件/文件夹详细信息） &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td bgcolor=#00FF00&gt;-t &lt;/td&gt; &lt;td&gt; sort by modification time &lt;/td&gt; &lt;td&gt; 按照修改时间排序（默认最近被修改的文件/文件夹排在最前面） &lt;/td&gt; &lt;tr&gt; &lt;td bgcolor=rgb(0,10,0)&gt;-r &lt;/td&gt; &lt;td&gt; reverse order while sorting &lt;/td&gt; &lt;td&gt; 逆序排列 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; html方式实现表格实例参数详细解释备注-luse a long listing format以长列表方式显示（显示出文件/文件夹详细信息）-tsort by modification time按照修改时间排序（默认最近被修改的文件/文件夹排在最前面）-rreverse order while sorting逆序排列","categories":[],"tags":[{"name":"git&markdown语法","slug":"git-markdown语法","permalink":"http://www.python100.com/tags/git-markdown语法/"}]}]}